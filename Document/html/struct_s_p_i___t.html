<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Nano102_112 Series BSP: SPI_T Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="M0Banner_v2.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Nano102_112 Series BSP
   &#160;<span id="projectnumber">V3.03.001</span>
   </div>
   <div id="projectbrief">The Board Support Package for  Nano102_112 Series</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">SPI_T Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a069fd6acdea1842f24bba35267ff3ea5"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a069fd6acdea1842f24bba35267ff3ea5">CTL</a></td></tr>
<tr class="separator:a069fd6acdea1842f24bba35267ff3ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4afe2cb0c518f0dff54c05986b987f33"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a4afe2cb0c518f0dff54c05986b987f33">STATUS</a></td></tr>
<tr class="separator:a4afe2cb0c518f0dff54c05986b987f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea1e761f8c180884bc051c73db22e13"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a6ea1e761f8c180884bc051c73db22e13">CLKDIV</a></td></tr>
<tr class="separator:a6ea1e761f8c180884bc051c73db22e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5d65619694a5df1436bb9bc1f548d4"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#acd5d65619694a5df1436bb9bc1f548d4">SSR</a></td></tr>
<tr class="separator:acd5d65619694a5df1436bb9bc1f548d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c47737acb74f2f2d9349a981d095b57"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a7c47737acb74f2f2d9349a981d095b57">RX0</a></td></tr>
<tr class="separator:a7c47737acb74f2f2d9349a981d095b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ec07fe66de05dbcb70bcce2a1f3272"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a62ec07fe66de05dbcb70bcce2a1f3272">RX1</a></td></tr>
<tr class="separator:a62ec07fe66de05dbcb70bcce2a1f3272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf28b6d289035f03cbe294af78b345b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a9bf28b6d289035f03cbe294af78b345b">RESERVE0</a> [2]</td></tr>
<tr class="separator:a9bf28b6d289035f03cbe294af78b345b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6b1c45e89186b0b38d4d5a03dfa063"><td class="memItemLeft" align="right" valign="top">__O uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a2e6b1c45e89186b0b38d4d5a03dfa063">TX0</a></td></tr>
<tr class="separator:a2e6b1c45e89186b0b38d4d5a03dfa063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390d2928ba639001d0282683b53ceaf3"><td class="memItemLeft" align="right" valign="top">__O uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a390d2928ba639001d0282683b53ceaf3">TX1</a></td></tr>
<tr class="separator:a390d2928ba639001d0282683b53ceaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff3af89b804bed7e4c2d7805fec32e4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a0ff3af89b804bed7e4c2d7805fec32e4">RESERVE1</a> [3]</td></tr>
<tr class="separator:a0ff3af89b804bed7e4c2d7805fec32e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762fced4160de55295b4d0854f24f66d"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a762fced4160de55295b4d0854f24f66d">VARCLK</a></td></tr>
<tr class="separator:a762fced4160de55295b4d0854f24f66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a436021c5a67252e0ae2e95d9ef9e4"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#af7a436021c5a67252e0ae2e95d9ef9e4">DMA</a></td></tr>
<tr class="separator:af7a436021c5a67252e0ae2e95d9ef9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd9a89d3d1c7a3a6f3e3c5c4beb0727"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a4cd9a89d3d1c7a3a6f3e3c5c4beb0727">FFCTL</a></td></tr>
<tr class="separator:a4cd9a89d3d1c7a3a6f3e3c5c4beb0727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267f2a01680881b9bb723e72a022af70"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a267f2a01680881b9bb723e72a022af70">RESERVE2</a> [4]</td></tr>
<tr class="separator:a267f2a01680881b9bb723e72a022af70"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">@addtogroup SPI Serial Peripheral Interface Controller(SPI)
Memory Mapped Structure for SPI Controller
</pre> 
<p class="definition">Definition at line <a class="el" href="_nano1_x2_series_8h_source.html#l08459">8459</a> of file <a class="el" href="_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>
</div><h2 class="groupheader">Field Documentation</h2>
<a id="a6ea1e761f8c180884bc051c73db22e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea1e761f8c180884bc051c73db22e13">&#9670;&nbsp;</a></span>CLKDIV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SPI_T::CLKDIV</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>CLKDIV </h1>
<h2>Offset: 0x08 SPI Clock Divider Register </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]  </td><td class="markdownTableBodyCenter">DIVIDER1  </td><td class="markdownTableBodyLeft">Clock Divider 1   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The value is the 1th frequency divider of the PCLK to generate the serial clock of SPI_SCLK.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The desired frequency is obtained according to the following equation: fsclk = feclk / (DIVIDER1 + 1)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Where feclk is the SPI peripheral clock source.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It is defined in the CLK_SEL2[21:20] in Clock control section (CLK_BA + 0x18).   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[23:16]  </td><td class="markdownTableBodyCenter">DIVIDER2  </td><td class="markdownTableBodyLeft">Clock Divider 2   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The value is the 2nd frequency divider of the PCLK to generate the serial clock of SPI_SCLK.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The desired frequency is obtained according to the following equation: fsclk = feclk / (DIVIDER2 + 1)   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano1_x2_series_8h_source.html#l08624">8624</a> of file <a class="el" href="_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="a069fd6acdea1842f24bba35267ff3ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a069fd6acdea1842f24bba35267ff3ea5">&#9670;&nbsp;</a></span>CTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SPI_T::CTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>CTL </h1>
<h2>Offset: 0x00 SPI Control Register </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]  </td><td class="markdownTableBodyCenter">GO_BUSY  </td><td class="markdownTableBodyLeft">SPI Transfer Control Bit And Busy Status   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Writing this bit "0" will stop data transfer if SPI is transferring.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = In Master mode, writing "1" to this bit will start the SPI data transfer; In Slave mode, writing '1' to this bit indicates that the salve is ready to communicate with a master.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the FIFO mode is disabled, during the data transfer, this bit keeps the value of '1'.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">As the transfer is finished, this bit will be cleared automatically.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Software can read this bit to check if the SPI is in busy status.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In FIFO mode, this bit will be controlled by hardware.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Software should not modify this bit.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In slave mode, this bit always returns 1 when software reads this register.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In master mode, this bit reflects the busy or idle status of SPI.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: When FIFO mode is disabled, all configurations should be set before writing "1" to the GO_BUSY bit in the SPI_CTL register.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: When FIFO bit is disabled and the software uses TX or RX PDMA function to transfer data, this bit will be cleared after the PDMA controller finishes the data transfer.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]  </td><td class="markdownTableBodyCenter">RX_NEG  </td><td class="markdownTableBodyLeft">Receive At Negative Edge   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The received data is latched on the rising edge of SPI_SCLK.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The received data is latched on the falling edge of SPI_SCLK.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2]  </td><td class="markdownTableBodyCenter">TX_NEG  </td><td class="markdownTableBodyLeft">Transmit At Negative Edge   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The transmitted data output is changed on the rising edge of SPI_SCLK.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The transmitted data output is changed on the falling edge of SPI_SCLK.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:3]  </td><td class="markdownTableBodyCenter">TX_BIT_LEN  </td><td class="markdownTableBodyLeft">Transmit Bit Length   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field specifies how many bits can be transmitted / received in one transaction.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The minimum bit length is 8 bits and can be up to 32 bits.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00000 = 32 bits are transmitted in one transaction.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01000 = 8 bits are transmitted in one transaction.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01001 = 9 bits are transmitted in one transaction.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01010 = 10 bits are transmitted in one transaction.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">--&mdash;   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11111 = 31 bits are transmitted in one transaction.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[10]  </td><td class="markdownTableBodyCenter">LSB  </td><td class="markdownTableBodyLeft">Send LSB First   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The MSB, which bit of transmit/receive register depends on the setting of TX_BITLEN, is transmitted/received first.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The LSB, bit 0 of the SPI_TX0/1, is sent first to the the SPI data output pin, and the first bit received from the SPI data input pin will be put in the LSB position of the SPI_RX register (SPI_RX0/1).   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[11]  </td><td class="markdownTableBodyCenter">CLKP  </td><td class="markdownTableBodyLeft">Clock Polarity   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The default level of SCLK is low.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The default level of SCLK is high.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[15:12]  </td><td class="markdownTableBodyCenter">SP_CYCLE  </td><td class="markdownTableBodyLeft">Suspend Interval (Master Only)   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">These four bits provide configurable suspend interval between two successive transmit/receive transaction in a transfer.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The suspend interval is from the last falling clock edge of the current transaction to the first rising clock edge of the successive transaction if CLKP = "0".   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If CLKP = "1", the interval is from the rising clock edge to the falling clock edge.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The default value is 0x3. The desired suspend interval is obtained according to the following equation:   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(SP_CYCLE[3:0) + 0.5) * period of SPICLK   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Ex:   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SP_CYCLE = 0x0 .... 0.5 SPICLK clock cycle.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SP_CYCLE = 0x1 .... 1.5 SPICLK clock cycle.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">......   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SP_CYCLE = 0xE .... 14.5 SPICLK clock cycle.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SP_CYCLE = 0xF .... 15.5 SPICLK clock cycle.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the Variable Clock function is enabled, the minimum period of suspend interval (the transmit data in FIFO buffer is not empty) between the successive transaction is (6.5 + SP_CYCLE) * SPICLK clock cycle   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[17]  </td><td class="markdownTableBodyCenter">INTEN  </td><td class="markdownTableBodyLeft">Interrupt Enable Control   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = SPI Interrupt Disabled.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = SPI Interrupt Enabled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[18]  </td><td class="markdownTableBodyCenter">SLAVE  </td><td class="markdownTableBodyLeft">Slave Mode   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = SPI controller set as Master mode.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = SPI controller set as Slave mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[19]  </td><td class="markdownTableBodyCenter">REORDER  </td><td class="markdownTableBodyLeft">Byte Reorder Function Enable Control   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disable byte reorder function.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enable byte reorder function and insert a byte suspend interval among each byte.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The setting of TX_BIT_LEN must be configured as 00b ( 32 bits/ word).   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The suspend interval is defined in SP_CYCLE.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Byte Suspend is only used in SPI Byte Reorder mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[21]  </td><td class="markdownTableBodyCenter">FIFOM  </td><td class="markdownTableBodyLeft">FIFO Mode Enable Control   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = FIFO mode Disabled (in Normal mode).   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = FIFO mode Enabled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[22]  </td><td class="markdownTableBodyCenter">TWOB  </td><td class="markdownTableBodyLeft">2-Bit Transfer Mode Active   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = 2-bit transfer mode Disabled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = 2-bit transfer mode Enabled.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23]  </td><td class="markdownTableBodyCenter">VARCLK_EN  </td><td class="markdownTableBodyLeft">Variable Clock Enable Control   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The serial clock output frequency is fixed and only decided by the value of DIVIDER1.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The serial clock output frequency is variable.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The output frequency is decided by the value of VARCLK (SPI_VARCLK), DIVIDER1, and DIVIDER2.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[28]  </td><td class="markdownTableBodyCenter">DUAL_IO_DIR  </td><td class="markdownTableBodyLeft">Dual IO Mode Direction   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Date read in the Dual I/O Mode function.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Data write in the Dual I/O Mode function.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[29]  </td><td class="markdownTableBodyCenter">DUAL_IO_EN  </td><td class="markdownTableBodyLeft">Dual IO Mode Enable Control   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Dual I/O Mode function Disabled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Dual I/O Mode function Enabled.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31]  </td><td class="markdownTableBodyCenter">WKEUP_EN  </td><td class="markdownTableBodyLeft">Wake-Up Enable Control   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Wake-up function Disabled.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Wake-up function Enabled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When the system enters Power-down mode, the system can be wake-up from the SPI controller when this bit is enabled and if there is any toggle in the SPICLK port.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">After the system wake-up, this bit must be cleared by user to disable the wake-up requirement.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano1_x2_series_8h_source.html#l08550">8550</a> of file <a class="el" href="_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="af7a436021c5a67252e0ae2e95d9ef9e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7a436021c5a67252e0ae2e95d9ef9e4">&#9670;&nbsp;</a></span>DMA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SPI_T::DMA</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>DMA </h1>
<h2>Offset: 0x38 SPI DMA Control Register </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]  </td><td class="markdownTableBodyCenter">TX_DMA_EN  </td><td class="markdownTableBodyLeft">Transmit PDMA Enable Control   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Transmit PDMA function Disabled.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Transmit PDMA function Enabled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: Two transaction need minimal 18 APB clock + 8 SPI peripheral clocks suspend interval in master mode for edge mode and 18 APB clock + 9.5 SPI peripheral clocks for level mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: If the 2-bit function is enabled, the requirement timing shall append 18 APB clock based on the above clock period.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Hardware will clear this bit to 0 automatically after PDMA transfer done.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]  </td><td class="markdownTableBodyCenter">RX_DMA_EN  </td><td class="markdownTableBodyLeft">Receiving PDMA Enable Control   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Receiver PDMA function Disabled.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Receiver PDMA function Enabled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Hardware will clear this bit to 0 automatically after PDMA transfer done.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In Slave mode and the FIFO bit is disabled, if the receive PDMA is enabled but the transmit PDMA is disabled, the minimal suspend interval between two successive transactions input is need to be larger than 9 SPI peripheral clock + 4 APB clock for edge mode and 9.5 SPI peripheral clock + 4 APB clock   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2]  </td><td class="markdownTableBodyCenter">PDMA_RST  </td><td class="markdownTableBodyLeft">PDMA Reset   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It is used to reset the SPI PDMA function into default state.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = After reset PDMA function or in normal operation.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Reset PDMA function.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: it is auto cleared to "0" after the reset function has done.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano1_x2_series_8h_source.html#l08803">8803</a> of file <a class="el" href="_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="a4cd9a89d3d1c7a3a6f3e3c5c4beb0727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd9a89d3d1c7a3a6f3e3c5c4beb0727">&#9670;&nbsp;</a></span>FFCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SPI_T::FFCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>FFCTL </h1>
<h2>Offset: 0x3C SPI FIFO Control Register </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]  </td><td class="markdownTableBodyCenter">RX_CLR  </td><td class="markdownTableBodyLeft">Receiving FIFO Counter Clear   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No clear the received FIFO.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Clear the received FIFO.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is used to clear the receiver counter in FIFO Mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit can be written "1" to clear the receiver counter and this bit will be cleared to "0" automatically after clearing receiving counter.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">After the clear operation, the flag of RX_EMPTY in SPI_STATUS[0] will be set to "1".   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]  </td><td class="markdownTableBodyCenter">TX_CLR  </td><td class="markdownTableBodyLeft">Transmitting FIFO Counter Clear   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No clear the transmitted FIFO.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Clear the transmitted FIFO.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is used to clear the transmit counter in FIFO Mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit can be written "1" to clear the transmitting counter and this bit will be cleared to "0" automatically after clearing transmitting counter.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">After the clear operation, the flag of TX_EMPTY in SPI_STATUS[2] will be set to "1".   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]  </td><td class="markdownTableBodyCenter">RXINT_EN  </td><td class="markdownTableBodyLeft">RX Threshold Interrupt Enable Control   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Rx threshold interrupt Disabled.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RX threshold interrupt Enable.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]  </td><td class="markdownTableBodyCenter">TXINT_EN  </td><td class="markdownTableBodyLeft">TX Threshold Interrupt Enable Control   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = TX threshold interrupt Disabled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = TX threshold interrupt Enable.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]  </td><td class="markdownTableBodyCenter">RXOVINT_EN  </td><td class="markdownTableBodyLeft">RX FIFO Over Run Interrupt Enable Control   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RX FIFO over run interrupt Disabled.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RX FIFO over run interrupt Enable.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[7]  </td><td class="markdownTableBodyCenter">TIMEOUT_EN  </td><td class="markdownTableBodyLeft">RX Read Time Out Function Enable Control   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RX read Timeout function Disabled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RX read Timeout function Enable.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[26:24]  </td><td class="markdownTableBodyCenter">RX_THRESHOLD  </td><td class="markdownTableBodyLeft">Received FIFO Threshold   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If RX valid data counts large than RXTHRESHOLD, RXINT_STS (SPI_STATUS[8]) will set to 1,.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[30:28]  </td><td class="markdownTableBodyCenter">TX_THRESHOLD  </td><td class="markdownTableBodyLeft">Transmit FIFO Threshold   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If TX valid data counts small or equal than TXTHRESHOLD, TXINT_STS (SPI_STATUS[10]) will set to 1.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano1_x2_series_8h_source.html#l08841">8841</a> of file <a class="el" href="_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="a9bf28b6d289035f03cbe294af78b345b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bf28b6d289035f03cbe294af78b345b">&#9670;&nbsp;</a></span>RESERVE0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SPI_T::RESERVE0[2]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_nano1_x2_series_8h_source.html#l08721">8721</a> of file <a class="el" href="_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="a0ff3af89b804bed7e4c2d7805fec32e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff3af89b804bed7e4c2d7805fec32e4">&#9670;&nbsp;</a></span>RESERVE1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SPI_T::RESERVE1[3]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_nano1_x2_series_8h_source.html#l08763">8763</a> of file <a class="el" href="_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="a267f2a01680881b9bb723e72a022af70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a267f2a01680881b9bb723e72a022af70">&#9670;&nbsp;</a></span>RESERVE2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SPI_T::RESERVE2[4]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_nano1_x2_series_8h_source.html#l08842">8842</a> of file <a class="el" href="_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="a7c47737acb74f2f2d9349a981d095b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c47737acb74f2f2d9349a981d095b57">&#9670;&nbsp;</a></span>RX0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t SPI_T::RX0</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>RX0 </h1>
<h2>Offset: 0x10 SPI Receive Data FIFO Register 0 </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]  </td><td class="markdownTableBodyCenter">RDATA  </td><td class="markdownTableBodyLeft">Receive Data FIFO Bits(Read Only)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The received data can be read on it.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the FIFO bit is set as 1, the user also checks the RX_EMPTY, SPI_STATUS[0], to check if there is any more received data or not.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: The SPI_RX1 is used only in TWOB bit (SPI_CTL[22]) is set 1.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The first channel's received data shall be read from SPI_RX0 and the second channel's received data shall be read from SPI_RX1 in two-bit mode.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SPI_RX0 shall be read first in TWOB mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In FIFO and two-bit mode, the first read back data in SPI_RX0 is the first channel data and the second read back data in SPI_RX0 is the second channel data.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: These registers are read only.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano1_x2_series_8h_source.html#l08702">8702</a> of file <a class="el" href="_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="a62ec07fe66de05dbcb70bcce2a1f3272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ec07fe66de05dbcb70bcce2a1f3272">&#9670;&nbsp;</a></span>RX1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t SPI_T::RX1</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>RX1 </h1>
<h2>Offset: 0x14 SPI Receive Data FIFO Register 1 </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]  </td><td class="markdownTableBodyCenter">RDATA  </td><td class="markdownTableBodyLeft">Receive Data FIFO Bits(Read Only)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The received data can be read on it.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the FIFO bit is set as 1, the user also checks the RX_EMPTY, SPI_STATUS[0], to check if there is any more received data or not.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: The SPI_RX1 is used only in TWOB bit (SPI_CTL[22]) is set 1.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The first channel's received data shall be read from SPI_RX0 and the second channel's received data shall be read from SPI_RX1 in two-bit mode.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SPI_RX0 shall be read first in TWOB mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In FIFO and two-bit mode, the first read back data in SPI_RX0 is the first channel data and the second read back data in SPI_RX0 is the second channel data.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: These registers are read only.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano1_x2_series_8h_source.html#l08720">8720</a> of file <a class="el" href="_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="acd5d65619694a5df1436bb9bc1f548d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5d65619694a5df1436bb9bc1f548d4">&#9670;&nbsp;</a></span>SSR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SPI_T::SSR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>SSR </h1>
<h2>Offset: 0x0C SPI Slave Select Register </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1:0]  </td><td class="markdownTableBodyCenter">SSR  </td><td class="markdownTableBodyLeft">Slave Select Active Register (Master Only)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If AUTOSS bit (SPI_SSR[3]) is cleared, writing "1" to SSR[0] bit sets the SPISS[0] line to an active state and writing "0" sets the line back to inactive state.(the same as SSR[1] for SPISS[1])   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">AUTOSS = 0.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Both SPISS[1] and SPISS[0] are inactive.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = SPISS[1] is inactive, SPISS[0] is active.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = SPISS[1] is active, SPISS[0] is inactive.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Both SPISS[1] and SPISS[0] are active.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If AUTOSS bit is set, writing "1" to any bit location of this field will select appropriate SPISS[1:0] line to be automatically driven to active state for the duration of the transaction, and will be driven to inactive state for the rest of the time.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(The active level of SPISS[1:0] is specified in SS_LVL).   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">AUTOSS =1.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Both SPISS[1] and SPISS[0] are inactive.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = SPISS[1] is inactive, SPISS[0] is active on the duration of transaction.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = SPISS[1] is active on the duration of transaction, SPISS[0] is inactive.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Both SPISS[1] and SPISS[0] are active on the duration of transaction.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This interface can only drive one device/slave at a given time.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Therefore, the slaves select of the selected device must be set to its active level before starting any read or write transfer.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: SPISS[0] is also defined as device/slave select input in Slave mode.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">And that the slave select input must be driven by edge active trigger which level depend on the SS_LVL setting, otherwise the SPI slave core will go into dead path until the edge active triggers again or reset the SPI core by software.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]  </td><td class="markdownTableBodyCenter">SS_LVL  </td><td class="markdownTableBodyLeft">Slave Select Active Level   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It defines the active level of device/slave select signal (SPISS[1:0]).   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The SPI_SS slave select signal is active Low.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The SPI_SS slave select signal is active High.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]  </td><td class="markdownTableBodyCenter">AUTOSS  </td><td class="markdownTableBodyLeft">Automatic Slave Selection (Master Only)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = If this bit is set as "0", slave select signals are asserted and de-asserted by setting and clearing related bits in SSR[1:0] register.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = If this bit is set as "1", SPISS[1:0] signals are generated automatically.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It means that device/slave select signal, which is set in SSR[1:0] register is asserted by the SPI controller when transmit/receive is started, and is de-asserted after each transaction is done.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]  </td><td class="markdownTableBodyCenter">SS_LTRIG  </td><td class="markdownTableBodyLeft">Slave Select Level Trigger   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The input slave select signal is edge-trigger.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The slave select signal will be level-trigger.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It depends on SS_LVL to decide the signal is active low or active high.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5]  </td><td class="markdownTableBodyCenter">NOSLVSEL  </td><td class="markdownTableBodyLeft">No Slave Selected In Slave Mode   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is used to ignore the slave select signal in Slave mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The SPI controller can work on 3 wire interface including SPICLK, SPI_MISO, and SPI_MOSI when it is set as a slave device.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The controller is 4-wire bi-direction interface.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The controller is 3-wire bi-direction interface in Slave mode.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When this bit is set as 1, the controller start to transmit/receive data after the GO_BUSY bit active and the serial clock input.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: In no slave select signal mode, the SS_LTRIG (SPI_SSR[4]) shall be set as "1".   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[8]  </td><td class="markdownTableBodyCenter">SLV_ABORT  </td><td class="markdownTableBodyLeft">Abort In Slave Mode With No Slave Selected   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No force the slave abort.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Force the current transfer done in no slave select mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: It is auto cleared to "0" by hardware when the abort event is active.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[9]  </td><td class="markdownTableBodyCenter">SSTA_INTEN  </td><td class="markdownTableBodyLeft">Slave Start Interrupt Enable Control   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Transfer start interrupt Disabled in no slave select mode.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Transaction start interrupt Enabled in no slave select mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It is cleared when the current transfer done or the SLV_START_INTSTS bit cleared (write 1 clear).   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[16]  </td><td class="markdownTableBodyCenter">SS_INT_OPT  </td><td class="markdownTableBodyLeft">Slave Select Interrupt Option   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It is used to enable the interrupt when the transfer has done in slave mode.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No any interrupt, even there is slave select inactive event.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = There is interrupt event when the slave select becomes inactive from active condition.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It is used to inform the user to know that the transaction has finished and the slave select into the inactive state.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano1_x2_series_8h_source.html#l08684">8684</a> of file <a class="el" href="_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="a4afe2cb0c518f0dff54c05986b987f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4afe2cb0c518f0dff54c05986b987f33">&#9670;&nbsp;</a></span>STATUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SPI_T::STATUS</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>STATUS </h1>
<h2>Offset: 0x04 SPI Status Register </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]  </td><td class="markdownTableBodyCenter">RX_EMPTY  </td><td class="markdownTableBodyLeft">Received FIFO_EMPTY Status   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Received data FIFO is not empty in the FIFO mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Received data FIFO is empty in the FIFO mode.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]  </td><td class="markdownTableBodyCenter">RX_FULL  </td><td class="markdownTableBodyLeft">Received FIFO_FULL Status   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Received data FIFO is not full in FIFO mode.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Received data FIFO is full in the FIFO mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]  </td><td class="markdownTableBodyCenter">TX_EMPTY  </td><td class="markdownTableBodyLeft">Transmitted FIFO_EMPTY Status   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Transmitted data FIFO is not empty in the FIFO mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 =Transmitted data FIFO is empty in the FIFO mode.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]  </td><td class="markdownTableBodyCenter">TX_FULL  </td><td class="markdownTableBodyLeft">Transmitted FIFO_FULL Status   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Transmitted data FIFO is not full in the FIFO mode.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Transmitted data FIFO is full in the FIFO mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]  </td><td class="markdownTableBodyCenter">LTRIG_FLAG  </td><td class="markdownTableBodyLeft">Level Trigger Accomplish Flag (INTERNAL ONLY)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In Slave mode, this bit indicates whether the received bit number meets the requirement or not after the current transaction done.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The transferred bit length of one transaction does not meet the specified requirement.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The transferred bit length meets the specified requirement which defined in TX_BIT_LEN.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is READ only.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">As the software sets the GO_BUSY bit to 1, the LTRIG_FLAG will be cleared to 0 after 4 SPI engine clock periods plus 1 system clock period.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In FIFO mode, this bit is unmeaning.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[6]  </td><td class="markdownTableBodyCenter">SLV_START_INTSTS  </td><td class="markdownTableBodyLeft">Slave Start Interrupt Status   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It is used to dedicate that the transfer has started in Slave mode with no slave select.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Slave started transfer no active.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Transfer has started in Slave mode with no slave select.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It is auto clear by transfer done or writing one clear.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7]  </td><td class="markdownTableBodyCenter">INTSTS  </td><td class="markdownTableBodyLeft">Interrupt Status   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Transfer is not finished yet.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Transfer is done. The interrupt is requested when the INTEN(SPI_CTL[17]) bit is enabled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only, but can be cleared by writing "1" to this bit.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[8]  </td><td class="markdownTableBodyCenter">RXINT_STS  </td><td class="markdownTableBodyLeft">RX FIFO Threshold Interrupt Status (Read Only)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RX valid data counts small or equal than RXTHRESHOLD (SPI_FFCTL[27:24]).   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RX valid data counts bigger than RXTHRESHOLD.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: If RXINT_EN(SPI_FFCTL[2]) = 1 and RX_INTSTS = 1, SPI will generate interrupt.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[9]  </td><td class="markdownTableBodyCenter">RX_OVER_RUN  </td><td class="markdownTableBodyLeft">RX FIFO Over Run Status   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No FIFO is over run.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Receive FIFO over run.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: If SPI receives data when RX FIFO is full, this bit will set to 1, and the received data will dropped.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: This bit will be cleared by writing 1 to it.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[10]  </td><td class="markdownTableBodyCenter">TXINT_STS  </td><td class="markdownTableBodyLeft">TX FIFO Threshold Interrupt Status (Read Only)   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = TX valid data counts bigger than TXTHRESHOLD (SPI_FFCTL[31:28].   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = TX valid data counts small or equal than TXTHRESHOLD.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[12]  </td><td class="markdownTableBodyCenter">TIME_OUT_STS  </td><td class="markdownTableBodyLeft">TIMEOUT Interrupt Flag   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = There is not timeout event on the received buffer.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Time out event active in RX FIFO is not empty.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit will be cleared by writing 1 to it.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[19:16]  </td><td class="markdownTableBodyCenter">RX_FIFO_CNT  </td><td class="markdownTableBodyLeft">Data counts in RX FIFO (Read Only)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[23:20]  </td><td class="markdownTableBodyCenter">TX_FIFO_CNT  </td><td class="markdownTableBodyLeft">Data counts in TX FIFO (Read Only)   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano1_x2_series_8h_source.html#l08606">8606</a> of file <a class="el" href="_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="a2e6b1c45e89186b0b38d4d5a03dfa063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e6b1c45e89186b0b38d4d5a03dfa063">&#9670;&nbsp;</a></span>TX0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__O uint32_t SPI_T::TX0</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>TX0 </h1>
<h2>Offset: 0x20 SPI Transmit Data FIFO Register 0 </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]  </td><td class="markdownTableBodyCenter">TDATA  </td><td class="markdownTableBodyLeft">Transmit Data FIFO Bits(Write Only)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The Data Transmit Registers hold the data to be transmitted in the next transfer.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The number of valid bits depends on the setting of transmit bit length field of the SPI_CTL register.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For example, if TX_BIT_LEN is set to 0x8, the bit SPI_TX[7:0] will be transmitted in next transfer.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If TX_BIT_LEN is set to 0x0, the SPI controller will perform a 32-bit transfer.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: The SPI_TX1 is used only in TWOB bit (SPI_CTL[22]) is set 1.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The first channel's transmitted data shall be written into SPI_TX0 and the second channel's transmitted data shall be written into SPI_TX1 in two-bit mode.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SPI_TX0 shall be written first in TWOB mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In FIFO and two-bit mode, the first written into data in SPI_TX0 is the first channel's transmitted data and the second written data in SPI_RX0 is the second channel's transmitted data.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: When the SPI controller is configured as a slave device and the FIFO mode is disabled, if the SPI controller attempts to transmit data to a master, the software must update the transmit data register before setting the GO_BUSY bit to 1.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano1_x2_series_8h_source.html#l08742">8742</a> of file <a class="el" href="_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="a390d2928ba639001d0282683b53ceaf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390d2928ba639001d0282683b53ceaf3">&#9670;&nbsp;</a></span>TX1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__O uint32_t SPI_T::TX1</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>TX1 </h1>
<h2>Offset: 0x24 SPI Transmit Data FIFO Register 1 </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]  </td><td class="markdownTableBodyCenter">TDATA  </td><td class="markdownTableBodyLeft">Transmit Data FIFO Bits(Write Only)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The Data Transmit Registers hold the data to be transmitted in the next transfer.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The number of valid bits depends on the setting of transmit bit length field of the SPI_CTL register.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For example, if TX_BIT_LEN is set to 0x8, the bit SPI_TX[7:0] will be transmitted in next transfer.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If TX_BIT_LEN is set to 0x0, the SPI controller will perform a 32-bit transfer.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: The SPI_TX1 is used only in TWOB bit (SPI_CTL[22]) is set 1.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The first channel's transmitted data shall be written into SPI_TX0 and the second channel's transmitted data shall be written into SPI_TX1 in two-bit mode.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SPI_TX0 shall be written first in TWOB mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In FIFO and two-bit mode, the first written into data in SPI_TX0 is the first channel's transmitted data and the second written data in SPI_RX0 is the second channel's transmitted data.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: When the SPI controller is configured as a slave device and the FIFO mode is disabled, if the SPI controller attempts to transmit data to a master, the software must update the transmit data register before setting the GO_BUSY bit to 1.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano1_x2_series_8h_source.html#l08762">8762</a> of file <a class="el" href="_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="a762fced4160de55295b4d0854f24f66d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762fced4160de55295b4d0854f24f66d">&#9670;&nbsp;</a></span>VARCLK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SPI_T::VARCLK</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>VARCLK </h1>
<h2>Offset: 0x34 SPI Variable Clock Pattern Flag Register </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]  </td><td class="markdownTableBodyCenter">VARCLK  </td><td class="markdownTableBodyLeft">Variable Clock Pattern Flag   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The value in this field is the frequency patterns of the SPICLK.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: It is used for CLKP = 0 only.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano1_x2_series_8h_source.html#l08777">8777</a> of file <a class="el" href="_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>Device/Nuvoton/Nano1X2Series/Include/<a class="el" href="_nano1_x2_series_8h_source.html">Nano1X2Series.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Nov 7 2019 08:54:03 for Nano102_112 Series BSP by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
