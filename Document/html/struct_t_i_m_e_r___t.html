<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Nano102_112 Series BSP: TIMER_T Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="M0Banner_v2.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Nano102_112 Series BSP
   &#160;<span id="projectnumber">V3.03.001</span>
   </div>
   <div id="projectbrief">The Board Support Package for  Nano102_112 Series</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">TIMER_T Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:abb8d9df4695b742a04b52a7a64594322"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_t_i_m_e_r___t.html#abb8d9df4695b742a04b52a7a64594322">CTL</a></td></tr>
<tr class="separator:abb8d9df4695b742a04b52a7a64594322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a66d55fb7d20c3e12402aa320661d8f"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_t_i_m_e_r___t.html#a6a66d55fb7d20c3e12402aa320661d8f">PRECNT</a></td></tr>
<tr class="separator:a6a66d55fb7d20c3e12402aa320661d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91eb63011da0934d7d8edcfb58566417"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_t_i_m_e_r___t.html#a91eb63011da0934d7d8edcfb58566417">CMPR</a></td></tr>
<tr class="separator:a91eb63011da0934d7d8edcfb58566417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b93de0ad6cd08676926bcff6888c10d"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_t_i_m_e_r___t.html#a1b93de0ad6cd08676926bcff6888c10d">IER</a></td></tr>
<tr class="separator:a1b93de0ad6cd08676926bcff6888c10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7679f758ebbdcf746f8b03195364b47"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_t_i_m_e_r___t.html#aa7679f758ebbdcf746f8b03195364b47">ISR</a></td></tr>
<tr class="separator:aa7679f758ebbdcf746f8b03195364b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5ea6a1af3b26e732ffec08d4d519f5"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_t_i_m_e_r___t.html#a7f5ea6a1af3b26e732ffec08d4d519f5">DR</a></td></tr>
<tr class="separator:a7f5ea6a1af3b26e732ffec08d4d519f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4508d4ae8dda154e5e796090fcafff3"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_t_i_m_e_r___t.html#ac4508d4ae8dda154e5e796090fcafff3">TCAP</a></td></tr>
<tr class="separator:ac4508d4ae8dda154e5e796090fcafff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ecc606ca7cfd8c6693ec2d396b9e3d8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_t_i_m_e_r___t.html#a9ecc606ca7cfd8c6693ec2d396b9e3d8">RESERVE0</a> [1]</td></tr>
<tr class="separator:a9ecc606ca7cfd8c6693ec2d396b9e3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e91877db4ad3b35116bbd1c281bda6"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_t_i_m_e_r___t.html#af6e91877db4ad3b35116bbd1c281bda6">ECTL</a></td></tr>
<tr class="separator:af6e91877db4ad3b35116bbd1c281bda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">@addtogroup TIMER Timer Controller(TIMER)
Memory Mapped Structure for TMR Controller
</pre> 
<p class="definition">Definition at line <a class="el" href="_nano1_x2_series_8h_source.html#l09026">9026</a> of file <a class="el" href="_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>
</div><h2 class="groupheader">Field Documentation</h2>
<a id="a91eb63011da0934d7d8edcfb58566417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91eb63011da0934d7d8edcfb58566417">&#9670;&nbsp;</a></span>CMPR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t TIMER_T::CMPR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>CMPR </h1>
<h2>Offset: 0x08 Timer x Compare Register </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23:0]  </td><td class="markdownTableBodyCenter">TMR_CMP  </td><td class="markdownTableBodyLeft">Timer Compared Value   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">TMR_CMP is a 24-bit compared register.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the internal 24-bit up-counter counts and its value is equal to TMR_CMP value, a Timer Interrupt is requested if the timer interrupt is enabled with TMR_EN (TMRx_CTL [0]) is enabled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The TMR_CMP value defines the timer counting cycle time.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Time-out period = (Period of timer clock input) * (8-bit PRESCALE_CNT + 1) * (24-bit TMR_CMP).   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: Never write 0x0 or 0x1 in TMR_CMP, or the core will run into unknown state.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: No matter TMR_EN (TMRx_CTL [0]) is 0 or 1, whenever software write a new value into this register, TIMER will restart counting using this new value and abort previous count.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano1_x2_series_8h_source.html#l09207">9207</a> of file <a class="el" href="_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="abb8d9df4695b742a04b52a7a64594322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8d9df4695b742a04b52a7a64594322">&#9670;&nbsp;</a></span>CTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t TIMER_T::CTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>CTL </h1>
<h2>Offset: 0x00 Timer x Control Register </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]  </td><td class="markdownTableBodyCenter">TMR_EN  </td><td class="markdownTableBodyLeft">Timer Counter Enable Control   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Stops/Suspends counting.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Starts counting.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: Set TMR_EN to 1 enables 24-bit counter keeps up counting from the last stop counting value.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: This bit is auto-cleared by hardware in one-shot mode (MODE_SEL (TMRx_CTL[5:4]) = 00) once the value of 24-bit up counter equals the TMRx_CMPR.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]  </td><td class="markdownTableBodyCenter">SW_RST  </td><td class="markdownTableBodyLeft">Software Reset   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set this bit will reset the timer counter, pre-scale counter and also force TMR_EN (TMRx_CTL [0]) to 0.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No effect.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Reset Timer's pre-scale counter, internal 24-bit up-counter and TMR_EN (TMRx_CTL [0]) bit.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit will be auto cleared and takes at least 3 TMRx_CLK clock cycles.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]  </td><td class="markdownTableBodyCenter">WAKE_EN  </td><td class="markdownTableBodyLeft">Wake-Up Enable Control   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When WAKE_EN is set and the TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1]) is set, the timer controller will generate a wake-up trigger event to CPU.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Wake-up trigger event Disabled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Wake-up trigger event Enabled.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]  </td><td class="markdownTableBodyCenter">DBGACK_EN  </td><td class="markdownTableBodyLeft">ICE Debug Mode Acknowledge Ineffective Enable Control   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = ICE debug mode acknowledgement effects TIMER counting and TIMER counter will be held while ICE debug mode acknowledged.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = ICE debug mode acknowledgement is ineffective and TIMER counter will keep going no matter ICE debug mode acknowledged or not.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5:4]  </td><td class="markdownTableBodyCenter">MODE_SEL  </td><td class="markdownTableBodyLeft">Timer Operating Mode Select   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = The timer is operating in the one-shot mode.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In this mode, the associated interrupt signal is generated (if TMR_IER [TMR_IE] is enabled) once the value of 24-bit up counter equals the TMRx_CMPR.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">And TMR_CTL [TMR_EN] is automatically cleared by hardware.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = The timer is operating in the periodic mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In this mode, the associated interrupt signal is generated periodically (if TMR_IER [TMR_IE] is enabled) while the value of 24-bit up counter equals the TMRx_CMPR.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">After that, the 24-bit counter will be reset and starts counting from zero again.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = The timer is operating in the periodic mode with output toggling.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In this mode, the associated interrupt signal is generated periodically (if TMR_IER [TMR_IE] is enabled) while the value of 24-bit up counter equals the TMRx_CMPR.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">After that, the 24-bit counter will be reset and starts counting from zero again.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">At the same time, timer controller will also toggle the output pin TMRx_TOG_OUT to its inverse level (from low to high or from high to low).   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: The default level of TMRx_TOG_OUT after reset is low.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = The timer is operating in continuous counting mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In this mode, the associated interrupt signal is generated when TMR_DR = TMR_CMPR (if TMR_IER [TMR_IE] is enabled).   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">However, the 24-bit up-counter counts continuously without reset.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6]  </td><td class="markdownTableBodyCenter">ACMP_EN_TMR  </td><td class="markdownTableBodyLeft">ACMP Trigger Timer Enable Control   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit high enables the functionality that when ACMP0 is in sigma-delta mode, it could enable Timer.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = ACMP0 trigger timer functionality disabled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = ACMP0 trigger timer functionality enabled.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7]  </td><td class="markdownTableBodyCenter">TMR_ACT  </td><td class="markdownTableBodyLeft">Timer Active Status Bit (Read Only)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates the timer counter status of timer.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Timer is not active.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Timer is in active.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[8]  </td><td class="markdownTableBodyCenter">ADC_TEEN  </td><td class="markdownTableBodyLeft">Timer Trigger ADC Enable Control   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit controls if TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1]) could trigger ADC.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When ADC_TEEN is set, TMR_IS (TMRx_ISR[0]) is set and the CAP_TRG_EN (TMRx_CTL[11]) is low, the timer controller will generate an internal trigger event to ADC controller.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When ADC_TEEN is set, TCAP_IS (TMRx_ISR[1]) is set and the CAP_TRG_EN (TMRx_CTL[11]) is high, the timer controller will generate an internal trigger event to ADC controller.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1]) trigger ADC Disabled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1]) trigger ADC Enabled.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[10]  </td><td class="markdownTableBodyCenter">PDMA_TEEN  </td><td class="markdownTableBodyLeft">Timer Trigger PDMA Enable Control   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit controls if TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1]) could trigger PDMA.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When PDMA_TEEN is set, TMR_IS (TMRx_ISR[0]) is set and the CAP_TRG_EN (TMRx_CTL[11]) is low, the timer controller will generate an internal trigger event to PDMA controller.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When PDMA_TEEN is set, TCAP_IS (TMRx_ISR[1]) is set and the CAP_TRG_EN (TMRx_CTL[11]) is high, the timer controller will generate an internal trigger event to PDMA controller.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1]) trigger PDMA Disabled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1]) trigger PDMA Enabled.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[11]  </td><td class="markdownTableBodyCenter">CAP_TRG_EN  </td><td class="markdownTableBodyLeft">TCAP_IS Trigger Mode Enable   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit controls if the TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1]) is used to trigger PDMA and ADC while TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1]) is set.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If this bit is low and TMR_IS (TMRx_ISR[0]) is set, timer will generate an internal trigger event to PDMA or ADC while related trigger enable bit (PDMA_TEEN (TMRx_CTL[10]) or ADC_TEEN (TMRx_CTL[8])) is set.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If this bit is set high and TCAP_IS (TMRx_ISR[0]) is set, timer will generate an internal trigger event to PDMA or ADC while related trigger enable bit (PDMA_TEEN (TMRx_CTL[10]) or ADC_TEEN (TMRx_CTL[8])) is set.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = TMR_IS (TMRx_ISR[0]) is used to trigger PDMA and ADC.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = TCAP_IS (TMRx_ISR[1]) is used to trigger PDMA and ADC.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[12]  </td><td class="markdownTableBodyCenter">EVENT_EN  </td><td class="markdownTableBodyLeft">Event Counting Mode Enable Control   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When EVENT_EN is set, the increase of 24-bit up-counting timer is controlled by external event pin.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">While the transition of external event pin matches the definition of EVENT_EDGE (TMRx_CTL[13]), the 24-bit up-counting timer increases by 1.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Or, the 24-bit up-counting timer will keep its value unchanged.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Timer counting is not controlled by external event pin.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Timer counting is controlled by external event pin.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[13]  </td><td class="markdownTableBodyCenter">EVENT_EDGE  </td><td class="markdownTableBodyLeft">Event Counting Mode Edge Selection   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates which edge of external event pin enabling the timer to increase 1.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = A falling edge of external event enabling the timer to increase 1.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = A rising edge of external event enabling the timer to increase 1.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[14]  </td><td class="markdownTableBodyCenter">EVNT_DEB_EN  </td><td class="markdownTableBodyLeft">External Event De-Bounce Enable Control   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When EVNT_DEB_EN is set, the external event pin de-bounce circuit will be enabled to eliminate the bouncing of the signal.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In de-bounce circuit the external event pin will be sampled 4 times by TMRx_CLK.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = De-bounce circuit Disabled.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = De-bounce circuit Enabled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When EVENT_EN (TMRx_CTL[12]) is enabled, enable this bit is recommended.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">And, while EVENT_EN (TMRx_CTL[12]) is disabled, disable this bit is recommended to save power consumption.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[16]  </td><td class="markdownTableBodyCenter">TCAP_EN  </td><td class="markdownTableBodyLeft">TC Pin Functional Enable Control   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit controls if the transition on TC pin could be used as timer counter reset function or timer capture function.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The transition on TC pin is ignored.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The transition on TC pin will result in the capture or reset of 24-bit timer counter.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For TMRx_CTL, if INTR_TRG_EN (TMRx_CTL[24]) is set, the TCAP_EN will be forced to low and the TC pin transition is ignored (where x = 0 or 2).   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For TMRx+1_CTL, if INTR_TRG_EN (TMRx_CTL[24]) is set, the TCAP_EN will be forced to high (where x = 0 or 2).   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[17]  </td><td class="markdownTableBodyCenter">TCAP_MODE  </td><td class="markdownTableBodyLeft">TC Pin Function Mode Selection   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates if the transition on TC pin is used as timer counter reset function or timer capture function.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The transition on TC pin is used as timer capture function.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The transition on TC pin is used as timer counter reset function.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For TMRx+1_CTL, if INTR_TRG_EN (TMRx_CTL[24]) is set, the TCAP_MODE will be forced to low (where x = 0 or 2).   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[19:18]  </td><td class="markdownTableBodyCenter">TCAP_EDGE  </td><td class="markdownTableBodyLeft">TC Pin Edge Detect Selection   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field defines that active transition of Tcapture pin is for timer counter reset function or for timer capture function.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For timer counter reset function and free-counting mode of timer capture function, the configurations are:   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = A falling edge (1 to 0 transition) on Tcapture pin is an active transition.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = A rising edge (0 to 1 transition) on Tcapture pin is an active transition.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Both falling edge (1 to 0 transition) and rising edge (0 to 1 transition) on Tcapture pin are active transitions.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Both falling edge (1 to 0 transition) and rising edge (0 to 1 transition) on Tcapture pin are active transitions.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For trigger-counting mode of timer capture function, the configurations are:   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = 1st falling edge on Tcapture pin triggers 24-bit timer to start counting, while 2nd falling edge triggers 24-bit timer to stop counting.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = 1st rising edge on Tcapture pin triggers 24-bit timer to start counting, while 2nd rising edge triggers 24-bit timer to stop counting.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Falling edge on Tcapture pin triggers 24-bit timer to start counting, while rising edge triggers 24-bit timer to stop counting.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Rising edge on Tcapture pin triggers 24-bit timer to start counting, while falling edge triggers 24-bit timer to stop counting.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For TMRx+1_CTL, if INTR_TRG_EN is set, the TCAP_EDGE will be forced to 11.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[20]  </td><td class="markdownTableBodyCenter">TCAP_CNT_MOD  </td><td class="markdownTableBodyLeft">Timer Capture Counting Mode Selection   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates the behavior of 24-bit up-counting timer while TCAP_EN (TMRx_CTL[16]) is set to high.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If this bit is 0, the free-counting mode, the behavior of 24-bit up-counting timer is defined by MODE_SEL (TMRx_CTL[5:4]) field.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When TCAP_EN (TMRx_CTL[16]) is set, TCAP_MODE (TMRx_CTL[17]) is 0, and the transition of TC pin matches the TCAP_EDGE (TMRx_CTL[19:18]) setting, the value of 24-bit up-counting timer will be saved into register TMRx_TCAP.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If this bit is 1, Trigger-counting mode, 24-bit up-counting timer will be not counting and keep its value at 0.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When TCAP_EN (TMRx_CTL[16]) is set, TCAP_MODE (TMRx_CTL[17]) is 0, and once the transition of external pin matches the 1st transition of TCAP_EDGE (TMRx_CTL[19:18]) setting, the 24-bit up-counting timer will start counting.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">And then if the transition of external pin matches the 2nd transition of TCAP_EDGE (TMRx_CTL[19:18]) setting, the 24-bit up-counting timer will stop counting.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">And its value will be saved into register TMRx_TCAP.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Capture with free-counting timer mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Capture with trigger-counting timer mode.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For TMRx+1_CTL, if INTR_TRG_EN (TMRx_CTL[24]) is set, the TCAP_CNT_MOD will be forced to high, the capture with Trigger-counting Timer mode (where x = 0 or 2).   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[22]  </td><td class="markdownTableBodyCenter">TCAP_DEB_EN  </td><td class="markdownTableBodyLeft">TC Pin De-Bounce Enable Control   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When CAP_DEB_EN (TMRx_CTL[22]) is set, the TC pin de-bounce circuit will be enabled to eliminate the bouncing of the signal.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In de-bounce circuit the TC pin signal will be sampled 4 times by TMRx_CLK.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = De-bounce circuit Disabled.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = De-bounce circuit Enabled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When TCAP_EN (TMRx_CTL[16]) is enabled, enable this bit is recommended.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">And, while TCAP_EN (TMRx_CTL[16]) is disabled, disable this bit is recommended to save power consumption.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When CAP_SRC (TMRx_ECTL[16]) is high, the capture signal is from internal of chip and the de-bounce circuit would not take effect no matter this bit is high or low.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For Timer 1 and 3, when INTR_TRG_EN (TMRx_CTL[24]) is high, the capture signal is from internal of chip and the de-bounce circuit would not take effect no matter this bit is high or low.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[24]  </td><td class="markdownTableBodyCenter">INTR_TRG_EN  </td><td class="markdownTableBodyLeft">Inter-Timer Trigger Function Enable Control   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit controls if Inter-timer Trigger function is enabled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If Inter-timer Trigger function is enabled, the TMRx will be in counter mode and counting with external Clock Source or event.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In addition, TMRx+1 will be in trigger-counting mode of capture function.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Inter-timer trigger function Disabled.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Inter-timer trigger function Enabled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For TMRx+1_CTL, this bit is ignored and the read back value is always 0.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[25]  </td><td class="markdownTableBodyCenter">INTR_TRG_MODE  </td><td class="markdownTableBodyLeft">Inter-Timer Trigger Mode Selection   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit controls the timer operation mode when inter-timer trigger function is enabled.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When this bit is low, the TMRx will be in counter mode and counting with external Clock Source or event.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In addition, TMRx+1 will be in trigger-counting mode of capture function.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In this mode, TMRx_CMPR control when inter-timer trigger function terminated.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When this bit is high, the TMRx will be in counter mode and counting with external Clock Source or event.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In addition, TMRx+1 will be in trigger-counting mode of capture function.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In this mode, TMRx+1_CMPR control when inter-timer trigger function terminated.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In this mode, TMRx would ignore some incoming event based on the EVNT_DROP_CNT (TMRx_ECTL[31:24]).   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">And once the TMRx+1 counter value equal or large than TMRx+1_CMPR, TMRx would terminate the operation when next incoming event received.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Inter-Timer Trigger function wouldn't ignore any incoming event.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Inter-Timer Trigger function would ignore incoming event based on the EVNT_DROP_CNT (TMRx_ECTL[31:24]).   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For TMRx+1_CTL, this bit is ignored and the read back value is always 0.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano1_x2_series_8h_source.html#l09177">9177</a> of file <a class="el" href="_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="a7f5ea6a1af3b26e732ffec08d4d519f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f5ea6a1af3b26e732ffec08d4d519f5">&#9670;&nbsp;</a></span>DR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t TIMER_T::DR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>DR </h1>
<h2>Offset: 0x14 Timer 0 Data Register </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23:0]  </td><td class="markdownTableBodyCenter">TDR  </td><td class="markdownTableBodyLeft">Timer Data Register (Read)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">User can read this register for internal 24-bit timer up-counter value.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Counter Reset (Write)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">User can write any value to this register to reset internal 24-bit timer up-counter and 8-bit pre-scale counter.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This reset operation wouldn't affect any other timer control registers and circuit.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">After reset completed, the 24-bit timer up-counter and 8-bit pre-scale counter restart the counting based on the TMRx_CTL register setting.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31]  </td><td class="markdownTableBodyCenter">RSTACT  </td><td class="markdownTableBodyLeft">Reset Active   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates if the counter reset operation active.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When user write this register, timer starts to reset its internal 24-bit timer up-counter and 8-bit pre-scale counter to 0.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In the same time, timer set this flag to 1 to indicate the counter reset operation is in progress.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Once the counter reset operation done, timer clear this bit to 0 automatically.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Reset operation done.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Reset operation triggered by writing TMR_DR is in progress.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only. Write operation wouldn't take any effect.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano1_x2_series_8h_source.html#l09286">9286</a> of file <a class="el" href="_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="af6e91877db4ad3b35116bbd1c281bda6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6e91877db4ad3b35116bbd1c281bda6">&#9670;&nbsp;</a></span>ECTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t TIMER_T::ECTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>ECTL </h1>
<h2>Offset: 0x20 Timer x Extended Control Register </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]  </td><td class="markdownTableBodyCenter">EVNT_GEN_EN  </td><td class="markdownTableBodyLeft">Event Generator Function Enable Control   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When this bit is high, timer would generate a high pulse event out when it increases the 24-bit up counter and the polarity of signal defined by EVNT_GEN_SRC (TMRx_ECTL[12]) is same as the polarity defined by EVNT_GEN_POL (TMRx_ECTL[1]).   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Event generator function disabled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Event generator function enabled.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]  </td><td class="markdownTableBodyCenter">EVNT_GEN_POL  </td><td class="markdownTableBodyLeft">Event Generator Reference Input Source Polarity Selection   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When this bit is low and EVNT_GEN_EN (TMRx_ECTL[0]) is high, timer would generate a high pulse event out when it increases the 24-bit up counter and the polarity of signal defined by EVNT_GEN_SRC (TMRx_ECTL[12]) is low.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When this bit is high and EVNT_GEN_EN (TMRx_ECTL[0]) is high, timer would generate a low pulse event pulse out when it increases the 24-bit up counter and the polarity of signal defined by EVNT_GEN_SRC (TMRx_ECTL[12]) is high.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit only affects timer's operation when EVNT_GEN_EN (TMRx_ECTL[0]) is high.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Timer generates a high pulse event out when it increase the 24-bit up counter and the polarity of signal defined by EVNT_GEN_SRC (TMRx_ECTL[12]) is low.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Timer generates a high pulse event out when it increase the 24-bit up counter and the polarity of signal defined by EVNT_GEN_SRC (TMRx_ECTL[12]) is high.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[8]  </td><td class="markdownTableBodyCenter">EVNT_CNT_SRC  </td><td class="markdownTableBodyLeft">Event Counting Source Selection   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit defines the TMRx+1 event counting source is from external event pin TMx+1 or internal signal from TMRx's event generator output (where x = 0 or 2).   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The event counting source is from external event pin.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The event counting source is from TMRx's event generator output.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is only available in TMRx+1 (where x = 0 or 2).   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[12]  </td><td class="markdownTableBodyCenter">EVNT_GEN_SRC  </td><td class="markdownTableBodyLeft">Event Generator Reference Input Source Selection   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit defines the event generator function controlled by external event pin or internal event signals from ACMP0.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The event generator reference source is from external event pin.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The event generator reference source is from ACMP0.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is only available in TMRx (where x = 0 or 2).   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[16]  </td><td class="markdownTableBodyCenter">CAP_SRC  </td><td class="markdownTableBodyLeft">Capture Function Source Selection   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit defines timer counter reset function or timer capture function controlled by transition of TC pin or transition of internal signals from other functional blocks of this chip.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Transition of TC pin selected.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Transition of internal signals from ACMP0.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When this bit is high, the EVNT_DEB_EN (TMRx_CTL[14]) would not take effect.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[31:24]  </td><td class="markdownTableBodyCenter">EVNT_DROP_CNT  </td><td class="markdownTableBodyLeft">Event Drop Count   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field indicates timer to drop how many events after inter-timer trigger function enable.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For example, if user writes 0x7 to this field, timer would drop 7 first incoming events and starts the inter-timer trigger operation when it get 8th event.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field would affect timer's operation only when inter-timer trigger function enabled (INTR_TRG_EN (TMRx_CTL[24]) = 1) and ITNR_TRG_MODE (TMRx_CTL[25]) = 1.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano1_x2_series_8h_source.html#l09342">9342</a> of file <a class="el" href="_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="a1b93de0ad6cd08676926bcff6888c10d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b93de0ad6cd08676926bcff6888c10d">&#9670;&nbsp;</a></span>IER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t TIMER_T::IER</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>IER </h1>
<h2>Offset: 0x0C Timer x Interrupt Enable Register </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]  </td><td class="markdownTableBodyCenter">TMR_IE  </td><td class="markdownTableBodyLeft">Timer Interrupt Enable Control   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Timer Interrupt Disabled.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Timer Interrupt Enabled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: If timer interrupt is enabled, the timer asserts its interrupt signal when the associated counter is equal to TMR_CMPR.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]  </td><td class="markdownTableBodyCenter">TCAP_IE  </td><td class="markdownTableBodyLeft">Timer Capture Function Interrupt Enable Control   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Timer External Pin Function Interrupt Disabled.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Timer External Pin Function Interrupt Enabled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: If timer external pin function interrupt is enabled, the timer asserts its interrupt signal when the TCAP_EN (TMRx_CTL[16]) is set and the transition of external pin matches the TCAP_EDGE (TMRx_CTL[19:18]) setting   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano1_x2_series_8h_source.html#l09225">9225</a> of file <a class="el" href="_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="aa7679f758ebbdcf746f8b03195364b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7679f758ebbdcf746f8b03195364b47">&#9670;&nbsp;</a></span>ISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t TIMER_T::ISR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>ISR </h1>
<h2>Offset: 0x10 Timer x Interrupt Status Register </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]  </td><td class="markdownTableBodyCenter">TMR_IS  </td><td class="markdownTableBodyLeft">Timer Interrupt Status   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates the interrupt status of Timer.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set by hardware when the up counting value of internal 24-bit counter matches the timer compared value (TMR_CMPR).   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Write 1 to clear this bit to 0.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If this bit is active and TMR_IE (TMRx_IER[0]) is enabled, Timer will trigger an interrupt to CPU.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]  </td><td class="markdownTableBodyCenter">TCAP_IS  </td><td class="markdownTableBodyLeft">Timer Capture Function Interrupt Status   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates the external pin function interrupt status of Timer.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set by hardware when TCAP_EN (TMRx_CTL[16]) is set high, and the transition of external pin matches the TCAP_EDGE (TMRx_CTL[19:18]) setting.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Write 1 to clear this bit to 0.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If this bit is active and TCAP_IE (TMRx_IER[1]) is enabled, Timer will trigger an interrupt to CPU.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]  </td><td class="markdownTableBodyCenter">TMR_WAKE_STS  </td><td class="markdownTableBodyLeft">Timer Wake-Up Status   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If timer causes CPU wakes up from power-down mode, this bit will be set to high.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It must be cleared by software with a write 1 to this bit.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Timer does not cause system wake-up.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Wakes system up from power-down mode by Timer timeout.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5]  </td><td class="markdownTableBodyCenter">NCAP_DET_STS  </td><td class="markdownTableBodyLeft">New Capture Detected Status   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This status is to indicate there is a new incoming capture event detected before CPU clearing the TCAP_IS (TMRx_ISR[1]) status.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the above condition occurred, the Timer will keep register TMRx_TCAP unchanged and drop the new capture value.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Write 1 to clear this bit to 0.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = New incoming capture event didn't detect before CPU clearing TCAP_IS (TMRx_ISR[1]) status.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = New incoming capture event detected before CPU clearing TCAP_IS (TMRx_ISR[1]) status.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[6]  </td><td class="markdownTableBodyCenter">TCAP_IS_FEDGE  </td><td class="markdownTableBodyLeft">TC Pin Edge Detect Is Falling   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This flag indicates the edge detected in TC pin is rising edge or falling edge.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Timer only updates this flag when it updates the Timer Capture Data (TMR_TCAP[23:0]) value.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When a new incoming capture event detected before CPU clearing the TCAP_IS (TMRx_ISR[1]) status, Timer will keep this bit unchanged.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = TC pin edge detected is rising edge.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = TC pin edge detected is falling edge.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano1_x2_series_8h_source.html#l09262">9262</a> of file <a class="el" href="_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="a6a66d55fb7d20c3e12402aa320661d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a66d55fb7d20c3e12402aa320661d8f">&#9670;&nbsp;</a></span>PRECNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t TIMER_T::PRECNT</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>PRECNT </h1>
<h2>Offset: 0x04 Timer x Pre-Scale Counter Register </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]  </td><td class="markdownTableBodyCenter">PRESCALE_CNT  </td><td class="markdownTableBodyLeft">Pre-Scale Counter   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Clock input is divided by PRESCALE_CNT + 1 before it is fed to the counter.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If PRESCALE_CNT =0, then there is no scaling.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano1_x2_series_8h_source.html#l09190">9190</a> of file <a class="el" href="_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="a9ecc606ca7cfd8c6693ec2d396b9e3d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ecc606ca7cfd8c6693ec2d396b9e3d8">&#9670;&nbsp;</a></span>RESERVE0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t TIMER_T::RESERVE0[1]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_nano1_x2_series_8h_source.html#l09302">9302</a> of file <a class="el" href="_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ac4508d4ae8dda154e5e796090fcafff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4508d4ae8dda154e5e796090fcafff3">&#9670;&nbsp;</a></span>TCAP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t TIMER_T::TCAP</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>TCAP </h1>
<h2>Offset: 0x18 Timer x Capture Data Register </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23:0]  </td><td class="markdownTableBodyCenter">CAP  </td><td class="markdownTableBodyLeft">Timer Capture Data Register   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When TCAP_EN (TMRx_CTL[16]) is set, TCAP_MODE (TMRx_CTL[17]) is 0, TCAP_CNT_MOD (TMRx_CTL[20]) is 0, and the transition of external pin matches the TCAP_EDGE (TMRx_CTL[19:18]) setting, the value of 24-bit up-counting timer will be saved into register TMRx_TCAP.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When TCAP_EN (TMRx_CTL[16]) is set, TCAP_MODE (TMRx_CTL[17]) is 0, TCAP_CNT_MOD (TMRx_CTL[20]) is 1, and the transition of external pin matches the 2nd transition of TCAP_EDGE (TMRx_CTL[19:18]) setting, the value of 24-bit up-counting timer will be saved into register TMRx_TCAP.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">User can read this register to get the counter value.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When a new incoming capture event detected before CPU clearing the TCAP_IS (TMRxISR[1]) status, Timer will keep this filed value unchanged and drop the new capture value.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano1_x2_series_8h_source.html#l09301">9301</a> of file <a class="el" href="_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>Device/Nuvoton/Nano1X2Series/Include/<a class="el" href="_nano1_x2_series_8h_source.html">Nano1X2Series.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Nov 7 2019 08:54:03 for Nano102_112 Series BSP by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
