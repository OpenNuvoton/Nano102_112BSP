<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NANO102/112 BSP: NANO102/112 Legacy Constants</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../M0Banner_v2.jpg"/></td>
  <td id="projectalign">
   <div id="projectname">NANO102/112 BSP<span id="projectnumber">&#160;V3.03.003</span>
   </div>
   <div id="projectbrief">The Board Support Package for Nano102/112 Series</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#enumval-members">Enumerator</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">NANO102/112 Legacy Constants<div class="ingroups"><a class="el" href="../../d5/db2/group___n_a_n_o1_x2___p_e_r_i_p_h_e_r_a_l___m_e_m___m_a_p.html">NANO102/112 Peripheral Memory Map</a> &raquo; <a class="el" href="../../da/d2d/group___n_a_n_o1_x2___p_e_r_i_p_h_e_r_a_l___d_e_c_l_a_r_a_t_i_o_n.html">NANO102/112 Peripheral Declaration</a> &raquo; <a class="el" href="../../d6/d70/group___n_a_n_o1_x2___i_o___r_o_u_t_i_n_e.html">NANO102/112 I/O Routines</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for NANO102/112 Legacy Constants:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.png" border="0" usemap="#ad4_2d75_2group______n__a__n__o1__x2____legacy______constants" alt=""/></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga070d2ce7b6bb7e5c05602aa8c308d0c4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:ga070d2ce7b6bb7e5c05602aa8c308d0c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">NULL pointer.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">More...</a><br /></td></tr>
<tr class="separator:ga070d2ce7b6bb7e5c05602aa8c308d0c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8cecfc5c5c054d2875c03e77b7be15d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:gaa8cecfc5c5c054d2875c03e77b7be15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean true, define to use in API parameters or return value.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaa8cecfc5c5c054d2875c03e77b7be15d">More...</a><br /></td></tr>
<tr class="separator:gaa8cecfc5c5c054d2875c03e77b7be15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa93f0eb578d23995850d61f7d61c55c1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaa93f0eb578d23995850d61f7d61c55c1">FALSE</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:gaa93f0eb578d23995850d61f7d61c55c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean false, define to use in API parameters or return value.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaa93f0eb578d23995850d61f7d61c55c1">More...</a><br /></td></tr>
<tr class="separator:gaa93f0eb578d23995850d61f7d61c55c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga514ad415fb6125ba296793df7d1a468a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga514ad415fb6125ba296793df7d1a468a">ENABLE</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:ga514ad415fb6125ba296793df7d1a468a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable, define to use in API parameters.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga514ad415fb6125ba296793df7d1a468a">More...</a><br /></td></tr>
<tr class="separator:ga514ad415fb6125ba296793df7d1a468a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99496f7308834e8b220f7894efa0b6ab"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga99496f7308834e8b220f7894efa0b6ab">DISABLE</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:ga99496f7308834e8b220f7894efa0b6ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable, define to use in API parameters.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga99496f7308834e8b220f7894efa0b6ab">More...</a><br /></td></tr>
<tr class="separator:ga99496f7308834e8b220f7894efa0b6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4d43f8748b542bce39e18790f845ecc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gad4d43f8748b542bce39e18790f845ecc">BIT0</a>&#160;&#160;&#160;(0x00000001)</td></tr>
<tr class="memdesc:gad4d43f8748b542bce39e18790f845ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 0 mask of an 32 bit integer.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gad4d43f8748b542bce39e18790f845ecc">More...</a><br /></td></tr>
<tr class="separator:gad4d43f8748b542bce39e18790f845ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga601923eba46784638244c1ebf2622a2a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga601923eba46784638244c1ebf2622a2a">BIT1</a>&#160;&#160;&#160;(0x00000002)</td></tr>
<tr class="memdesc:ga601923eba46784638244c1ebf2622a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 1 mask of an 32 bit integer.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga601923eba46784638244c1ebf2622a2a">More...</a><br /></td></tr>
<tr class="separator:ga601923eba46784638244c1ebf2622a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c9560bccccb00174801c728f1ed1399"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga9c9560bccccb00174801c728f1ed1399">BIT2</a>&#160;&#160;&#160;(0x00000004)</td></tr>
<tr class="memdesc:ga9c9560bccccb00174801c728f1ed1399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 2 mask of an 32 bit integer.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga9c9560bccccb00174801c728f1ed1399">More...</a><br /></td></tr>
<tr class="separator:ga9c9560bccccb00174801c728f1ed1399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e44574a8a8becc885b05f3bc367ef6a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga8e44574a8a8becc885b05f3bc367ef6a">BIT3</a>&#160;&#160;&#160;(0x00000008)</td></tr>
<tr class="memdesc:ga8e44574a8a8becc885b05f3bc367ef6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 3 mask of an 32 bit integer.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga8e44574a8a8becc885b05f3bc367ef6a">More...</a><br /></td></tr>
<tr class="separator:ga8e44574a8a8becc885b05f3bc367ef6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa731e0b6cf75f4e637ee88959315f5e4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaa731e0b6cf75f4e637ee88959315f5e4">BIT4</a>&#160;&#160;&#160;(0x00000010)</td></tr>
<tr class="memdesc:gaa731e0b6cf75f4e637ee88959315f5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 4 mask of an 32 bit integer.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaa731e0b6cf75f4e637ee88959315f5e4">More...</a><br /></td></tr>
<tr class="separator:gaa731e0b6cf75f4e637ee88959315f5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae692bc3df48028ceb1ddc2534a993bb8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gae692bc3df48028ceb1ddc2534a993bb8">BIT5</a>&#160;&#160;&#160;(0x00000020)</td></tr>
<tr class="memdesc:gae692bc3df48028ceb1ddc2534a993bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 5 mask of an 32 bit integer.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gae692bc3df48028ceb1ddc2534a993bb8">More...</a><br /></td></tr>
<tr class="separator:gae692bc3df48028ceb1ddc2534a993bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc2d074401e2b6322ee8f03476c24677"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gacc2d074401e2b6322ee8f03476c24677">BIT6</a>&#160;&#160;&#160;(0x00000040)</td></tr>
<tr class="memdesc:gacc2d074401e2b6322ee8f03476c24677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 6 mask of an 32 bit integer.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gacc2d074401e2b6322ee8f03476c24677">More...</a><br /></td></tr>
<tr class="separator:gacc2d074401e2b6322ee8f03476c24677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6b8f3261ae9e2e1043380c192f7b5f0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaa6b8f3261ae9e2e1043380c192f7b5f0">BIT7</a>&#160;&#160;&#160;(0x00000080)</td></tr>
<tr class="memdesc:gaa6b8f3261ae9e2e1043380c192f7b5f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 7 mask of an 32 bit integer.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaa6b8f3261ae9e2e1043380c192f7b5f0">More...</a><br /></td></tr>
<tr class="separator:gaa6b8f3261ae9e2e1043380c192f7b5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e80e65237843fa1ff15c68cd78066f8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga0e80e65237843fa1ff15c68cd78066f8">BIT8</a>&#160;&#160;&#160;(0x00000100)</td></tr>
<tr class="memdesc:ga0e80e65237843fa1ff15c68cd78066f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 8 mask of an 32 bit integer.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga0e80e65237843fa1ff15c68cd78066f8">More...</a><br /></td></tr>
<tr class="separator:ga0e80e65237843fa1ff15c68cd78066f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3aa20ab5eb33383fa31b0e94f4401cdf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga3aa20ab5eb33383fa31b0e94f4401cdf">BIT9</a>&#160;&#160;&#160;(0x00000200)</td></tr>
<tr class="memdesc:ga3aa20ab5eb33383fa31b0e94f4401cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 9 mask of an 32 bit integer.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga3aa20ab5eb33383fa31b0e94f4401cdf">More...</a><br /></td></tr>
<tr class="separator:ga3aa20ab5eb33383fa31b0e94f4401cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c0f01fdf020d0f7467449b181fe95cb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga8c0f01fdf020d0f7467449b181fe95cb">BIT10</a>&#160;&#160;&#160;(0x00000400)</td></tr>
<tr class="memdesc:ga8c0f01fdf020d0f7467449b181fe95cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 10 mask of an 32 bit integer.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga8c0f01fdf020d0f7467449b181fe95cb">More...</a><br /></td></tr>
<tr class="separator:ga8c0f01fdf020d0f7467449b181fe95cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cda1debde057b596766eba6a76daca0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga2cda1debde057b596766eba6a76daca0">BIT11</a>&#160;&#160;&#160;(0x00000800)</td></tr>
<tr class="memdesc:ga2cda1debde057b596766eba6a76daca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 11 mask of an 32 bit integer.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga2cda1debde057b596766eba6a76daca0">More...</a><br /></td></tr>
<tr class="separator:ga2cda1debde057b596766eba6a76daca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa0a6acba8436baabcaa1e91fad6c0bd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaaa0a6acba8436baabcaa1e91fad6c0bd">BIT12</a>&#160;&#160;&#160;(0x00001000)</td></tr>
<tr class="memdesc:gaaa0a6acba8436baabcaa1e91fad6c0bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 12 mask of an 32 bit integer.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaaa0a6acba8436baabcaa1e91fad6c0bd">More...</a><br /></td></tr>
<tr class="separator:gaaa0a6acba8436baabcaa1e91fad6c0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga965dc1748ab1cf91426bd04a2fe16ecf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga965dc1748ab1cf91426bd04a2fe16ecf">BIT13</a>&#160;&#160;&#160;(0x00002000)</td></tr>
<tr class="memdesc:ga965dc1748ab1cf91426bd04a2fe16ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 13 mask of an 32 bit integer.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga965dc1748ab1cf91426bd04a2fe16ecf">More...</a><br /></td></tr>
<tr class="separator:ga965dc1748ab1cf91426bd04a2fe16ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41e750b67eb36c8da10328c565b90dd5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga41e750b67eb36c8da10328c565b90dd5">BIT14</a>&#160;&#160;&#160;(0x00004000)</td></tr>
<tr class="memdesc:ga41e750b67eb36c8da10328c565b90dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 14 mask of an 32 bit integer.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga41e750b67eb36c8da10328c565b90dd5">More...</a><br /></td></tr>
<tr class="separator:ga41e750b67eb36c8da10328c565b90dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae40f5db1c57c98c6db42f15e0a56f03a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gae40f5db1c57c98c6db42f15e0a56f03a">BIT15</a>&#160;&#160;&#160;(0x00008000)</td></tr>
<tr class="memdesc:gae40f5db1c57c98c6db42f15e0a56f03a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 15 mask of an 32 bit integer.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gae40f5db1c57c98c6db42f15e0a56f03a">More...</a><br /></td></tr>
<tr class="separator:gae40f5db1c57c98c6db42f15e0a56f03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c55b9d74a6a1b129397792053cf08d5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga7c55b9d74a6a1b129397792053cf08d5">BIT16</a>&#160;&#160;&#160;(0x00010000)</td></tr>
<tr class="memdesc:ga7c55b9d74a6a1b129397792053cf08d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 16 mask of an 32 bit integer.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga7c55b9d74a6a1b129397792053cf08d5">More...</a><br /></td></tr>
<tr class="separator:ga7c55b9d74a6a1b129397792053cf08d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27fe52b845a36280f50414ab4a00f74f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga27fe52b845a36280f50414ab4a00f74f">BIT17</a>&#160;&#160;&#160;(0x00020000)</td></tr>
<tr class="memdesc:ga27fe52b845a36280f50414ab4a00f74f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 17 mask of an 32 bit integer.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga27fe52b845a36280f50414ab4a00f74f">More...</a><br /></td></tr>
<tr class="separator:ga27fe52b845a36280f50414ab4a00f74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56a026d146963b7d977255d9b1f682ae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga56a026d146963b7d977255d9b1f682ae">BIT18</a>&#160;&#160;&#160;(0x00040000)</td></tr>
<tr class="memdesc:ga56a026d146963b7d977255d9b1f682ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 18 mask of an 32 bit integer.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga56a026d146963b7d977255d9b1f682ae">More...</a><br /></td></tr>
<tr class="separator:ga56a026d146963b7d977255d9b1f682ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ce58ae33c478370e59c915b04b05381"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga9ce58ae33c478370e59c915b04b05381">BIT19</a>&#160;&#160;&#160;(0x00080000)</td></tr>
<tr class="memdesc:ga9ce58ae33c478370e59c915b04b05381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 19 mask of an 32 bit integer.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga9ce58ae33c478370e59c915b04b05381">More...</a><br /></td></tr>
<tr class="separator:ga9ce58ae33c478370e59c915b04b05381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83aaba3456aa46dfefe199fe6264d8dc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga83aaba3456aa46dfefe199fe6264d8dc">BIT20</a>&#160;&#160;&#160;(0x00100000)</td></tr>
<tr class="memdesc:ga83aaba3456aa46dfefe199fe6264d8dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 20 mask of an 32 bit integer.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga83aaba3456aa46dfefe199fe6264d8dc">More...</a><br /></td></tr>
<tr class="separator:ga83aaba3456aa46dfefe199fe6264d8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a5b4d4ca137f11bcb2e9c381f2ea6c5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga1a5b4d4ca137f11bcb2e9c381f2ea6c5">BIT21</a>&#160;&#160;&#160;(0x00200000)</td></tr>
<tr class="memdesc:ga1a5b4d4ca137f11bcb2e9c381f2ea6c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 21 mask of an 32 bit integer.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga1a5b4d4ca137f11bcb2e9c381f2ea6c5">More...</a><br /></td></tr>
<tr class="separator:ga1a5b4d4ca137f11bcb2e9c381f2ea6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdaa01ee37bdcd01ea44dbab6a30fd0d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gafdaa01ee37bdcd01ea44dbab6a30fd0d">BIT22</a>&#160;&#160;&#160;(0x00400000)</td></tr>
<tr class="memdesc:gafdaa01ee37bdcd01ea44dbab6a30fd0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 22 mask of an 32 bit integer.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gafdaa01ee37bdcd01ea44dbab6a30fd0d">More...</a><br /></td></tr>
<tr class="separator:gafdaa01ee37bdcd01ea44dbab6a30fd0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada7be80971d1875e5c4774edd3ecd97d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gada7be80971d1875e5c4774edd3ecd97d">BIT23</a>&#160;&#160;&#160;(0x00800000)</td></tr>
<tr class="memdesc:gada7be80971d1875e5c4774edd3ecd97d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 23 mask of an 32 bit integer.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gada7be80971d1875e5c4774edd3ecd97d">More...</a><br /></td></tr>
<tr class="separator:gada7be80971d1875e5c4774edd3ecd97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96cfb019bda32752ff4c8b8244aa6ea0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga96cfb019bda32752ff4c8b8244aa6ea0">BIT24</a>&#160;&#160;&#160;(0x01000000)</td></tr>
<tr class="memdesc:ga96cfb019bda32752ff4c8b8244aa6ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 24 mask of an 32 bit integer.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga96cfb019bda32752ff4c8b8244aa6ea0">More...</a><br /></td></tr>
<tr class="separator:ga96cfb019bda32752ff4c8b8244aa6ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3017291241a7269c1582154a3d3b1f09"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga3017291241a7269c1582154a3d3b1f09">BIT25</a>&#160;&#160;&#160;(0x02000000)</td></tr>
<tr class="memdesc:ga3017291241a7269c1582154a3d3b1f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 25 mask of an 32 bit integer.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga3017291241a7269c1582154a3d3b1f09">More...</a><br /></td></tr>
<tr class="separator:ga3017291241a7269c1582154a3d3b1f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f97a8963cc15a1a50521d855b8a1331"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga4f97a8963cc15a1a50521d855b8a1331">BIT26</a>&#160;&#160;&#160;(0x04000000)</td></tr>
<tr class="memdesc:ga4f97a8963cc15a1a50521d855b8a1331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 26 mask of an 32 bit integer.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga4f97a8963cc15a1a50521d855b8a1331">More...</a><br /></td></tr>
<tr class="separator:ga4f97a8963cc15a1a50521d855b8a1331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdd1584eaddf508717554b35a600b0fd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gafdd1584eaddf508717554b35a600b0fd">BIT27</a>&#160;&#160;&#160;(0x08000000)</td></tr>
<tr class="memdesc:gafdd1584eaddf508717554b35a600b0fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 27 mask of an 32 bit integer.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gafdd1584eaddf508717554b35a600b0fd">More...</a><br /></td></tr>
<tr class="separator:gafdd1584eaddf508717554b35a600b0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4361544977e96fb8eb8387ff0feaf6b6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga4361544977e96fb8eb8387ff0feaf6b6">BIT28</a>&#160;&#160;&#160;(0x10000000)</td></tr>
<tr class="memdesc:ga4361544977e96fb8eb8387ff0feaf6b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 28 mask of an 32 bit integer.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga4361544977e96fb8eb8387ff0feaf6b6">More...</a><br /></td></tr>
<tr class="separator:ga4361544977e96fb8eb8387ff0feaf6b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb368e517e545da53d8aace5923649e1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gadb368e517e545da53d8aace5923649e1">BIT29</a>&#160;&#160;&#160;(0x20000000)</td></tr>
<tr class="memdesc:gadb368e517e545da53d8aace5923649e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 29 mask of an 32 bit integer.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gadb368e517e545da53d8aace5923649e1">More...</a><br /></td></tr>
<tr class="separator:gadb368e517e545da53d8aace5923649e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70105c4a8c864754c8ba9e9b0e5da52a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga70105c4a8c864754c8ba9e9b0e5da52a">BIT30</a>&#160;&#160;&#160;(0x40000000)</td></tr>
<tr class="memdesc:ga70105c4a8c864754c8ba9e9b0e5da52a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 30 mask of an 32 bit integer.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga70105c4a8c864754c8ba9e9b0e5da52a">More...</a><br /></td></tr>
<tr class="separator:ga70105c4a8c864754c8ba9e9b0e5da52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfb09898dca36071e32cb1fbeec479e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gadfb09898dca36071e32cb1fbeec479e5">BIT31</a>&#160;&#160;&#160;(0x80000000)</td></tr>
<tr class="memdesc:gadfb09898dca36071e32cb1fbeec479e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 31 mask of an 32 bit integer.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gadfb09898dca36071e32cb1fbeec479e5">More...</a><br /></td></tr>
<tr class="separator:gadfb09898dca36071e32cb1fbeec479e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2da6b6038c3e29eb02a23385f7dfe18e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga2da6b6038c3e29eb02a23385f7dfe18e">BYTE0_Msk</a>&#160;&#160;&#160;(0x000000FF)</td></tr>
<tr class="memdesc:ga2da6b6038c3e29eb02a23385f7dfe18e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask to get bit0~bit7 from a 32 bit integer.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga2da6b6038c3e29eb02a23385f7dfe18e">More...</a><br /></td></tr>
<tr class="separator:ga2da6b6038c3e29eb02a23385f7dfe18e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bdb45c3d1adab74d72eab6116f9581c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga6bdb45c3d1adab74d72eab6116f9581c">BYTE1_Msk</a>&#160;&#160;&#160;(0x0000FF00)</td></tr>
<tr class="memdesc:ga6bdb45c3d1adab74d72eab6116f9581c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask to get bit8~bit15 from a 32 bit integer.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga6bdb45c3d1adab74d72eab6116f9581c">More...</a><br /></td></tr>
<tr class="separator:ga6bdb45c3d1adab74d72eab6116f9581c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a926438abfcff696496c60ee5ebd4da"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga6a926438abfcff696496c60ee5ebd4da">BYTE2_Msk</a>&#160;&#160;&#160;(0x00FF0000)</td></tr>
<tr class="memdesc:ga6a926438abfcff696496c60ee5ebd4da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask to get bit16~bit23 from a 32 bit integer.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga6a926438abfcff696496c60ee5ebd4da">More...</a><br /></td></tr>
<tr class="separator:ga6a926438abfcff696496c60ee5ebd4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26cd8778bf420a922c9cd2bf7c916875"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga26cd8778bf420a922c9cd2bf7c916875">BYTE3_Msk</a>&#160;&#160;&#160;(0xFF000000)</td></tr>
<tr class="memdesc:ga26cd8778bf420a922c9cd2bf7c916875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask to get bit24~bit31 from a 32 bit integer.  <a href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga26cd8778bf420a922c9cd2bf7c916875">More...</a><br /></td></tr>
<tr class="separator:ga26cd8778bf420a922c9cd2bf7c916875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4adc89d1a476c51ae52eb700a06fb96"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaf4adc89d1a476c51ae52eb700a06fb96">GET_BYTE0</a>(u32Param)&#160;&#160;&#160;((u32Param &amp; <a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga2da6b6038c3e29eb02a23385f7dfe18e">BYTE0_Msk</a>)      )</td></tr>
<tr class="separator:gaf4adc89d1a476c51ae52eb700a06fb96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61fd653ee8852ef7bb04fff1509febc8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga61fd653ee8852ef7bb04fff1509febc8">GET_BYTE1</a>(u32Param)&#160;&#160;&#160;((u32Param &amp; <a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga6bdb45c3d1adab74d72eab6116f9581c">BYTE1_Msk</a>) &gt;&gt;  8)</td></tr>
<tr class="separator:ga61fd653ee8852ef7bb04fff1509febc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35d066854cc83e3823a21f9972fc308f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga35d066854cc83e3823a21f9972fc308f">GET_BYTE2</a>(u32Param)&#160;&#160;&#160;((u32Param &amp; <a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga6a926438abfcff696496c60ee5ebd4da">BYTE2_Msk</a>) &gt;&gt; 16)</td></tr>
<tr class="separator:ga35d066854cc83e3823a21f9972fc308f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b580f1b27a79bb2b5924a40c9867ab4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga2b580f1b27a79bb2b5924a40c9867ab4">GET_BYTE3</a>(u32Param)&#160;&#160;&#160;((u32Param &amp; <a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga26cd8778bf420a922c9cd2bf7c916875">BYTE3_Msk</a>) &gt;&gt; 24)</td></tr>
<tr class="separator:ga2b580f1b27a79bb2b5924a40c9867ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gaa8d835ee4132082a088bc7481e600ab7"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaa8d835ee4132082a088bc7481e600ab7">ACMP_T::CR</a> [2]</td></tr>
<tr class="separator:gaa8d835ee4132082a088bc7481e600ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga852606aa3333cffd3dc4c9ed4ff32a61"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga852606aa3333cffd3dc4c9ed4ff32a61">ACMP_T::SR</a></td></tr>
<tr class="separator:ga852606aa3333cffd3dc4c9ed4ff32a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac76855ed7d26898428b9eb077c0c92d9"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gac76855ed7d26898428b9eb077c0c92d9">ACMP_T::RVCR</a></td></tr>
<tr class="separator:gac76855ed7d26898428b9eb077c0c92d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b446461dd6a5701eda33387d5cdb016"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga9b446461dd6a5701eda33387d5cdb016">ACMP_T::MODCR0</a></td></tr>
<tr class="separator:ga9b446461dd6a5701eda33387d5cdb016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e69d68623f50b230184c4466a44b700"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga9e69d68623f50b230184c4466a44b700">ADC_T::RESULT</a> [18]</td></tr>
<tr class="separator:ga9e69d68623f50b230184c4466a44b700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c3ab78a735c6154aafb45290d791a94"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga7c3ab78a735c6154aafb45290d791a94">ADC_T::CR</a></td></tr>
<tr class="separator:ga7c3ab78a735c6154aafb45290d791a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a552a9d8396e7a1a9c405359018a349"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga8a552a9d8396e7a1a9c405359018a349">ADC_T::CHEN</a></td></tr>
<tr class="separator:ga8a552a9d8396e7a1a9c405359018a349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21ba1290b1f30db4da4280030ccdbcf5"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga21ba1290b1f30db4da4280030ccdbcf5">ADC_T::CMPR0</a></td></tr>
<tr class="separator:ga21ba1290b1f30db4da4280030ccdbcf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecaf7bd402b9e48d435b3d55bcd1992f"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaecaf7bd402b9e48d435b3d55bcd1992f">ADC_T::CMPR1</a></td></tr>
<tr class="separator:gaecaf7bd402b9e48d435b3d55bcd1992f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabf9e91cd1c93268d5030303b872eecf"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaabf9e91cd1c93268d5030303b872eecf">ADC_T::SR</a></td></tr>
<tr class="separator:gaabf9e91cd1c93268d5030303b872eecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab35b677a2dc28f2733fb7769c99786a7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gab35b677a2dc28f2733fb7769c99786a7">ADC_T::RESERVE1</a> [1]</td></tr>
<tr class="separator:gab35b677a2dc28f2733fb7769c99786a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf77721058d20e5b5a0a4e5db7f1e7193"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaf77721058d20e5b5a0a4e5db7f1e7193">ADC_T::PDMA</a></td></tr>
<tr class="separator:gaf77721058d20e5b5a0a4e5db7f1e7193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b33e02385e50126dbe173470193bdf8"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga7b33e02385e50126dbe173470193bdf8">ADC_T::PWRCTL</a></td></tr>
<tr class="separator:ga7b33e02385e50126dbe173470193bdf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga060402df18d1f63be3a0c429402c7764"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga060402df18d1f63be3a0c429402c7764">ADC_T::CALCTL</a></td></tr>
<tr class="separator:ga060402df18d1f63be3a0c429402c7764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf08c7acec8b147ea37c5bc0dd64ae6c"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaaf08c7acec8b147ea37c5bc0dd64ae6c">ADC_T::CALWORD</a></td></tr>
<tr class="separator:gaaf08c7acec8b147ea37c5bc0dd64ae6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacf17b4088c0c6fa8bb82f567bfebf32"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaacf17b4088c0c6fa8bb82f567bfebf32">ADC_T::SMPLCNT0</a></td></tr>
<tr class="separator:gaacf17b4088c0c6fa8bb82f567bfebf32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad48be5bda281d3f56570e57f2583de37"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gad48be5bda281d3f56570e57f2583de37">ADC_T::SMPLCNT1</a></td></tr>
<tr class="separator:gad48be5bda281d3f56570e57f2583de37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dc40f2a57b0b379fd97dd6eecdba230"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga8dc40f2a57b0b379fd97dd6eecdba230">CLK_T::PWRCTL</a></td></tr>
<tr class="separator:ga8dc40f2a57b0b379fd97dd6eecdba230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga808b691f73f5988acf98189dc52c2258"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga808b691f73f5988acf98189dc52c2258">CLK_T::AHBCLK</a></td></tr>
<tr class="separator:ga808b691f73f5988acf98189dc52c2258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab95b1d5348167498809cbe3d4afa7960"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gab95b1d5348167498809cbe3d4afa7960">CLK_T::APBCLK</a></td></tr>
<tr class="separator:gab95b1d5348167498809cbe3d4afa7960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga939046f1ff107551dfeedab4aca2c20d"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga939046f1ff107551dfeedab4aca2c20d">CLK_T::CLKSTATUS</a></td></tr>
<tr class="separator:ga939046f1ff107551dfeedab4aca2c20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5d0e2a48518b0d44641f594a763b619"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gae5d0e2a48518b0d44641f594a763b619">CLK_T::CLKSEL0</a></td></tr>
<tr class="separator:gae5d0e2a48518b0d44641f594a763b619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cad9e775d46b22aad65c5caa3ba9cbf"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga9cad9e775d46b22aad65c5caa3ba9cbf">CLK_T::CLKSEL1</a></td></tr>
<tr class="separator:ga9cad9e775d46b22aad65c5caa3ba9cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga505ef1b8c8d11745b09418636c576b6f"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga505ef1b8c8d11745b09418636c576b6f">CLK_T::CLKSEL2</a></td></tr>
<tr class="separator:ga505ef1b8c8d11745b09418636c576b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecdde8616f159af8c864c8c111e52414"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaecdde8616f159af8c864c8c111e52414">CLK_T::CLKDIV0</a></td></tr>
<tr class="separator:gaecdde8616f159af8c864c8c111e52414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16bc8804dd7c329491e87a4c24dfd86c"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga16bc8804dd7c329491e87a4c24dfd86c">CLK_T::CLKDIV1</a></td></tr>
<tr class="separator:ga16bc8804dd7c329491e87a4c24dfd86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0059b5b729980b9dfe3a9cb3e75ea99a"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga0059b5b729980b9dfe3a9cb3e75ea99a">CLK_T::PLLCTL</a></td></tr>
<tr class="separator:ga0059b5b729980b9dfe3a9cb3e75ea99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05aca80545648c67739ed834eaa01f79"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga05aca80545648c67739ed834eaa01f79">CLK_T::FRQDIV0</a></td></tr>
<tr class="separator:ga05aca80545648c67739ed834eaa01f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5c543e82031d3cb0ba48c5f9a916031"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gac5c543e82031d3cb0ba48c5f9a916031">CLK_T::RESERVE0</a> [1]</td></tr>
<tr class="separator:gac5c543e82031d3cb0ba48c5f9a916031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3aace40aeea86c8dece6918b4e1170d0"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga3aace40aeea86c8dece6918b4e1170d0">CLK_T::WK_INTSTS</a></td></tr>
<tr class="separator:ga3aace40aeea86c8dece6918b4e1170d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e3a18ffbc3f4aee6c6fc5e8a1ae553e"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga1e3a18ffbc3f4aee6c6fc5e8a1ae553e">CLK_T::APB_DIV</a></td></tr>
<tr class="separator:ga1e3a18ffbc3f4aee6c6fc5e8a1ae553e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga331ce92b94015f5c199d9bf36ab5874a"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga331ce92b94015f5c199d9bf36ab5874a">CLK_T::FRQDIV1</a></td></tr>
<tr class="separator:ga331ce92b94015f5c199d9bf36ab5874a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9b4363cbc9fa5e227122d0d9852830b"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gac9b4363cbc9fa5e227122d0d9852830b">CLK_T::SP_DET</a></td></tr>
<tr class="separator:gac9b4363cbc9fa5e227122d0d9852830b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f3cf7cd93cbac6e644e7ba6192f0c6c"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga9f3cf7cd93cbac6e644e7ba6192f0c6c">CLK_T::SP_STS</a></td></tr>
<tr class="separator:ga9f3cf7cd93cbac6e644e7ba6192f0c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11450e004bab24c0dbe2b152d95e93fc"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga11450e004bab24c0dbe2b152d95e93fc">DMA_CRC_T::CTL</a></td></tr>
<tr class="separator:ga11450e004bab24c0dbe2b152d95e93fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8c41cb44a1921f97ba4b8ab5230e0ad"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaa8c41cb44a1921f97ba4b8ab5230e0ad">DMA_CRC_T::DMASAR</a></td></tr>
<tr class="separator:gaa8c41cb44a1921f97ba4b8ab5230e0ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga411f3d9964120e7bf442d4fe46644353"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga411f3d9964120e7bf442d4fe46644353">DMA_CRC_T::RESERVE0</a> [1]</td></tr>
<tr class="separator:ga411f3d9964120e7bf442d4fe46644353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee2cc59012292dead10fff18f43ef71e"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaee2cc59012292dead10fff18f43ef71e">DMA_CRC_T::DMABCR</a></td></tr>
<tr class="separator:gaee2cc59012292dead10fff18f43ef71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb37485b9fd770784d56d6e9ebd57b2e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaeb37485b9fd770784d56d6e9ebd57b2e">DMA_CRC_T::RESERVE1</a> [1]</td></tr>
<tr class="separator:gaeb37485b9fd770784d56d6e9ebd57b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cf62f0df806c2ea48766d2643954acb"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga7cf62f0df806c2ea48766d2643954acb">DMA_CRC_T::DMACSAR</a></td></tr>
<tr class="separator:ga7cf62f0df806c2ea48766d2643954acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a6f3fb798fb0a132a2ccf7f6b424233"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga0a6f3fb798fb0a132a2ccf7f6b424233">DMA_CRC_T::RESERVE2</a> [1]</td></tr>
<tr class="separator:ga0a6f3fb798fb0a132a2ccf7f6b424233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95f060935bd6cca5c51615de894f40f6"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga95f060935bd6cca5c51615de894f40f6">DMA_CRC_T::DMACBCR</a></td></tr>
<tr class="separator:ga95f060935bd6cca5c51615de894f40f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8d725245a81746f9d034d1c4242cd82"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gad8d725245a81746f9d034d1c4242cd82">DMA_CRC_T::DMAIER</a></td></tr>
<tr class="separator:gad8d725245a81746f9d034d1c4242cd82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb314f9a25f38e16be8be0a3178a44a8"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaeb314f9a25f38e16be8be0a3178a44a8">DMA_CRC_T::DMAISR</a></td></tr>
<tr class="separator:gaeb314f9a25f38e16be8be0a3178a44a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga318f84a6afb4e661302a1d21d361ba29"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga318f84a6afb4e661302a1d21d361ba29">DMA_CRC_T::RESERVE3</a> [22]</td></tr>
<tr class="separator:ga318f84a6afb4e661302a1d21d361ba29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga119abaa69d99974d66efbb946518e931"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga119abaa69d99974d66efbb946518e931">DMA_CRC_T::WDATA</a></td></tr>
<tr class="separator:ga119abaa69d99974d66efbb946518e931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bb69708797f658b773cd864e48e4c0b"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga3bb69708797f658b773cd864e48e4c0b">DMA_CRC_T::SEED</a></td></tr>
<tr class="separator:ga3bb69708797f658b773cd864e48e4c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab507dbddc46ba55a5cc05b3de901e132"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gab507dbddc46ba55a5cc05b3de901e132">DMA_CRC_T::CHECKSUM</a></td></tr>
<tr class="separator:gab507dbddc46ba55a5cc05b3de901e132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1afa8bc188cd8faa4c924f86426c8559"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga1afa8bc188cd8faa4c924f86426c8559">DMA_GCR_T::GCRCSR</a></td></tr>
<tr class="separator:ga1afa8bc188cd8faa4c924f86426c8559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga314f75fa91026439282e77423ac2f830"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga314f75fa91026439282e77423ac2f830">DMA_GCR_T::DSSR0</a></td></tr>
<tr class="separator:ga314f75fa91026439282e77423ac2f830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e2b0f6d1c0549073bf2f1c4261b851b"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga2e2b0f6d1c0549073bf2f1c4261b851b">DMA_GCR_T::DSSR1</a></td></tr>
<tr class="separator:ga2e2b0f6d1c0549073bf2f1c4261b851b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b047759aa8f5953e4fc72fe3ad26b75"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga5b047759aa8f5953e4fc72fe3ad26b75">DMA_GCR_T::GCRISR</a></td></tr>
<tr class="separator:ga5b047759aa8f5953e4fc72fe3ad26b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d21db3829051558647d9e50ec276543"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga9d21db3829051558647d9e50ec276543">PDMA_T::CSR</a></td></tr>
<tr class="separator:ga9d21db3829051558647d9e50ec276543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac03cbcb60bd8f61f401bc492a5082aa5"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gac03cbcb60bd8f61f401bc492a5082aa5">PDMA_T::SAR</a></td></tr>
<tr class="separator:gac03cbcb60bd8f61f401bc492a5082aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9328015fb4cd6a934f99b2463a7149f"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gae9328015fb4cd6a934f99b2463a7149f">PDMA_T::DAR</a></td></tr>
<tr class="separator:gae9328015fb4cd6a934f99b2463a7149f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb440a7a3753ec21c130497aef7de4b8"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gafb440a7a3753ec21c130497aef7de4b8">PDMA_T::BCR</a></td></tr>
<tr class="separator:gafb440a7a3753ec21c130497aef7de4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaee053849c4f8a1b259a095cc09ee22e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaaee053849c4f8a1b259a095cc09ee22e">PDMA_T::RESERVE0</a> [1]</td></tr>
<tr class="separator:gaaee053849c4f8a1b259a095cc09ee22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga769c202442b98c7705ed366570418d4a"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga769c202442b98c7705ed366570418d4a">PDMA_T::CSAR</a></td></tr>
<tr class="separator:ga769c202442b98c7705ed366570418d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71808ef5d48dfb05afba27eaacbc65c8"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga71808ef5d48dfb05afba27eaacbc65c8">PDMA_T::CDAR</a></td></tr>
<tr class="separator:ga71808ef5d48dfb05afba27eaacbc65c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36ea5c8cb37f89bb4ba6dfd1ea44dca1"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga36ea5c8cb37f89bb4ba6dfd1ea44dca1">PDMA_T::CBCR</a></td></tr>
<tr class="separator:ga36ea5c8cb37f89bb4ba6dfd1ea44dca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c28784c32bb49716e0486c490be2e7e"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga5c28784c32bb49716e0486c490be2e7e">PDMA_T::IER</a></td></tr>
<tr class="separator:ga5c28784c32bb49716e0486c490be2e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9722e42994cbccb70a65ae76675a8ee6"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga9722e42994cbccb70a65ae76675a8ee6">PDMA_T::ISR</a></td></tr>
<tr class="separator:ga9722e42994cbccb70a65ae76675a8ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d32cd7347384fb469ccb130cebeec32"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga2d32cd7347384fb469ccb130cebeec32">PDMA_T::TCR</a></td></tr>
<tr class="separator:ga2d32cd7347384fb469ccb130cebeec32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad658f15872614d8af77a748cf2f18d67"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gad658f15872614d8af77a748cf2f18d67">FMC_T::ISPCON</a></td></tr>
<tr class="separator:gad658f15872614d8af77a748cf2f18d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02da88864194e77c672763a1389d5839"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga02da88864194e77c672763a1389d5839">FMC_T::ISPADR</a></td></tr>
<tr class="separator:ga02da88864194e77c672763a1389d5839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93a594f096446ee933113f6c57c200c3"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga93a594f096446ee933113f6c57c200c3">FMC_T::ISPDAT</a></td></tr>
<tr class="separator:ga93a594f096446ee933113f6c57c200c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga535eb6e9457c338ac7515a5d2ff06802"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga535eb6e9457c338ac7515a5d2ff06802">FMC_T::ISPCMD</a></td></tr>
<tr class="separator:ga535eb6e9457c338ac7515a5d2ff06802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef7c67979c87346e1de844a30b649269"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaef7c67979c87346e1de844a30b649269">FMC_T::ISPTRG</a></td></tr>
<tr class="separator:gaef7c67979c87346e1de844a30b649269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f8433cf17517dba01cee3cbd65f4e63"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga6f8433cf17517dba01cee3cbd65f4e63">FMC_T::DFBADR</a></td></tr>
<tr class="separator:ga6f8433cf17517dba01cee3cbd65f4e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84b8652eeb9b92b1eaf40b204d7d405b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga84b8652eeb9b92b1eaf40b204d7d405b">FMC_T::RESERVE0</a> [10]</td></tr>
<tr class="separator:ga84b8652eeb9b92b1eaf40b204d7d405b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dc78a1205af2308d25719d882f78764"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga2dc78a1205af2308d25719d882f78764">FMC_T::ISPSTA</a></td></tr>
<tr class="separator:ga2dc78a1205af2308d25719d882f78764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6246fa552c418eb242d8bb15ebb045ba"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga6246fa552c418eb242d8bb15ebb045ba">SYS_T::PDID</a></td></tr>
<tr class="separator:ga6246fa552c418eb242d8bb15ebb045ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c3fa8471628dc184c272b5fcd913c0a"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga4c3fa8471628dc184c272b5fcd913c0a">SYS_T::RST_SRC</a></td></tr>
<tr class="separator:ga4c3fa8471628dc184c272b5fcd913c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d8aba8c61ac18aec3989ca8c6429fcf"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga2d8aba8c61ac18aec3989ca8c6429fcf">SYS_T::IPRST_CTL1</a></td></tr>
<tr class="separator:ga2d8aba8c61ac18aec3989ca8c6429fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga505c932d819154975b9b438b7556bbe9"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga505c932d819154975b9b438b7556bbe9">SYS_T::IPRST_CTL2</a></td></tr>
<tr class="separator:ga505c932d819154975b9b438b7556bbe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe13d0bb8565a6db2f4608278d1fb5f9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gafe13d0bb8565a6db2f4608278d1fb5f9">SYS_T::RESERVE0</a> [4]</td></tr>
<tr class="separator:gafe13d0bb8565a6db2f4608278d1fb5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf39e47b38db7eb4fb8ac81670cdc9496"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaf39e47b38db7eb4fb8ac81670cdc9496">SYS_T::TEMPCTL</a></td></tr>
<tr class="separator:gaf39e47b38db7eb4fb8ac81670cdc9496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf73711431d617ffdca77288c88244328"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaf73711431d617ffdca77288c88244328">SYS_T::RESERVE1</a> [3]</td></tr>
<tr class="separator:gaf73711431d617ffdca77288c88244328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea4dc4bb849dc1fb9f683dd91695221c"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaea4dc4bb849dc1fb9f683dd91695221c">SYS_T::PA_L_MFP</a></td></tr>
<tr class="separator:gaea4dc4bb849dc1fb9f683dd91695221c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92edc95845e792155315a0147ae3d408"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga92edc95845e792155315a0147ae3d408">SYS_T::PA_H_MFP</a></td></tr>
<tr class="separator:ga92edc95845e792155315a0147ae3d408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa34e4f826e465a1b5316d5d8286d77d3"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaa34e4f826e465a1b5316d5d8286d77d3">SYS_T::PB_L_MFP</a></td></tr>
<tr class="separator:gaa34e4f826e465a1b5316d5d8286d77d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a0729014977cbc03210e17bc3eb0f67"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga6a0729014977cbc03210e17bc3eb0f67">SYS_T::PB_H_MFP</a></td></tr>
<tr class="separator:ga6a0729014977cbc03210e17bc3eb0f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dff3844e17550fa00b70ce8c4269acf"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga4dff3844e17550fa00b70ce8c4269acf">SYS_T::PC_L_MFP</a></td></tr>
<tr class="separator:ga4dff3844e17550fa00b70ce8c4269acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ee16e76c17384504294d4fec1d85264"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga6ee16e76c17384504294d4fec1d85264">SYS_T::PC_H_MFP</a></td></tr>
<tr class="separator:ga6ee16e76c17384504294d4fec1d85264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8eeac00dfcf4487bff6bba055f2fbe2e"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga8eeac00dfcf4487bff6bba055f2fbe2e">SYS_T::PD_L_MFP</a></td></tr>
<tr class="separator:ga8eeac00dfcf4487bff6bba055f2fbe2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90efc4877dec8729f297074457da943a"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga90efc4877dec8729f297074457da943a">SYS_T::PD_H_MFP</a></td></tr>
<tr class="separator:ga90efc4877dec8729f297074457da943a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe16fa3d0d6cd8b5a6a5c5016c81bab6"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gabe16fa3d0d6cd8b5a6a5c5016c81bab6">SYS_T::PE_L_MFP</a></td></tr>
<tr class="separator:gabe16fa3d0d6cd8b5a6a5c5016c81bab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15ea5302dbb03ab88bb2fd1430da9f90"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga15ea5302dbb03ab88bb2fd1430da9f90">SYS_T::PE_H_MFP</a></td></tr>
<tr class="separator:ga15ea5302dbb03ab88bb2fd1430da9f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07add08f9430d94b83bdb92d0d310df0"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga07add08f9430d94b83bdb92d0d310df0">SYS_T::PF_L_MFP</a></td></tr>
<tr class="separator:ga07add08f9430d94b83bdb92d0d310df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06196df18a6325dad3253828ee6df730"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga06196df18a6325dad3253828ee6df730">SYS_T::RESERVE2</a> [1]</td></tr>
<tr class="separator:ga06196df18a6325dad3253828ee6df730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f7460c376f0ea3779d9446cb12cb923"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga2f7460c376f0ea3779d9446cb12cb923">SYS_T::PORCTL</a></td></tr>
<tr class="separator:ga2f7460c376f0ea3779d9446cb12cb923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcc1733dcd63d84da44ae4c75f6312b2"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gabcc1733dcd63d84da44ae4c75f6312b2">SYS_T::BODCTL</a></td></tr>
<tr class="separator:gabcc1733dcd63d84da44ae4c75f6312b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bae1177bf10fd15b6c8b7d02fce568b"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga0bae1177bf10fd15b6c8b7d02fce568b">SYS_T::BODSTS</a></td></tr>
<tr class="separator:ga0bae1177bf10fd15b6c8b7d02fce568b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c44a4ecdebb23c29b983637fd66c9dc"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga8c44a4ecdebb23c29b983637fd66c9dc">SYS_T::Int_VREFCTL</a></td></tr>
<tr class="separator:ga8c44a4ecdebb23c29b983637fd66c9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bf08ac5aac385ff2ecd010d9178e3b5"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga5bf08ac5aac385ff2ecd010d9178e3b5">SYS_T::LDO_CTL</a></td></tr>
<tr class="separator:ga5bf08ac5aac385ff2ecd010d9178e3b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9724dc13b92d809434d8c849615b213"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gac9724dc13b92d809434d8c849615b213">SYS_T::RESERVE3</a> [3]</td></tr>
<tr class="separator:gac9724dc13b92d809434d8c849615b213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac13d1171be23e2595c900b0f36713b7c"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gac13d1171be23e2595c900b0f36713b7c">SYS_T::IRCTRIMCTL</a></td></tr>
<tr class="separator:gac13d1171be23e2595c900b0f36713b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd3ebb0f8f212d70eeef59ae7077ed55"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gadd3ebb0f8f212d70eeef59ae7077ed55">SYS_T::IRCTRIMIEN</a></td></tr>
<tr class="separator:gadd3ebb0f8f212d70eeef59ae7077ed55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafa54adb500584bd9b19ec01bb0c0caf"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaafa54adb500584bd9b19ec01bb0c0caf">SYS_T::IRCTRIMINT</a></td></tr>
<tr class="separator:gaafa54adb500584bd9b19ec01bb0c0caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a873dceecf467cf62bb6d1fc7a87940"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga6a873dceecf467cf62bb6d1fc7a87940">SYS_T::RESERVE4</a> [29]</td></tr>
<tr class="separator:ga6a873dceecf467cf62bb6d1fc7a87940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad919a9ee2c00afca7cbd30f4a0da78f6"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gad919a9ee2c00afca7cbd30f4a0da78f6">SYS_T::RegLockAddr</a></td></tr>
<tr class="separator:gad919a9ee2c00afca7cbd30f4a0da78f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d09c59b4451ee8cc8736c8078891386"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga1d09c59b4451ee8cc8736c8078891386">GPIO_T::PMD</a></td></tr>
<tr class="separator:ga1d09c59b4451ee8cc8736c8078891386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef33c98df44df03b96cd70ca24c62fc4"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaef33c98df44df03b96cd70ca24c62fc4">GPIO_T::OFFD</a></td></tr>
<tr class="separator:gaef33c98df44df03b96cd70ca24c62fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacedf474a76d41eb49d93ca976fa0afa4"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gacedf474a76d41eb49d93ca976fa0afa4">GPIO_T::DOUT</a></td></tr>
<tr class="separator:gacedf474a76d41eb49d93ca976fa0afa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d1418a8fdc087ba44028f784cbd2ea2"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga5d1418a8fdc087ba44028f784cbd2ea2">GPIO_T::DMASK</a></td></tr>
<tr class="separator:ga5d1418a8fdc087ba44028f784cbd2ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd64ba4db747a13e65ee2ff1eaa0fe47"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gacd64ba4db747a13e65ee2ff1eaa0fe47">GPIO_T::PIN</a></td></tr>
<tr class="separator:gacd64ba4db747a13e65ee2ff1eaa0fe47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3d4810bebd87d723aa1c2553576bc95"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gad3d4810bebd87d723aa1c2553576bc95">GPIO_T::DBEN</a></td></tr>
<tr class="separator:gad3d4810bebd87d723aa1c2553576bc95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga238fd487ce9252ecbab0003630cdeb27"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga238fd487ce9252ecbab0003630cdeb27">GPIO_T::IMD</a></td></tr>
<tr class="separator:ga238fd487ce9252ecbab0003630cdeb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa332e6a57141c2ae9a44acc296a8ca18"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaa332e6a57141c2ae9a44acc296a8ca18">GPIO_T::IER</a></td></tr>
<tr class="separator:gaa332e6a57141c2ae9a44acc296a8ca18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91b435e9c7adfdb9b41621709ba118c4"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga91b435e9c7adfdb9b41621709ba118c4">GPIO_T::ISRC</a></td></tr>
<tr class="separator:ga91b435e9c7adfdb9b41621709ba118c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4363701c030af4adb16f6329a7d59833"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga4363701c030af4adb16f6329a7d59833">GPIO_T::PUEN</a></td></tr>
<tr class="separator:ga4363701c030af4adb16f6329a7d59833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c3a42efc127d5d543a646cac4861e34"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga0c3a42efc127d5d543a646cac4861e34">GP_DB_T::DBNCECON</a></td></tr>
<tr class="separator:ga0c3a42efc127d5d543a646cac4861e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a6b1cd30e7ad401b1dff3f181a0a6c4"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga3a6b1cd30e7ad401b1dff3f181a0a6c4">I2C_T::CON</a></td></tr>
<tr class="separator:ga3a6b1cd30e7ad401b1dff3f181a0a6c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b528aee5b81928cfa6e84f205ac5e88"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga2b528aee5b81928cfa6e84f205ac5e88">I2C_T::INTSTS</a></td></tr>
<tr class="separator:ga2b528aee5b81928cfa6e84f205ac5e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45e9c068d3cc966e206bd45c9b04b074"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga45e9c068d3cc966e206bd45c9b04b074">I2C_T::STATUS</a></td></tr>
<tr class="separator:ga45e9c068d3cc966e206bd45c9b04b074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab20c783148e5e679d8da4415cfad85b2"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gab20c783148e5e679d8da4415cfad85b2">I2C_T::DIV</a></td></tr>
<tr class="separator:gab20c783148e5e679d8da4415cfad85b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ea7086ff7e567448f6fa0cf63a1391b"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga3ea7086ff7e567448f6fa0cf63a1391b">I2C_T::TOUT</a></td></tr>
<tr class="separator:ga3ea7086ff7e567448f6fa0cf63a1391b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab30093acea7930ab2ef7bc15872a1043"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gab30093acea7930ab2ef7bc15872a1043">I2C_T::DATA</a></td></tr>
<tr class="separator:gab30093acea7930ab2ef7bc15872a1043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7563fb74bf39715685191219c1917615"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga7563fb74bf39715685191219c1917615">I2C_T::SADDR0</a></td></tr>
<tr class="separator:ga7563fb74bf39715685191219c1917615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5aaa84688133cbe054ad75fa00130648"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga5aaa84688133cbe054ad75fa00130648">I2C_T::SADDR1</a></td></tr>
<tr class="separator:ga5aaa84688133cbe054ad75fa00130648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab53f85444601fedf71ba84ed308a5ca4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gab53f85444601fedf71ba84ed308a5ca4">I2C_T::RESERVE0</a> [2]</td></tr>
<tr class="separator:gab53f85444601fedf71ba84ed308a5ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf53d28d3d8ac5a0ab9a92a127a557b2d"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaf53d28d3d8ac5a0ab9a92a127a557b2d">I2C_T::SAMASK0</a></td></tr>
<tr class="separator:gaf53d28d3d8ac5a0ab9a92a127a557b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a530f5050894501e7bc05d48cdf0dc9"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga1a530f5050894501e7bc05d48cdf0dc9">I2C_T::SAMASK1</a></td></tr>
<tr class="separator:ga1a530f5050894501e7bc05d48cdf0dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae69ae433f5ac470a10bf5f971fb71642"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gae69ae433f5ac470a10bf5f971fb71642">I2C_T::RESERVE1</a> [4]</td></tr>
<tr class="separator:gae69ae433f5ac470a10bf5f971fb71642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dd0ebcfad612a3b1f86f6a70ba0c386"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga2dd0ebcfad612a3b1f86f6a70ba0c386">I2C_T::CON2</a></td></tr>
<tr class="separator:ga2dd0ebcfad612a3b1f86f6a70ba0c386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cfcc00c975a3f704c9c006512a218fc"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga2cfcc00c975a3f704c9c006512a218fc">I2C_T::STATUS2</a></td></tr>
<tr class="separator:ga2cfcc00c975a3f704c9c006512a218fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9455b650a0a22ebfeb3ed2fd92ac539b"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga9455b650a0a22ebfeb3ed2fd92ac539b">LCD_T::CTL</a></td></tr>
<tr class="separator:ga9455b650a0a22ebfeb3ed2fd92ac539b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4faaa1d0245b10a054375cb0a45bf33c"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga4faaa1d0245b10a054375cb0a45bf33c">LCD_T::DISPCTL</a></td></tr>
<tr class="separator:ga4faaa1d0245b10a054375cb0a45bf33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6cd1ed5436fe8fcb3548f5532c296f4"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gab6cd1ed5436fe8fcb3548f5532c296f4">LCD_T::MEM_0</a></td></tr>
<tr class="separator:gab6cd1ed5436fe8fcb3548f5532c296f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1e43837b252b800886b9cf0b88ab446"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gab1e43837b252b800886b9cf0b88ab446">LCD_T::MEM_1</a></td></tr>
<tr class="separator:gab1e43837b252b800886b9cf0b88ab446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9db343a2fe1219578e34ea71222ff9b3"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga9db343a2fe1219578e34ea71222ff9b3">LCD_T::MEM_2</a></td></tr>
<tr class="separator:ga9db343a2fe1219578e34ea71222ff9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7793dcf6f3123c7912c19b5bfc8d02b2"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga7793dcf6f3123c7912c19b5bfc8d02b2">LCD_T::MEM_3</a></td></tr>
<tr class="separator:ga7793dcf6f3123c7912c19b5bfc8d02b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96d137308b430ea8cedaa9f61c989fee"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga96d137308b430ea8cedaa9f61c989fee">LCD_T::MEM_4</a></td></tr>
<tr class="separator:ga96d137308b430ea8cedaa9f61c989fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6122c7c7d934773037c46d82fba6f478"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga6122c7c7d934773037c46d82fba6f478">LCD_T::MEM_5</a></td></tr>
<tr class="separator:ga6122c7c7d934773037c46d82fba6f478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga860a61f5f5ec937b5eea163d8fe101c1"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga860a61f5f5ec937b5eea163d8fe101c1">LCD_T::MEM_6</a></td></tr>
<tr class="separator:ga860a61f5f5ec937b5eea163d8fe101c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga104d8922b3f16e323b034efca7d01d7e"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga104d8922b3f16e323b034efca7d01d7e">LCD_T::MEM_7</a></td></tr>
<tr class="separator:ga104d8922b3f16e323b034efca7d01d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14cd3a29e195b15b5e8c9acef7ba7115"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga14cd3a29e195b15b5e8c9acef7ba7115">LCD_T::MEM_8</a></td></tr>
<tr class="separator:ga14cd3a29e195b15b5e8c9acef7ba7115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b98f0117b692926f875fc732366f792"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga6b98f0117b692926f875fc732366f792">LCD_T::RESERVE0</a> [1]</td></tr>
<tr class="separator:ga6b98f0117b692926f875fc732366f792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54f4a365cae899c3df7a6916da301e84"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga54f4a365cae899c3df7a6916da301e84">LCD_T::FCR</a></td></tr>
<tr class="separator:ga54f4a365cae899c3df7a6916da301e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa25ad7fbb1cb93402ce992f10d34d48a"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaa25ad7fbb1cb93402ce992f10d34d48a">LCD_T::FCSTS</a></td></tr>
<tr class="separator:gaa25ad7fbb1cb93402ce992f10d34d48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bf7d727d4a434b4ee8157a2e7f9ec81"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga7bf7d727d4a434b4ee8157a2e7f9ec81">PWM_T::PRES</a></td></tr>
<tr class="separator:ga7bf7d727d4a434b4ee8157a2e7f9ec81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga575284c06ad67e614037859cf59f6993"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga575284c06ad67e614037859cf59f6993">PWM_T::CLKSEL</a></td></tr>
<tr class="separator:ga575284c06ad67e614037859cf59f6993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a5218f3d6ce38a982289ba890e94ebc"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga0a5218f3d6ce38a982289ba890e94ebc">PWM_T::CTL</a></td></tr>
<tr class="separator:ga0a5218f3d6ce38a982289ba890e94ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fbc063a076e84e9b8f17ebcee04879e"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga1fbc063a076e84e9b8f17ebcee04879e">PWM_T::INTEN</a></td></tr>
<tr class="separator:ga1fbc063a076e84e9b8f17ebcee04879e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac535addafa0eb3c00a1fba2f4d845451"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gac535addafa0eb3c00a1fba2f4d845451">PWM_T::INTSTS</a></td></tr>
<tr class="separator:gac535addafa0eb3c00a1fba2f4d845451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6615e3d0c9a7c79f9586507567ca43c8"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga6615e3d0c9a7c79f9586507567ca43c8">PWM_T::OE</a></td></tr>
<tr class="separator:ga6615e3d0c9a7c79f9586507567ca43c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga880146e1f82cd56ac83fea85f285e086"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga880146e1f82cd56ac83fea85f285e086">PWM_T::RESERVE0</a> [1]</td></tr>
<tr class="separator:ga880146e1f82cd56ac83fea85f285e086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e445593e42699eb743ebe6ded0d416e"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga1e445593e42699eb743ebe6ded0d416e">PWM_T::DUTY0</a></td></tr>
<tr class="separator:ga1e445593e42699eb743ebe6ded0d416e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac492ca9fe4d8ec74273c1e1a5e783316"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gac492ca9fe4d8ec74273c1e1a5e783316">PWM_T::DATA0</a></td></tr>
<tr class="separator:gac492ca9fe4d8ec74273c1e1a5e783316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32f14231d09f9f6b951ac21635f5d01e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga32f14231d09f9f6b951ac21635f5d01e">PWM_T::RESERVE1</a> [1]</td></tr>
<tr class="separator:ga32f14231d09f9f6b951ac21635f5d01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15e419d84971c3dd1a5e11672102f8d3"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga15e419d84971c3dd1a5e11672102f8d3">PWM_T::DUTY1</a></td></tr>
<tr class="separator:ga15e419d84971c3dd1a5e11672102f8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9db243709384d923303b4750e8593015"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga9db243709384d923303b4750e8593015">PWM_T::DATA1</a></td></tr>
<tr class="separator:ga9db243709384d923303b4750e8593015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd8ea3e41c0de5046768e097edad6074"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gabd8ea3e41c0de5046768e097edad6074">PWM_T::RESERVE2</a> [1]</td></tr>
<tr class="separator:gabd8ea3e41c0de5046768e097edad6074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6147d61adbaeeda64cb1b628d74e771"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gad6147d61adbaeeda64cb1b628d74e771">PWM_T::DUTY2</a></td></tr>
<tr class="separator:gad6147d61adbaeeda64cb1b628d74e771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf13cceaac2f36d56edf9a4e568056b22"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaf13cceaac2f36d56edf9a4e568056b22">PWM_T::DATA2</a></td></tr>
<tr class="separator:gaf13cceaac2f36d56edf9a4e568056b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0539e3b4a1138b2f6fefbef4bab09d1e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga0539e3b4a1138b2f6fefbef4bab09d1e">PWM_T::RESERVE3</a> [1]</td></tr>
<tr class="separator:ga0539e3b4a1138b2f6fefbef4bab09d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98e5ffc188d1b543dc3cbe0557100aba"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga98e5ffc188d1b543dc3cbe0557100aba">PWM_T::DUTY3</a></td></tr>
<tr class="separator:ga98e5ffc188d1b543dc3cbe0557100aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff8373e6eafa04a9b75ffc36188fffca"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaff8373e6eafa04a9b75ffc36188fffca">PWM_T::DATA3</a></td></tr>
<tr class="separator:gaff8373e6eafa04a9b75ffc36188fffca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22b0ee7cf9f53c86810622215189a9f5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga22b0ee7cf9f53c86810622215189a9f5">PWM_T::RESERVE4</a> [3]</td></tr>
<tr class="separator:ga22b0ee7cf9f53c86810622215189a9f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd90a09a831b62d48dd09b92395997cb"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gadd90a09a831b62d48dd09b92395997cb">PWM_T::CAPCTL</a></td></tr>
<tr class="separator:gadd90a09a831b62d48dd09b92395997cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60536c86136f09a69087306a65b6f9f4"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga60536c86136f09a69087306a65b6f9f4">PWM_T::CAPINTEN</a></td></tr>
<tr class="separator:ga60536c86136f09a69087306a65b6f9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c11ac4d6481b29e81e38f6288f7d3dc"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga0c11ac4d6481b29e81e38f6288f7d3dc">PWM_T::CAPINTSTS</a></td></tr>
<tr class="separator:ga0c11ac4d6481b29e81e38f6288f7d3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29f9787deab9252b057fa563f3759187"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga29f9787deab9252b057fa563f3759187">PWM_T::CRL0</a></td></tr>
<tr class="separator:ga29f9787deab9252b057fa563f3759187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa350009fd0f58831db2cf141cf5a81f2"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaa350009fd0f58831db2cf141cf5a81f2">PWM_T::CFL0</a></td></tr>
<tr class="separator:gaa350009fd0f58831db2cf141cf5a81f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad72ee1e1b23d26cc06fe4868d4db611a"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gad72ee1e1b23d26cc06fe4868d4db611a">PWM_T::CRL1</a></td></tr>
<tr class="separator:gad72ee1e1b23d26cc06fe4868d4db611a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa61f9f184253185fef38f0df2d1806f"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gafa61f9f184253185fef38f0df2d1806f">PWM_T::CFL1</a></td></tr>
<tr class="separator:gafa61f9f184253185fef38f0df2d1806f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga504a797400871a6f73459f37a0810794"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga504a797400871a6f73459f37a0810794">PWM_T::CRL2</a></td></tr>
<tr class="separator:ga504a797400871a6f73459f37a0810794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45f84dd5fd63d4b4f5365441cf7c4eb5"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga45f84dd5fd63d4b4f5365441cf7c4eb5">PWM_T::CFL2</a></td></tr>
<tr class="separator:ga45f84dd5fd63d4b4f5365441cf7c4eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65842f44c6f7f39283c170bdb0ca328f"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga65842f44c6f7f39283c170bdb0ca328f">PWM_T::CRL3</a></td></tr>
<tr class="separator:ga65842f44c6f7f39283c170bdb0ca328f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45a7dcc8be3bef81caec04b1da0b0ca2"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga45a7dcc8be3bef81caec04b1da0b0ca2">PWM_T::CFL3</a></td></tr>
<tr class="separator:ga45a7dcc8be3bef81caec04b1da0b0ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00d3ed7d7a00052d7152ad8acb35a5d3"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga00d3ed7d7a00052d7152ad8acb35a5d3">PWM_T::PDMACH0</a></td></tr>
<tr class="separator:ga00d3ed7d7a00052d7152ad8acb35a5d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad03bb7e0395fd46d24e13d608dfb3518"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gad03bb7e0395fd46d24e13d608dfb3518">PWM_T::PDMACH2</a></td></tr>
<tr class="separator:gad03bb7e0395fd46d24e13d608dfb3518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e21b5d2c1786a4e8cfd8b5de0657327"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga8e21b5d2c1786a4e8cfd8b5de0657327">PWM_T::ADTRGEN</a></td></tr>
<tr class="separator:ga8e21b5d2c1786a4e8cfd8b5de0657327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga550b69893c2058e0876f85ff4be7263c"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga550b69893c2058e0876f85ff4be7263c">PWM_T::ADTRGSTS</a></td></tr>
<tr class="separator:ga550b69893c2058e0876f85ff4be7263c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1b69ac1224067d2efd37f74bfc176f9"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaa1b69ac1224067d2efd37f74bfc176f9">RTC_T::INIR</a></td></tr>
<tr class="separator:gaa1b69ac1224067d2efd37f74bfc176f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9283ffd6e2925e436e6763283666e325"><td class="memItemLeft" align="right" valign="top">__O uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga9283ffd6e2925e436e6763283666e325">RTC_T::AER</a></td></tr>
<tr class="separator:ga9283ffd6e2925e436e6763283666e325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49587e6682033dfe454dd2009b2a4341"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga49587e6682033dfe454dd2009b2a4341">RTC_T::FCR</a></td></tr>
<tr class="separator:ga49587e6682033dfe454dd2009b2a4341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa06624870e1a72d15e39316ba0a581c"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaaa06624870e1a72d15e39316ba0a581c">RTC_T::TLR</a></td></tr>
<tr class="separator:gaaa06624870e1a72d15e39316ba0a581c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dc44efebe26ce6f4913a84a2513c9fe"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga8dc44efebe26ce6f4913a84a2513c9fe">RTC_T::CLR</a></td></tr>
<tr class="separator:ga8dc44efebe26ce6f4913a84a2513c9fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf061c521c29b57af2654b536c9ee976c"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaf061c521c29b57af2654b536c9ee976c">RTC_T::TSSR</a></td></tr>
<tr class="separator:gaf061c521c29b57af2654b536c9ee976c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4a7833299d2b3a61dc3d46dbe69c610"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gac4a7833299d2b3a61dc3d46dbe69c610">RTC_T::DWR</a></td></tr>
<tr class="separator:gac4a7833299d2b3a61dc3d46dbe69c610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3aca5cd35bc5b6847d7c3b73b4f90248"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga3aca5cd35bc5b6847d7c3b73b4f90248">RTC_T::TAR</a></td></tr>
<tr class="separator:ga3aca5cd35bc5b6847d7c3b73b4f90248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d2d24398c805a164fbb1f4840652a35"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga3d2d24398c805a164fbb1f4840652a35">RTC_T::CAR</a></td></tr>
<tr class="separator:ga3d2d24398c805a164fbb1f4840652a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64ab49e4601427afac7133470a40e971"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga64ab49e4601427afac7133470a40e971">RTC_T::LIR</a></td></tr>
<tr class="separator:ga64ab49e4601427afac7133470a40e971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e3f50478c302bafe3a0ad71abdeabc8"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga4e3f50478c302bafe3a0ad71abdeabc8">RTC_T::RIER</a></td></tr>
<tr class="separator:ga4e3f50478c302bafe3a0ad71abdeabc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e271103aa712f44406bf7aaa6d1c4d8"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga6e271103aa712f44406bf7aaa6d1c4d8">RTC_T::RIIR</a></td></tr>
<tr class="separator:ga6e271103aa712f44406bf7aaa6d1c4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga017c4ea5adc9a4fd9e837ace5ad3544c"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga017c4ea5adc9a4fd9e837ace5ad3544c">RTC_T::TTR</a></td></tr>
<tr class="separator:ga017c4ea5adc9a4fd9e837ace5ad3544c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0ebb36ccc1d9c7dc94d3275cfdcbed5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gae0ebb36ccc1d9c7dc94d3275cfdcbed5">RTC_T::RESERVE0</a> [2]</td></tr>
<tr class="separator:gae0ebb36ccc1d9c7dc94d3275cfdcbed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac35296c5363050bac2547534960088a9"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gac35296c5363050bac2547534960088a9">RTC_T::SPRCTL</a></td></tr>
<tr class="separator:gac35296c5363050bac2547534960088a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c5f556996172ac3fe01a48548ce8f83"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga8c5f556996172ac3fe01a48548ce8f83">RTC_T::SPR</a> [20]</td></tr>
<tr class="separator:ga8c5f556996172ac3fe01a48548ce8f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafec014ee84168de58491161eff42e1f7"><td class="memItemLeft" >__I uint32_t&#160;&#160;&#160;<a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga071fcc6d567d3ac4e54345160abf87a9">SC_T::RBR</a></td></tr>
<tr class="separator:gafec014ee84168de58491161eff42e1f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85b903bc70752bcd60f69537e38cb4be"><td class="memItemLeft" >__O uint32_t&#160;&#160;&#160;<a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gadfe33df8456b56de687076679cd493f3">SC_T::THR</a></td></tr>
<tr class="separator:ga85b903bc70752bcd60f69537e38cb4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a7f5c1a680c1cb11050725a055f557e"><td class="memItemLeft" >union {</td></tr>
<tr class="memitem:gafec014ee84168de58491161eff42e1f7"><td class="memItemLeft" >&#160;&#160;&#160;__I uint32_t&#160;&#160;&#160;<a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga071fcc6d567d3ac4e54345160abf87a9">SC_T::RBR</a></td></tr>
<tr class="separator:gafec014ee84168de58491161eff42e1f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85b903bc70752bcd60f69537e38cb4be"><td class="memItemLeft" >&#160;&#160;&#160;__O uint32_t&#160;&#160;&#160;<a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gadfe33df8456b56de687076679cd493f3">SC_T::THR</a></td></tr>
<tr class="separator:ga85b903bc70752bcd60f69537e38cb4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a7f5c1a680c1cb11050725a055f557e"><td class="memItemLeft" valign="top">};&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="separator:ga0a7f5c1a680c1cb11050725a055f557e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga657b6619f178ac1a923485d599c1b0f7"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga657b6619f178ac1a923485d599c1b0f7">SC_T::CTL</a></td></tr>
<tr class="separator:ga657b6619f178ac1a923485d599c1b0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ec54b613f4251f58197d4129fd42564"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga5ec54b613f4251f58197d4129fd42564">SC_T::ALTCTL</a></td></tr>
<tr class="separator:ga5ec54b613f4251f58197d4129fd42564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34a0768b1f83a855a84af99cfe1939fd"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga34a0768b1f83a855a84af99cfe1939fd">SC_T::EGTR</a></td></tr>
<tr class="separator:ga34a0768b1f83a855a84af99cfe1939fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90acfb650851f2b72a3dca73041b5df4"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga90acfb650851f2b72a3dca73041b5df4">SC_T::RFTMR</a></td></tr>
<tr class="separator:ga90acfb650851f2b72a3dca73041b5df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45c091e2ae29b2e35d20f989adc427a2"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga45c091e2ae29b2e35d20f989adc427a2">SC_T::ETUCR</a></td></tr>
<tr class="separator:ga45c091e2ae29b2e35d20f989adc427a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae664041daf8c26402757b67aaa5677e2"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gae664041daf8c26402757b67aaa5677e2">SC_T::IER</a></td></tr>
<tr class="separator:gae664041daf8c26402757b67aaa5677e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a6b2fb485cffbfa199e53e7c9565044"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga3a6b2fb485cffbfa199e53e7c9565044">SC_T::ISR</a></td></tr>
<tr class="separator:ga3a6b2fb485cffbfa199e53e7c9565044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa543328de43e1099a7641d0e4c8899f"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaaa543328de43e1099a7641d0e4c8899f">SC_T::TRSR</a></td></tr>
<tr class="separator:gaaa543328de43e1099a7641d0e4c8899f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa725963be021c377b5ce3450109ee26"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gafa725963be021c377b5ce3450109ee26">SC_T::PINCSR</a></td></tr>
<tr class="separator:gafa725963be021c377b5ce3450109ee26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01050a1b1d9d4f5d872fef305a44d5dc"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga01050a1b1d9d4f5d872fef305a44d5dc">SC_T::TMR0</a></td></tr>
<tr class="separator:ga01050a1b1d9d4f5d872fef305a44d5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dc7a095b9af5e3c4cc20484b19d5a76"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga8dc7a095b9af5e3c4cc20484b19d5a76">SC_T::TMR1</a></td></tr>
<tr class="separator:ga8dc7a095b9af5e3c4cc20484b19d5a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5d2aa7e313712f078bc99feeb8249fc"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gac5d2aa7e313712f078bc99feeb8249fc">SC_T::TMR2</a></td></tr>
<tr class="separator:gac5d2aa7e313712f078bc99feeb8249fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35c7fa9d62529991f3e3b737945db3a4"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga35c7fa9d62529991f3e3b737945db3a4">SC_T::UACTL</a></td></tr>
<tr class="separator:ga35c7fa9d62529991f3e3b737945db3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2860d8f09411d649fea976b3f052b96"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gad2860d8f09411d649fea976b3f052b96">SC_T::TDRA</a></td></tr>
<tr class="separator:gad2860d8f09411d649fea976b3f052b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3ed821af51ad76506fe3f42769fd187"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gad3ed821af51ad76506fe3f42769fd187">SC_T::TDRB</a></td></tr>
<tr class="separator:gad3ed821af51ad76506fe3f42769fd187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga069fd6acdea1842f24bba35267ff3ea5"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga069fd6acdea1842f24bba35267ff3ea5">SPI_T::CTL</a></td></tr>
<tr class="separator:ga069fd6acdea1842f24bba35267ff3ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4afe2cb0c518f0dff54c05986b987f33"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga4afe2cb0c518f0dff54c05986b987f33">SPI_T::STATUS</a></td></tr>
<tr class="separator:ga4afe2cb0c518f0dff54c05986b987f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ea1e761f8c180884bc051c73db22e13"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga6ea1e761f8c180884bc051c73db22e13">SPI_T::CLKDIV</a></td></tr>
<tr class="separator:ga6ea1e761f8c180884bc051c73db22e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd5d65619694a5df1436bb9bc1f548d4"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gacd5d65619694a5df1436bb9bc1f548d4">SPI_T::SSR</a></td></tr>
<tr class="separator:gacd5d65619694a5df1436bb9bc1f548d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c47737acb74f2f2d9349a981d095b57"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga7c47737acb74f2f2d9349a981d095b57">SPI_T::RX0</a></td></tr>
<tr class="separator:ga7c47737acb74f2f2d9349a981d095b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62ec07fe66de05dbcb70bcce2a1f3272"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga62ec07fe66de05dbcb70bcce2a1f3272">SPI_T::RX1</a></td></tr>
<tr class="separator:ga62ec07fe66de05dbcb70bcce2a1f3272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bf28b6d289035f03cbe294af78b345b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga9bf28b6d289035f03cbe294af78b345b">SPI_T::RESERVE0</a> [2]</td></tr>
<tr class="separator:ga9bf28b6d289035f03cbe294af78b345b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e6b1c45e89186b0b38d4d5a03dfa063"><td class="memItemLeft" align="right" valign="top">__O uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga2e6b1c45e89186b0b38d4d5a03dfa063">SPI_T::TX0</a></td></tr>
<tr class="separator:ga2e6b1c45e89186b0b38d4d5a03dfa063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga390d2928ba639001d0282683b53ceaf3"><td class="memItemLeft" align="right" valign="top">__O uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga390d2928ba639001d0282683b53ceaf3">SPI_T::TX1</a></td></tr>
<tr class="separator:ga390d2928ba639001d0282683b53ceaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ff3af89b804bed7e4c2d7805fec32e4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga0ff3af89b804bed7e4c2d7805fec32e4">SPI_T::RESERVE1</a> [3]</td></tr>
<tr class="separator:ga0ff3af89b804bed7e4c2d7805fec32e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga762fced4160de55295b4d0854f24f66d"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga762fced4160de55295b4d0854f24f66d">SPI_T::VARCLK</a></td></tr>
<tr class="separator:ga762fced4160de55295b4d0854f24f66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7a436021c5a67252e0ae2e95d9ef9e4"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaf7a436021c5a67252e0ae2e95d9ef9e4">SPI_T::DMA</a></td></tr>
<tr class="separator:gaf7a436021c5a67252e0ae2e95d9ef9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cd9a89d3d1c7a3a6f3e3c5c4beb0727"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga4cd9a89d3d1c7a3a6f3e3c5c4beb0727">SPI_T::FFCTL</a></td></tr>
<tr class="separator:ga4cd9a89d3d1c7a3a6f3e3c5c4beb0727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga267f2a01680881b9bb723e72a022af70"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga267f2a01680881b9bb723e72a022af70">SPI_T::RESERVE2</a> [4]</td></tr>
<tr class="separator:ga267f2a01680881b9bb723e72a022af70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb8d9df4695b742a04b52a7a64594322"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gabb8d9df4695b742a04b52a7a64594322">TIMER_T::CTL</a></td></tr>
<tr class="separator:gabb8d9df4695b742a04b52a7a64594322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a66d55fb7d20c3e12402aa320661d8f"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga6a66d55fb7d20c3e12402aa320661d8f">TIMER_T::PRECNT</a></td></tr>
<tr class="separator:ga6a66d55fb7d20c3e12402aa320661d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91eb63011da0934d7d8edcfb58566417"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga91eb63011da0934d7d8edcfb58566417">TIMER_T::CMPR</a></td></tr>
<tr class="separator:ga91eb63011da0934d7d8edcfb58566417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b93de0ad6cd08676926bcff6888c10d"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga1b93de0ad6cd08676926bcff6888c10d">TIMER_T::IER</a></td></tr>
<tr class="separator:ga1b93de0ad6cd08676926bcff6888c10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7679f758ebbdcf746f8b03195364b47"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaa7679f758ebbdcf746f8b03195364b47">TIMER_T::ISR</a></td></tr>
<tr class="separator:gaa7679f758ebbdcf746f8b03195364b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f5ea6a1af3b26e732ffec08d4d519f5"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga7f5ea6a1af3b26e732ffec08d4d519f5">TIMER_T::DR</a></td></tr>
<tr class="separator:ga7f5ea6a1af3b26e732ffec08d4d519f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4508d4ae8dda154e5e796090fcafff3"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gac4508d4ae8dda154e5e796090fcafff3">TIMER_T::TCAP</a></td></tr>
<tr class="separator:gac4508d4ae8dda154e5e796090fcafff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ecc606ca7cfd8c6693ec2d396b9e3d8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga9ecc606ca7cfd8c6693ec2d396b9e3d8">TIMER_T::RESERVE0</a> [1]</td></tr>
<tr class="separator:ga9ecc606ca7cfd8c6693ec2d396b9e3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6e91877db4ad3b35116bbd1c281bda6"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaf6e91877db4ad3b35116bbd1c281bda6">TIMER_T::ECTL</a></td></tr>
<tr class="separator:gaf6e91877db4ad3b35116bbd1c281bda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa197bb74cef0a08558d1baab9a0db933"><td class="memItemLeft" >__I uint32_t&#160;&#160;&#160;<a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gae89a1c157c8f32081e88d5e41147b885">UART_T::RBR</a></td></tr>
<tr class="separator:gaa197bb74cef0a08558d1baab9a0db933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga001a0fe8a64ffba0713c74fd8b8d469f"><td class="memItemLeft" >__O uint32_t&#160;&#160;&#160;<a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gab2c575051f74234158db4c2627172943">UART_T::THR</a></td></tr>
<tr class="separator:ga001a0fe8a64ffba0713c74fd8b8d469f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab46006a7b232e3c6466e7187f871c4fd"><td class="memItemLeft" >union {</td></tr>
<tr class="memitem:gaa197bb74cef0a08558d1baab9a0db933"><td class="memItemLeft" >&#160;&#160;&#160;__I uint32_t&#160;&#160;&#160;<a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gae89a1c157c8f32081e88d5e41147b885">UART_T::RBR</a></td></tr>
<tr class="separator:gaa197bb74cef0a08558d1baab9a0db933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga001a0fe8a64ffba0713c74fd8b8d469f"><td class="memItemLeft" >&#160;&#160;&#160;__O uint32_t&#160;&#160;&#160;<a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gab2c575051f74234158db4c2627172943">UART_T::THR</a></td></tr>
<tr class="separator:ga001a0fe8a64ffba0713c74fd8b8d469f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab46006a7b232e3c6466e7187f871c4fd"><td class="memItemLeft" valign="top">};&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="separator:gab46006a7b232e3c6466e7187f871c4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ab90d38586ab0cbf20d7b41f1190374"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga9ab90d38586ab0cbf20d7b41f1190374">UART_T::CTL</a></td></tr>
<tr class="separator:ga9ab90d38586ab0cbf20d7b41f1190374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52b6efc5dbbc798e6ed525e3875e3a40"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga52b6efc5dbbc798e6ed525e3875e3a40">UART_T::TLCTL</a></td></tr>
<tr class="separator:ga52b6efc5dbbc798e6ed525e3875e3a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga202d78662da8b815cb7e16a997244a1f"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga202d78662da8b815cb7e16a997244a1f">UART_T::IER</a></td></tr>
<tr class="separator:ga202d78662da8b815cb7e16a997244a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1edf12aec26a4dccd41814cfb02dd949"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga1edf12aec26a4dccd41814cfb02dd949">UART_T::ISR</a></td></tr>
<tr class="separator:ga1edf12aec26a4dccd41814cfb02dd949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4297386c5926124fc6441172a68f844d"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga4297386c5926124fc6441172a68f844d">UART_T::TRSR</a></td></tr>
<tr class="separator:ga4297386c5926124fc6441172a68f844d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4147906e727e2bef07512303f1364881"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga4147906e727e2bef07512303f1364881">UART_T::FSR</a></td></tr>
<tr class="separator:ga4147906e727e2bef07512303f1364881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c448c3fbb4d954410aaef7402d7ca7e"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga0c448c3fbb4d954410aaef7402d7ca7e">UART_T::MCSR</a></td></tr>
<tr class="separator:ga0c448c3fbb4d954410aaef7402d7ca7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69e6fb451dbef4b45969bac159e8ffc0"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga69e6fb451dbef4b45969bac159e8ffc0">UART_T::TMCTL</a></td></tr>
<tr class="separator:ga69e6fb451dbef4b45969bac159e8ffc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ca01dcd16be120667b8ec1b940b2800"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga0ca01dcd16be120667b8ec1b940b2800">UART_T::BAUD</a></td></tr>
<tr class="separator:ga0ca01dcd16be120667b8ec1b940b2800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f27fb255eef2d5ad9a1d18496232119"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga7f27fb255eef2d5ad9a1d18496232119">UART_T::RESERVE0</a> [2]</td></tr>
<tr class="separator:ga7f27fb255eef2d5ad9a1d18496232119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdfc111e8ea7c7fe2aed82d163596da7"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gabdfc111e8ea7c7fe2aed82d163596da7">UART_T::IRCR</a></td></tr>
<tr class="separator:gabdfc111e8ea7c7fe2aed82d163596da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4e9ea8c4f49b557a138d36abaaf770b"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaf4e9ea8c4f49b557a138d36abaaf770b">UART_T::ALT_CTL</a></td></tr>
<tr class="separator:gaf4e9ea8c4f49b557a138d36abaaf770b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51ae34e470c8bc57f5a3a56bc25ca1b6"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga51ae34e470c8bc57f5a3a56bc25ca1b6">UART_T::FUN_SEL</a></td></tr>
<tr class="separator:ga51ae34e470c8bc57f5a3a56bc25ca1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga710545f9c9f66efe5c4426dae5acab78"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga710545f9c9f66efe5c4426dae5acab78">UART_T::BR_COMP</a></td></tr>
<tr class="separator:ga710545f9c9f66efe5c4426dae5acab78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee8e65be2579f6ca7675e9a63886ab42"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gaee8e65be2579f6ca7675e9a63886ab42">WDT_T::CTL</a></td></tr>
<tr class="separator:gaee8e65be2579f6ca7675e9a63886ab42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga780f43a9d3391b6c63694ffda079d3ca"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga780f43a9d3391b6c63694ffda079d3ca">WDT_T::IER</a></td></tr>
<tr class="separator:ga780f43a9d3391b6c63694ffda079d3ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3524d4eaae77066e138492763163bf9"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#gae3524d4eaae77066e138492763163bf9">WDT_T::ISR</a></td></tr>
<tr class="separator:gae3524d4eaae77066e138492763163bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a6969d28148afcd58ecbad152d56c73"><td class="memItemLeft" align="right" valign="top">__O uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga8a6969d28148afcd58ecbad152d56c73">WWDT_T::RLD</a></td></tr>
<tr class="separator:ga8a6969d28148afcd58ecbad152d56c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d24b8fe02f6a146b26cd13985051308"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga8d24b8fe02f6a146b26cd13985051308">WWDT_T::CR</a></td></tr>
<tr class="separator:ga8d24b8fe02f6a146b26cd13985051308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga817777175020f4492081e6e323fcb39e"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga817777175020f4492081e6e323fcb39e">WWDT_T::IER</a></td></tr>
<tr class="separator:ga817777175020f4492081e6e323fcb39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88df6283621250acaa2eb570db9c4d27"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga88df6283621250acaa2eb570db9c4d27">WWDT_T::STS</a></td></tr>
<tr class="separator:ga88df6283621250acaa2eb570db9c4d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a20715644b8a1b46c9600626bffb3b9"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga6a20715644b8a1b46c9600626bffb3b9">WWDT_T::VAL</a></td></tr>
<tr class="separator:ga6a20715644b8a1b46c9600626bffb3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >NANO102/112 Legacy Constants </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gad4d43f8748b542bce39e18790f845ecc" name="gad4d43f8748b542bce39e18790f845ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4d43f8748b542bce39e18790f845ecc">&#9670;&nbsp;</a></span>BIT0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT0&#160;&#160;&#160;(0x00000001)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 0 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10822">10822</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga601923eba46784638244c1ebf2622a2a" name="ga601923eba46784638244c1ebf2622a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga601923eba46784638244c1ebf2622a2a">&#9670;&nbsp;</a></span>BIT1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT1&#160;&#160;&#160;(0x00000002)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 1 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10823">10823</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga8c0f01fdf020d0f7467449b181fe95cb" name="ga8c0f01fdf020d0f7467449b181fe95cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c0f01fdf020d0f7467449b181fe95cb">&#9670;&nbsp;</a></span>BIT10</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT10&#160;&#160;&#160;(0x00000400)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 10 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10832">10832</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga2cda1debde057b596766eba6a76daca0" name="ga2cda1debde057b596766eba6a76daca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cda1debde057b596766eba6a76daca0">&#9670;&nbsp;</a></span>BIT11</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT11&#160;&#160;&#160;(0x00000800)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 11 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10833">10833</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaaa0a6acba8436baabcaa1e91fad6c0bd" name="gaaa0a6acba8436baabcaa1e91fad6c0bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa0a6acba8436baabcaa1e91fad6c0bd">&#9670;&nbsp;</a></span>BIT12</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT12&#160;&#160;&#160;(0x00001000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 12 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10834">10834</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga965dc1748ab1cf91426bd04a2fe16ecf" name="ga965dc1748ab1cf91426bd04a2fe16ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga965dc1748ab1cf91426bd04a2fe16ecf">&#9670;&nbsp;</a></span>BIT13</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT13&#160;&#160;&#160;(0x00002000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 13 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10835">10835</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga41e750b67eb36c8da10328c565b90dd5" name="ga41e750b67eb36c8da10328c565b90dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41e750b67eb36c8da10328c565b90dd5">&#9670;&nbsp;</a></span>BIT14</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT14&#160;&#160;&#160;(0x00004000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 14 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10836">10836</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gae40f5db1c57c98c6db42f15e0a56f03a" name="gae40f5db1c57c98c6db42f15e0a56f03a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae40f5db1c57c98c6db42f15e0a56f03a">&#9670;&nbsp;</a></span>BIT15</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT15&#160;&#160;&#160;(0x00008000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 15 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10837">10837</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga7c55b9d74a6a1b129397792053cf08d5" name="ga7c55b9d74a6a1b129397792053cf08d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c55b9d74a6a1b129397792053cf08d5">&#9670;&nbsp;</a></span>BIT16</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT16&#160;&#160;&#160;(0x00010000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 16 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10838">10838</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga27fe52b845a36280f50414ab4a00f74f" name="ga27fe52b845a36280f50414ab4a00f74f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27fe52b845a36280f50414ab4a00f74f">&#9670;&nbsp;</a></span>BIT17</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT17&#160;&#160;&#160;(0x00020000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 17 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10839">10839</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga56a026d146963b7d977255d9b1f682ae" name="ga56a026d146963b7d977255d9b1f682ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56a026d146963b7d977255d9b1f682ae">&#9670;&nbsp;</a></span>BIT18</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT18&#160;&#160;&#160;(0x00040000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 18 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10840">10840</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga9ce58ae33c478370e59c915b04b05381" name="ga9ce58ae33c478370e59c915b04b05381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ce58ae33c478370e59c915b04b05381">&#9670;&nbsp;</a></span>BIT19</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT19&#160;&#160;&#160;(0x00080000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 19 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10841">10841</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga9c9560bccccb00174801c728f1ed1399" name="ga9c9560bccccb00174801c728f1ed1399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c9560bccccb00174801c728f1ed1399">&#9670;&nbsp;</a></span>BIT2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT2&#160;&#160;&#160;(0x00000004)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 2 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10824">10824</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga83aaba3456aa46dfefe199fe6264d8dc" name="ga83aaba3456aa46dfefe199fe6264d8dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83aaba3456aa46dfefe199fe6264d8dc">&#9670;&nbsp;</a></span>BIT20</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT20&#160;&#160;&#160;(0x00100000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 20 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10842">10842</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga1a5b4d4ca137f11bcb2e9c381f2ea6c5" name="ga1a5b4d4ca137f11bcb2e9c381f2ea6c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a5b4d4ca137f11bcb2e9c381f2ea6c5">&#9670;&nbsp;</a></span>BIT21</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT21&#160;&#160;&#160;(0x00200000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 21 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10843">10843</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gafdaa01ee37bdcd01ea44dbab6a30fd0d" name="gafdaa01ee37bdcd01ea44dbab6a30fd0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdaa01ee37bdcd01ea44dbab6a30fd0d">&#9670;&nbsp;</a></span>BIT22</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT22&#160;&#160;&#160;(0x00400000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 22 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10844">10844</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gada7be80971d1875e5c4774edd3ecd97d" name="gada7be80971d1875e5c4774edd3ecd97d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada7be80971d1875e5c4774edd3ecd97d">&#9670;&nbsp;</a></span>BIT23</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT23&#160;&#160;&#160;(0x00800000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 23 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10845">10845</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga96cfb019bda32752ff4c8b8244aa6ea0" name="ga96cfb019bda32752ff4c8b8244aa6ea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96cfb019bda32752ff4c8b8244aa6ea0">&#9670;&nbsp;</a></span>BIT24</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT24&#160;&#160;&#160;(0x01000000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 24 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10846">10846</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga3017291241a7269c1582154a3d3b1f09" name="ga3017291241a7269c1582154a3d3b1f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3017291241a7269c1582154a3d3b1f09">&#9670;&nbsp;</a></span>BIT25</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT25&#160;&#160;&#160;(0x02000000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 25 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10847">10847</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga4f97a8963cc15a1a50521d855b8a1331" name="ga4f97a8963cc15a1a50521d855b8a1331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f97a8963cc15a1a50521d855b8a1331">&#9670;&nbsp;</a></span>BIT26</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT26&#160;&#160;&#160;(0x04000000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 26 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10848">10848</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gafdd1584eaddf508717554b35a600b0fd" name="gafdd1584eaddf508717554b35a600b0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdd1584eaddf508717554b35a600b0fd">&#9670;&nbsp;</a></span>BIT27</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT27&#160;&#160;&#160;(0x08000000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 27 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10849">10849</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga4361544977e96fb8eb8387ff0feaf6b6" name="ga4361544977e96fb8eb8387ff0feaf6b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4361544977e96fb8eb8387ff0feaf6b6">&#9670;&nbsp;</a></span>BIT28</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT28&#160;&#160;&#160;(0x10000000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 28 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10850">10850</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gadb368e517e545da53d8aace5923649e1" name="gadb368e517e545da53d8aace5923649e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb368e517e545da53d8aace5923649e1">&#9670;&nbsp;</a></span>BIT29</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT29&#160;&#160;&#160;(0x20000000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 29 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10851">10851</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga8e44574a8a8becc885b05f3bc367ef6a" name="ga8e44574a8a8becc885b05f3bc367ef6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e44574a8a8becc885b05f3bc367ef6a">&#9670;&nbsp;</a></span>BIT3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT3&#160;&#160;&#160;(0x00000008)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 3 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10825">10825</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga70105c4a8c864754c8ba9e9b0e5da52a" name="ga70105c4a8c864754c8ba9e9b0e5da52a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70105c4a8c864754c8ba9e9b0e5da52a">&#9670;&nbsp;</a></span>BIT30</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT30&#160;&#160;&#160;(0x40000000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 30 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10852">10852</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gadfb09898dca36071e32cb1fbeec479e5" name="gadfb09898dca36071e32cb1fbeec479e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfb09898dca36071e32cb1fbeec479e5">&#9670;&nbsp;</a></span>BIT31</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT31&#160;&#160;&#160;(0x80000000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 31 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10853">10853</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaa731e0b6cf75f4e637ee88959315f5e4" name="gaa731e0b6cf75f4e637ee88959315f5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa731e0b6cf75f4e637ee88959315f5e4">&#9670;&nbsp;</a></span>BIT4</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT4&#160;&#160;&#160;(0x00000010)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 4 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10826">10826</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gae692bc3df48028ceb1ddc2534a993bb8" name="gae692bc3df48028ceb1ddc2534a993bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae692bc3df48028ceb1ddc2534a993bb8">&#9670;&nbsp;</a></span>BIT5</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT5&#160;&#160;&#160;(0x00000020)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 5 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10827">10827</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gacc2d074401e2b6322ee8f03476c24677" name="gacc2d074401e2b6322ee8f03476c24677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc2d074401e2b6322ee8f03476c24677">&#9670;&nbsp;</a></span>BIT6</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT6&#160;&#160;&#160;(0x00000040)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 6 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10828">10828</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaa6b8f3261ae9e2e1043380c192f7b5f0" name="gaa6b8f3261ae9e2e1043380c192f7b5f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6b8f3261ae9e2e1043380c192f7b5f0">&#9670;&nbsp;</a></span>BIT7</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT7&#160;&#160;&#160;(0x00000080)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 7 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10829">10829</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga0e80e65237843fa1ff15c68cd78066f8" name="ga0e80e65237843fa1ff15c68cd78066f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e80e65237843fa1ff15c68cd78066f8">&#9670;&nbsp;</a></span>BIT8</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT8&#160;&#160;&#160;(0x00000100)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 8 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10830">10830</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga3aa20ab5eb33383fa31b0e94f4401cdf" name="ga3aa20ab5eb33383fa31b0e94f4401cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3aa20ab5eb33383fa31b0e94f4401cdf">&#9670;&nbsp;</a></span>BIT9</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT9&#160;&#160;&#160;(0x00000200)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 9 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10831">10831</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga2da6b6038c3e29eb02a23385f7dfe18e" name="ga2da6b6038c3e29eb02a23385f7dfe18e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2da6b6038c3e29eb02a23385f7dfe18e">&#9670;&nbsp;</a></span>BYTE0_Msk</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BYTE0_Msk&#160;&#160;&#160;(0x000000FF)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask to get bit0~bit7 from a 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10856">10856</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga6bdb45c3d1adab74d72eab6116f9581c" name="ga6bdb45c3d1adab74d72eab6116f9581c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bdb45c3d1adab74d72eab6116f9581c">&#9670;&nbsp;</a></span>BYTE1_Msk</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BYTE1_Msk&#160;&#160;&#160;(0x0000FF00)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask to get bit8~bit15 from a 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10857">10857</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga6a926438abfcff696496c60ee5ebd4da" name="ga6a926438abfcff696496c60ee5ebd4da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a926438abfcff696496c60ee5ebd4da">&#9670;&nbsp;</a></span>BYTE2_Msk</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BYTE2_Msk&#160;&#160;&#160;(0x00FF0000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask to get bit16~bit23 from a 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10858">10858</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga26cd8778bf420a922c9cd2bf7c916875" name="ga26cd8778bf420a922c9cd2bf7c916875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26cd8778bf420a922c9cd2bf7c916875">&#9670;&nbsp;</a></span>BYTE3_Msk</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BYTE3_Msk&#160;&#160;&#160;(0xFF000000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask to get bit24~bit31 from a 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10859">10859</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga99496f7308834e8b220f7894efa0b6ab" name="ga99496f7308834e8b220f7894efa0b6ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99496f7308834e8b220f7894efa0b6ab">&#9670;&nbsp;</a></span>DISABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DISABLE&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable, define to use in API parameters. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10819">10819</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga514ad415fb6125ba296793df7d1a468a" name="ga514ad415fb6125ba296793df7d1a468a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga514ad415fb6125ba296793df7d1a468a">&#9670;&nbsp;</a></span>ENABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENABLE&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable, define to use in API parameters. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10818">10818</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaa93f0eb578d23995850d61f7d61c55c1" name="gaa93f0eb578d23995850d61f7d61c55c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa93f0eb578d23995850d61f7d61c55c1">&#9670;&nbsp;</a></span>FALSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FALSE&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boolean false, define to use in API parameters or return value. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10816">10816</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaf4adc89d1a476c51ae52eb700a06fb96" name="gaf4adc89d1a476c51ae52eb700a06fb96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4adc89d1a476c51ae52eb700a06fb96">&#9670;&nbsp;</a></span>GET_BYTE0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GET_BYTE0</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">u32Param</td><td>)</td>
          <td>&#160;&#160;&#160;((u32Param &amp; <a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga2da6b6038c3e29eb02a23385f7dfe18e">BYTE0_Msk</a>)      )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Extract Byte 0 (Bit 0~ 7) from parameter u32Param </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10861">10861</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga61fd653ee8852ef7bb04fff1509febc8" name="ga61fd653ee8852ef7bb04fff1509febc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61fd653ee8852ef7bb04fff1509febc8">&#9670;&nbsp;</a></span>GET_BYTE1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GET_BYTE1</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">u32Param</td><td>)</td>
          <td>&#160;&#160;&#160;((u32Param &amp; <a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga6bdb45c3d1adab74d72eab6116f9581c">BYTE1_Msk</a>) &gt;&gt;  8)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Extract Byte 1 (Bit 8~15) from parameter u32Param </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10862">10862</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga35d066854cc83e3823a21f9972fc308f" name="ga35d066854cc83e3823a21f9972fc308f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35d066854cc83e3823a21f9972fc308f">&#9670;&nbsp;</a></span>GET_BYTE2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GET_BYTE2</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">u32Param</td><td>)</td>
          <td>&#160;&#160;&#160;((u32Param &amp; <a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga6a926438abfcff696496c60ee5ebd4da">BYTE2_Msk</a>) &gt;&gt; 16)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Extract Byte 2 (Bit 16~23) from parameter u32Param </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10863">10863</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga2b580f1b27a79bb2b5924a40c9867ab4" name="ga2b580f1b27a79bb2b5924a40c9867ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b580f1b27a79bb2b5924a40c9867ab4">&#9670;&nbsp;</a></span>GET_BYTE3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GET_BYTE3</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">u32Param</td><td>)</td>
          <td>&#160;&#160;&#160;((u32Param &amp; <a class="el" href="../../d4/d75/group___n_a_n_o1_x2__legacy___constants.html#ga26cd8778bf420a922c9cd2bf7c916875">BYTE3_Msk</a>) &gt;&gt; 24)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Extract Byte 3 (Bit 24~31) from parameter u32Param </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10864">10864</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga070d2ce7b6bb7e5c05602aa8c308d0c4" name="ga070d2ce7b6bb7e5c05602aa8c308d0c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga070d2ce7b6bb7e5c05602aa8c308d0c4">&#9670;&nbsp;</a></span>NULL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NULL&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>NULL pointer. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10812">10812</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaa8cecfc5c5c054d2875c03e77b7be15d" name="gaa8cecfc5c5c054d2875c03e77b7be15d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8cecfc5c5c054d2875c03e77b7be15d">&#9670;&nbsp;</a></span>TRUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TRUE&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boolean true, define to use in API parameters or return value. </p>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10815">10815</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga0a7f5c1a680c1cb11050725a055f557e" name="ga0a7f5c1a680c1cb11050725a055f557e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a7f5c1a680c1cb11050725a055f557e">&#9670;&nbsp;</a></span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union  { ... }  SC_T::@1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gab46006a7b232e3c6466e7187f871c4fd" name="gab46006a7b232e3c6466e7187f871c4fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab46006a7b232e3c6466e7187f871c4fd">&#9670;&nbsp;</a></span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union  { ... }  UART_T::@3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga8e21b5d2c1786a4e8cfd8b5de0657327" name="ga8e21b5d2c1786a4e8cfd8b5de0657327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e21b5d2c1786a4e8cfd8b5de0657327">&#9670;&nbsp;</a></span>ADTRGEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::ADTRGEN</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md302"></a>
ADTRGEN</h1>
<h2><a class="anchor" id="autotoc_md303"></a>
Offset: 0x88  PWM Center-Triggered Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">TRGCH0EN   </td><td class="markdownTableBodyLeft">PWM CH0 Center-Triggered Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM CH0 center-triggered function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM CH0 center-triggered function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: The center-triggered function is only valid in PWM center-aligned mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">TRGCH1EN   </td><td class="markdownTableBodyLeft">PWM CH1 Center-Triggered Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM CH1 center-triggered function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM CH1 center-triggered function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: The center-triggered function is only valid in PWM center-aligned mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">TRGCH2EN   </td><td class="markdownTableBodyLeft">PWM CH2 Center-Triggered Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM CH2 center-triggered function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM CH2 center-triggered function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: The center-triggered function is only valid in PWM center-aligned mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">TRGCH3EN   </td><td class="markdownTableBodyLeft">PWM CH3 Center-Triggered Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM CH3 center-triggered function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM CH3 center-triggered function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: The center-triggered function is only valid in PWM center-aligned mode.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l06579">6579</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga550b69893c2058e0876f85ff4be7263c" name="ga550b69893c2058e0876f85ff4be7263c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga550b69893c2058e0876f85ff4be7263c">&#9670;&nbsp;</a></span>ADTRGSTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::ADTRGSTS</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md304"></a>
ADTRGSTS</h1>
<h2><a class="anchor" id="autotoc_md305"></a>
Offset: 0x8C  PWM Center-Triggered Indication Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">ADTRG0Flag   </td><td class="markdownTableBodyLeft">PWM CH0 Center-Triggered Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM CH0 has not crossed half of PWM period yet.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM CH0 has crossed half of PWM period.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This flag is only valid in center-aligned mode, and software could write 1 into this bit to clear the flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">ADTRG1Flag   </td><td class="markdownTableBodyLeft">PWM CH1 Center-Triggered Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM CH1 has not crossed half of PWM period yet.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM CH1 has crossed half of PWM period.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This flag is only valid in center-aligned mode, and software could write 1 into this bit to clear the flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">ADTRG2Flag   </td><td class="markdownTableBodyLeft">PWM CH2 Center-Triggered Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM CH2 has not crossed half of PWM period yet.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM CH2 has crossed half of PWM period.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This flag is only valid in center-aligned mode, and software could write 1 into this bit to clear the flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">ADTRG3Flag   </td><td class="markdownTableBodyLeft">PWM CH3 Center-Triggered Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM CH3 has not crossed half of PWM period yet.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM CH3 has crossed half of PWM period.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This flag is only valid in center-aligned mode, and software could write 1 into this bit to clear the flag   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l06605">6605</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga9283ffd6e2925e436e6763283666e325" name="ga9283ffd6e2925e436e6763283666e325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9283ffd6e2925e436e6763283666e325">&#9670;&nbsp;</a></span>AER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__O uint32_t RTC_T::AER</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md308"></a>
AER</h1>
<h2><a class="anchor" id="autotoc_md309"></a>
Offset: 0x04  RTC Access Enable Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">AER   </td><td class="markdownTableBodyLeft">RTC Register Access Enable Password (Write Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Enable RTC access after write 0xA965. Otherwise disable RTC access.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">ENF   </td><td class="markdownTableBodyLeft">RTC Register Access Enable Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RTC register read/write disable.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RTC register read/write enable.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit will be set after AER[15:0] register is load a 0xA965, and be clear automatically 512 RTC clocks or AER[15:0] is not 0xA965.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l07107">7107</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga808b691f73f5988acf98189dc52c2258" name="ga808b691f73f5988acf98189dc52c2258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga808b691f73f5988acf98189dc52c2258">&#9670;&nbsp;</a></span>AHBCLK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t CLK_T::AHBCLK</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md34"></a>
AHBCLK</h1>
<h2><a class="anchor" id="autotoc_md35"></a>
Offset: 0x04  AHB Devices Clock Enable Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">GPIO_EN   </td><td class="markdownTableBodyLeft">GPIO Controller Clock Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">DMA_EN   </td><td class="markdownTableBodyLeft">DMA Controller Clock Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">ISP_EN   </td><td class="markdownTableBodyLeft">Flash ISP Controller Clock Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">SRAM_EN   </td><td class="markdownTableBodyLeft">SRAM Controller Clock Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">TICK_EN   </td><td class="markdownTableBodyLeft">System Tick Clock Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l01008">1008</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaf4e9ea8c4f49b557a138d36abaaf770b" name="gaf4e9ea8c4f49b557a138d36abaaf770b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4e9ea8c4f49b557a138d36abaaf770b">&#9670;&nbsp;</a></span>ALT_CTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t UART_T::ALT_CTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md428"></a>
ALT_CTL</h1>
<h2><a class="anchor" id="autotoc_md429"></a>
Offset: 0x34  UART Alternate Control State Register.</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2:0]   </td><td class="markdownTableBodyCenter">LIN_TX_BCNT   </td><td class="markdownTableBodyLeft">LIN TX Break Field Count Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The field contains 3-bit LIN TX break field count.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: The break field length is LIN_TX_BCNT + 8.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5:4]   </td><td class="markdownTableBodyCenter">LIN_HEAD_SEL   </td><td class="markdownTableBodyLeft">LIN Header Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = The LIN header includes "break field".    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = The LIN header includes "break field + sync field".    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = The LIN header includes "break field + sync field + PID field".    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">LIN_RX_EN   </td><td class="markdownTableBodyLeft">LIN RX Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When LIN RX mode enabled and received a break field or sync field or PID field (Select by LIN_Header_SEL), the controller will generator a interrupt to CPU (INT_LIN)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = LIN RX mode Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = LIN RX mode Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">LIN_TX_EN   </td><td class="markdownTableBodyLeft">LIN TX Header Trigger Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = LIN TX Header Trigger Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = LIN TX Header Trigger Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This bit will be cleared automatically and generate a interrupt to CPU (INT_LIN).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: If user wants to receive transmit data, it recommended to enable LIN_RX_EN bit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">BIT_ERR_EN   </td><td class="markdownTableBodyLeft">Bit Error Detect Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Bit error detection Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Bit error detection Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: In LIN function mode, when bit error occurs, hardware will generate an interrupt to CPU (INT_LIN).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">RS485_NMM   </td><td class="markdownTableBodyLeft">RS-485 Normal Multi-Drop Operation Mode (RS-485 NMM Mode)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RS-485 Normal Multi-drop Operation mode (NMM) Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RS-485 Normal Multi-drop Operation mode (NMM) Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: It can't be active in RS-485_AAD Operation mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[17]   </td><td class="markdownTableBodyCenter">RS485_AAD   </td><td class="markdownTableBodyLeft">RS-485 Auto Address Detection Operation Mode (RS-485 AAD Mode)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RS-485 Auto Address Detection Operation mode (AAD) Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RS-485 Auto Address Detection Operation mode (AAD) Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: It can't be active in RS-485_NMM Operation mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[18]   </td><td class="markdownTableBodyCenter">RS485_AUD   </td><td class="markdownTableBodyLeft">RS-485 Auto Direction Mode (RS-485 AUD Mode)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RS-485 Auto Direction mode (AUD) Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RS-485 Auto Direction mode (AUD) Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: It can be active in RS-485_AAD or RS-485_NMM operation mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[19]   </td><td class="markdownTableBodyCenter">RS485_ADD_EN   </td><td class="markdownTableBodyLeft">RS-485 Address Detection Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is used to enable RS-485 hardware address detection mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If hardware detects address byte, and then the controller will set UART_TRSR [RS485_ADDET_F] = "1".    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Address detection mode Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Address detection mode Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This field is used for RS-485 any operation mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[31:24]   </td><td class="markdownTableBodyCenter">ADDR_PID_MATCH   </td><td class="markdownTableBodyLeft">Address / PID Match Value Register    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field contains the RS-485 address match values in RS-485 Function mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field contains the LIN protected identifier field n LIN Function mode, software fills ID0~ID5 (ADDR_PID_MATCH [5:0]), hardware will calculate P0 and P1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This field is used for RS-485 auto address detection mode or used for LIN protected identifier field (PID).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10000">10000</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga5ec54b613f4251f58197d4129fd42564" name="ga5ec54b613f4251f58197d4129fd42564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ec54b613f4251f58197d4129fd42564">&#9670;&nbsp;</a></span>ALTCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SC_T::ALTCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md338"></a>
ALTCTL</h1>
<h2><a class="anchor" id="autotoc_md339"></a>
Offset: 0x08  SC Alternate Control Register.</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">TX_RST   </td><td class="markdownTableBodyLeft">TX Software Reset    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When TX_RST is set, all the bytes in the transmit buffer and TX internal state machine will be cleared.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No effect.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Reset the TX internal state machine and pointers.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit will be auto cleared and needs at least 3 SC engine clock cycles.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">RX_RST   </td><td class="markdownTableBodyLeft">RX Software Reset    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When RX_RST is set, all the bytes in the receiver buffer and RX internal state machine will be cleared.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No effect.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Reset the RX internal state machine and pointers.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit will be auto cleared and needs at least 3 SC engine clock cycles.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">DACT_EN   </td><td class="markdownTableBodyLeft">Deactivation Sequence Generator Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit enables SC controller to initiate the card by deactivation sequence    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No effect.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Deactivation sequence generator Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: When the deactivation sequence completed, this bit will be cleared automatically and the SC_ISR [INIT_IS] will be set to "1".    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: This field will be cleared by TX_RST and RX_RST.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">So don't fill this bit, TX_RST, and RX_RST at the same time.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note3: If SC_CTL [SC_CEN] is not enabled, this filed can not be programmed.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">ACT_EN   </td><td class="markdownTableBodyLeft">Activation Sequence Generator Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit enables SC controller to initiate the card by activation sequence    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No effect.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Activation sequence generator Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: When the activation sequence completed, this bit will be cleared automatically and the SC_IS [INIT_IS] will be set to "1".    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: This field will be cleared by TX_RST and RX_RST, so don't fill this bit, TX_RST, and RX_RST at the same time.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note3: If SC_CTL [SC_CEN] is not enabled, this filed can not be programmed.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">WARST_EN   </td><td class="markdownTableBodyLeft">Warm Reset Sequence Generator Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit enables SC controller to initiate the card by warm reset sequence    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No effect.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Warm reset sequence generator Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: When the warm reset sequence completed, this bit will be cleared automatically and the SC_ISR [INIT_IS] will be set to "1".    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: This field will be cleared by TX_RST and RX_RST, so don't fill this bit, TX_RST, and RX_RST at the same time.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note3: If SC_CTL [SC_CEN] is not enabled, this filed can not be programmed.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">TMR0_SEN   </td><td class="markdownTableBodyLeft">Internal Timer0 Start Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit enables Timer0 to start counting.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Software can fill "0" to stop it and set "1" to reload and count.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Stops counting.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Starts counting.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This field is used for internal 24 bit timer when SC_CTL [TMR_SEL] = 01.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: If the operation mode is not in auto-reload mode (SC_TMR0 [26] = "0"), this bit will be auto-cleared by hardware.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note3: This field will be cleared by TX_RST and RX_RST.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">So don't fill this bit, TX_RST and RX_RST at the same time.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note4: If SC_CTL [SC_CEN] is not enabled, this filed can not be programmed.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">TMR1_SEN   </td><td class="markdownTableBodyLeft">Internal Timer1 Start Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit enables Timer "1" to start counting.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Software can fill 0 to stop it and set "1" to reload and count.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Stops counting.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Starts counting.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This field is used for internal 8-bit timer when SC_CTL [TMR_SEL] = 01 or 10.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Don't filled TMR1_SEN when SC_CTL [TMR_SEL] = 00 or 11.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: If the operation mode is not in auto-reload mode (SC_TMR1 [26] = "0"), this bit will be auto-cleared by hardware.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note3: This field will be cleared by TX_RST and RX_RST, so don't fill this bit, TX_RST, and RX_RST at the same time.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note4: If SC_CTL [SC_CEN] is not enabled, this filed can not be programmed.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">TMR2_SEN   </td><td class="markdownTableBodyLeft">Internal Timer2 Start Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit enables Timer2 to start counting.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Software can fill "0" to stop it and set "1" to reload and count.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Stops counting.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Starts counting.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This field is used for internal 8-bit timer when SC_CTL [TMR_SEL] == 11.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Don't filled TMR2_SEN when SC_CTL [TMR_SEL] == 00 or 01 or 10.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: If the operation mode is not in auto-reload mode (SC_TMR2 [26] = "0"), this bit will be auto-cleared by hardware.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note3: This field will be cleared by TX_RST and RX_RST.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">So don't fill this bit, TX_RST, and RX_RST at the same time.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note4: If SC_CTL [SC_CEN] is not enabled, this filed can not be programmed.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[9:8]   </td><td class="markdownTableBodyCenter">INIT_SEL   </td><td class="markdownTableBodyLeft">Initial Timing Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field indicates the timing of hardware initial state (activation or warm-reset or deactivation).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[12]   </td><td class="markdownTableBodyCenter">RX_BGT_EN   </td><td class="markdownTableBodyLeft">Receiver Block Guard Time Function Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Receiver block guard time function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Receiver block guard time function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[13]   </td><td class="markdownTableBodyCenter">TMR0_ATV   </td><td class="markdownTableBodyLeft">Internal Timer0 Active State (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates the timer counter status of timer0.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Timer0 is not active.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Timer0 is active.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[14]   </td><td class="markdownTableBodyCenter">TMR1_ATV   </td><td class="markdownTableBodyLeft">Internal Timer1 Active State (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates the timer counter status of timer1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Timer1 is not active.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Timer1 is active.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15]   </td><td class="markdownTableBodyCenter">TMR2_ATV   </td><td class="markdownTableBodyLeft">Internal Timer2 Active State (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates the timer counter status of timer2.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Timer2 is not active.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Timer2 is active.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l07748">7748</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga1e3a18ffbc3f4aee6c6fc5e8a1ae553e" name="ga1e3a18ffbc3f4aee6c6fc5e8a1ae553e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e3a18ffbc3f4aee6c6fc5e8a1ae553e">&#9670;&nbsp;</a></span>APB_DIV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t CLK_T::APB_DIV</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md56"></a>
APB_DIV</h1>
<h2><a class="anchor" id="autotoc_md57"></a>
Offset: 0x34  APB Clock Divider</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2:0]   </td><td class="markdownTableBodyCenter">APBDIV   </td><td class="markdownTableBodyLeft">APB Clock Divider    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">APB PCLK can be divided from HCLK.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">000: PCLK = HCLK.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">001: PCLK =1/2 HCLK.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">010: PCLK = 1/4 HCLK.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">011: PCLK = 1/8 HCLK.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">100: PCLK = 1/16 HCLK.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others: PCLK = HCLK.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l01354">1354</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gab95b1d5348167498809cbe3d4afa7960" name="gab95b1d5348167498809cbe3d4afa7960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab95b1d5348167498809cbe3d4afa7960">&#9670;&nbsp;</a></span>APBCLK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t CLK_T::APBCLK</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md36"></a>
APBCLK</h1>
<h2><a class="anchor" id="autotoc_md37"></a>
Offset: 0x08  APB Devices Clock Enable Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">WDT_EN   </td><td class="markdownTableBodyLeft">Watchdog Timer Clock Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a protected register. Please refer to open lock sequence to program it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is used to control the WDT APB clock only, The WDT engine Clock Source is from LIRC.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">RTC_EN   </td><td class="markdownTableBodyLeft">Real-Time-Clock Clock Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is used to control the RTC APB clock only, The RTC engine Clock Source is from LXT.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">TMR0_EN   </td><td class="markdownTableBodyLeft">Timer0 Clock Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">TMR1_EN   </td><td class="markdownTableBodyLeft">Timer1 Clock Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">TMR2_EN   </td><td class="markdownTableBodyLeft">Timer2 Clock Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">TMR3_EN   </td><td class="markdownTableBodyLeft">Timer3 Clock Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">FDIV0_EN   </td><td class="markdownTableBodyLeft">Frequency Divider0 Output Clock Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">FDIV1_EN   </td><td class="markdownTableBodyLeft">Frequency Divider1 Output Clock Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">I2C0_EN   </td><td class="markdownTableBodyLeft">I2C0 Clock Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">I2C1_EN   </td><td class="markdownTableBodyLeft">I2C1 Clock Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[11]   </td><td class="markdownTableBodyCenter">ACMP_EN   </td><td class="markdownTableBodyLeft">ACMP Clock Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[12]   </td><td class="markdownTableBodyCenter">SPI0_EN   </td><td class="markdownTableBodyLeft">SPI0 Clock Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[13]   </td><td class="markdownTableBodyCenter">SPI1_EN   </td><td class="markdownTableBodyLeft">SPI1 Clock Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">UART0_EN   </td><td class="markdownTableBodyLeft">UART0 Clock Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[17]   </td><td class="markdownTableBodyCenter">UART1_EN   </td><td class="markdownTableBodyLeft">UART1 Clock Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[20]   </td><td class="markdownTableBodyCenter">PWM0_CH01_EN   </td><td class="markdownTableBodyLeft">PWM0 Channel 0 And Channel 1Clock Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[21]   </td><td class="markdownTableBodyCenter">PWM0_CH23_EN   </td><td class="markdownTableBodyLeft">PWM0 Channel 2 And Channel 3 Clock Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[26]   </td><td class="markdownTableBodyCenter">LCD_EN   </td><td class="markdownTableBodyLeft">LCD Controller Clock Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[28]   </td><td class="markdownTableBodyCenter">ADC_EN   </td><td class="markdownTableBodyLeft">Analog-Digital-Converter (ADC) Clock Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[30]   </td><td class="markdownTableBodyCenter">SC0_EN   </td><td class="markdownTableBodyLeft">SmartCard 0 Clock Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[31]   </td><td class="markdownTableBodyCenter">SC1_EN   </td><td class="markdownTableBodyLeft">SmartCard 1 Clock Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l01084">1084</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga0ca01dcd16be120667b8ec1b940b2800" name="ga0ca01dcd16be120667b8ec1b940b2800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ca01dcd16be120667b8ec1b940b2800">&#9670;&nbsp;</a></span>BAUD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t UART_T::BAUD</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md424"></a>
BAUD</h1>
<h2><a class="anchor" id="autotoc_md425"></a>
Offset: 0x24  UART Baud Rate Divisor Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">BRD   </td><td class="markdownTableBodyLeft">Baud Rate Divider    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[31]   </td><td class="markdownTableBodyCenter">DIV_16_EN   </td><td class="markdownTableBodyLeft">Divider 16 Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The BRD = Baud Rate Divider, and the baud rate equation is Baud Rate = UART_CLK/ [16 * (BRD + 1)];    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The equation of baud rate is UART_CLK / [ (BRD+1)].    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The equation of baud rate is UART_CLK / [16 * (BRD+1)].    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: In IrDA mode, this bit must disable.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l09925">9925</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gafb440a7a3753ec21c130497aef7de4b8" name="gafb440a7a3753ec21c130497aef7de4b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb440a7a3753ec21c130497aef7de4b8">&#9670;&nbsp;</a></span>BCR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PDMA_T::BCR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md98"></a>
BCR</h1>
<h2><a class="anchor" id="autotoc_md99"></a>
Offset: 0x0C  PDMA Transfer Byte Count Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PDMA_BCR   </td><td class="markdownTableBodyLeft">PDMA Transfer Byte Count Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field indicates a 16-bit transfer byte count of PDMA.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: In Memory-to-memory (PDMA_CSR [MODE_SEL] = 00) mode, the transfer byte count must be word alignment.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l02153">2153</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gabcc1733dcd63d84da44ae4c75f6312b2" name="gabcc1733dcd63d84da44ae4c75f6312b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcc1733dcd63d84da44ae4c75f6312b2">&#9670;&nbsp;</a></span>BODCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SYS_T::BODCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md160"></a>
BODCTL</h1>
<h2><a class="anchor" id="autotoc_md161"></a>
Offset: 0x64  Brown-out Detector Controller Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">BOD17_EN   </td><td class="markdownTableBodyLeft">Brown-Out Detector 1.7V Function Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a protected register. Please refer to open lock sequence to program it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The default value is set by flash controller user configuration register config0 bit[20:19]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Users can disable BOD17_EN but it takes effective (disabled) only in Power-down mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Once existing Power-down mode, BOD17 will be enabled by HW automatically.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When CPU reads this bit, CPU will read whether BOD17 function enabled or not.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In other words,CPU will always read high.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Brown-out Detector 1.7V function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Brown-out Detector 1.7V function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">BOD20_EN   </td><td class="markdownTableBodyLeft">Brown-Out Detector 2.0 V Function Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a protected register. Please refer to open lock sequence to program it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Brown-out Detector 2.0 V function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Brown-out Detector 2.0 V function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">BOD20_EN is default on.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If SW disables it, Brown-out Detector 2.0 V function is not disabled until chip enters power-down mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If system is not in power-down mode, BOD20_EN will be enabled by hardware automatically.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">BOD25_EN   </td><td class="markdownTableBodyLeft">Brown-Out Detector 2.5 V Function Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a protected register. Please refer to open lock sequence to program it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Brown-out Detector 2.5 V function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Brown-out Detector 2.5 V function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">BOD17_RST_EN   </td><td class="markdownTableBodyLeft">BOD 1.7 V Reset Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a protected register. Please refer to open lock sequence to program it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Reset does not issue when BOD17 occurs.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Reset issues when BOD17 occurs.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The default value is set by flash controller user configuration register config0 bit[20:19]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">BOD20_RST_EN   </td><td class="markdownTableBodyLeft">BOD 2.0 V Reset Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a protected register. Please refer to open lock sequence to program it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Reset does not issue when BOD20 occurs.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Reset issues when BOD20 occurs.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The default value is set by flash controller user configuration register config0 bit[20:19]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">BOD25_RST_EN   </td><td class="markdownTableBodyLeft">BOD 2.5 V Reset Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a protected register. Please refer to open lock sequence to program it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Reset does not issue when BOD25 occurs.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Reset issues when BOD25 occurs.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The default value is set by flash controller user configuration register config0 bit[20:19]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">BOD17_INT_EN   </td><td class="markdownTableBodyLeft">BOD 1.7 V Interrupt Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a protected register. Please refer to open lock sequence to program it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Interrupt does not issue when BOD17 occurs.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Interrupt issues when BOD17 occurs.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">BOD20_INT_EN   </td><td class="markdownTableBodyLeft">BOD 2.0 V Interrupt Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Interrupt does not issue when BOD20 occurs.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Interrupt issues when BOD20 occurs.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[10]   </td><td class="markdownTableBodyCenter">BOD25_INT_EN   </td><td class="markdownTableBodyLeft">BOD 2.5 V Interrupt Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a protected register. Please refer to open lock sequence to program it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Interrupt does not issue when BOD25 occurs.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Interrupt issues when BOD25 occurs.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:12]   </td><td class="markdownTableBodyCenter">BOD17_TRIM   </td><td class="markdownTableBodyLeft">BOD 1.7 TRIM Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a protected register. Please refer to open lock sequence to program it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This value is used to control BOD17 detect voltage level, nominal 1.7 V.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Higher trim value, higher detection voltage.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[19:16]   </td><td class="markdownTableBodyCenter">BOD20_TRIM   </td><td class="markdownTableBodyLeft">BOD 2.0 TRIM Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a protected register. Please refer to open lock sequence to program it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This value is used to control BOD20 detect voltage level, nominal 2.0 V.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Higher trim value, higher detection voltage.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23:20]   </td><td class="markdownTableBodyCenter">BOD25_TRIM   </td><td class="markdownTableBodyLeft">BOD 2.5 TRIM Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a protected register. Please refer to open lock sequence to program it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This value is used to control BOD25 detect voltage level, nominal 2.5 V.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Higher trim value, higher detection voltage.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l03406">3406</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga0bae1177bf10fd15b6c8b7d02fce568b" name="ga0bae1177bf10fd15b6c8b7d02fce568b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bae1177bf10fd15b6c8b7d02fce568b">&#9670;&nbsp;</a></span>BODSTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SYS_T::BODSTS</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md162"></a>
BODSTS</h1>
<h2><a class="anchor" id="autotoc_md163"></a>
Offset: 0x68  Brown-out Detector Status Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">BOD_INT   </td><td class="markdownTableBodyLeft">Brown-Out Detector Interrupt Status    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Brown-out Detector does not detect any voltage drift at VDD down through or up through the target detected voltage after interrupt is enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = When Brown-out Detector detects the VDD is dropped down through the target detected voltage or the VDD is raised up through the target detected voltage and Brown-out interrupt is enabled, this bit will be set to 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is cleared by writing 1 to it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">BOD17_drop   </td><td class="markdownTableBodyLeft">Brown-Out Detector Lower Than 1.7V Status    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Setting BOD17_drop high means once the detected voltage is lower than target detected voltage setting (1.7V).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Software can write 1 to clear BOD17_drop.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">BOD20_drop   </td><td class="markdownTableBodyLeft">Brown-Out Detector Lower Than 2.0V Status    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Setting BOD20_drop high means once the detected voltage is lower than target detected voltage setting (2.0V).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Software can write 1 to clear BOD20_drop.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">BOD25_drop   </td><td class="markdownTableBodyLeft">Brown-Out Detector Lower Than 2.5V Status    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Setting BOD25_drop high means once the detected voltage is lower than target detected voltage setting (2.5V).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Software can write 1 to clear BOD25_drop.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">BOD17_rise   </td><td class="markdownTableBodyLeft">Brown-Out Detector Higher Than 1.7V Status    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Setting BOD17_rise high means once the detected voltage is higher than target detected voltage setting (1.7V).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Software can write 1 to clear BOD17_rise.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">BOD20_rise   </td><td class="markdownTableBodyLeft">Brown-Out Detector Higher Than 2.0V Status    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Setting BOD20_rise high means once the detected voltage is higher than target detected voltage setting (2.0V).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Software can write 1 to clear BOD20_rise.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">BOD25_rise   </td><td class="markdownTableBodyLeft">Brown-Out Detector Higher Than 2.5V Status    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Setting BOD25_rise high means once the detected voltage is higher than target detected voltage setting (2.5V).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Software can write 1 to clear BOD25_rise.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">BOD17   </td><td class="markdownTableBodyLeft">Brown-Out Detector 1.7V Status    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit reflects the BOD17 status.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">BOD17 is high if detected voltage is higher than 1.7 V.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">BOD17 is low if detected voltage is lower than 1.7 V.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is ready-only.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">BOD20   </td><td class="markdownTableBodyLeft">Brown-Out Detector 2.0V Status    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit reflects the BOD20 status.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">BOD20 is high if detected voltage is higher than 2.0 V.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">BOD20 is low if detected voltage is lower than 2.0 V.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is ready-only.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[10]   </td><td class="markdownTableBodyCenter">BOD25   </td><td class="markdownTableBodyLeft">Brown-Out Detector 2.5V Status    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit reflects the BOD25 status.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">BOD25 is high if detected voltage is higher than 2.5 V.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">BOD25 is low if detected voltage is lower than 2.5 V.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is ready-only.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l03453">3453</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga710545f9c9f66efe5c4426dae5acab78" name="ga710545f9c9f66efe5c4426dae5acab78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga710545f9c9f66efe5c4426dae5acab78">&#9670;&nbsp;</a></span>BR_COMP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t UART_T::BR_COMP</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md432"></a>
BR_COMP</h1>
<h2><a class="anchor" id="autotoc_md433"></a>
Offset: 0x3C  UART Baud Rate Compensation</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[8:0]   </td><td class="markdownTableBodyCenter">BR_COMP   </td><td class="markdownTableBodyLeft">Baud Rate Compensation Patten    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">These 9-bits are used to define the relative bit is compensated or not.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">BR_COMP[7:0] is used to define the compensation of UART data[7:0] and BR_COM[8] is used to define the parity bit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[31]   </td><td class="markdownTableBodyCenter">BR_COMP_DEC   </td><td class="markdownTableBodyLeft">Baud Rate Compensation Decrease    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Positive (increase one module clock) compensation for each compensated bit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Negative (decrease one module clock) compensation for each compensated bit.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10031">10031</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga060402df18d1f63be3a0c429402c7764" name="ga060402df18d1f63be3a0c429402c7764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga060402df18d1f63be3a0c429402c7764">&#9670;&nbsp;</a></span>CALCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t ADC_T::CALCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md24"></a>
CALCTL</h1>
<h2><a class="anchor" id="autotoc_md25"></a>
Offset: 0x68  ADC Calibration  Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">CALEN   </td><td class="markdownTableBodyLeft">Calibration Function Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Enable this bit to turn on the calibration function block.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">CALSTART   </td><td class="markdownTableBodyLeft">Calibration Functional Block Start    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Stops calibration functional block.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Starts calibration functional block.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is set by SW and clear by HW; don't write 1 to this bit while CALEN = 0.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">CALDONE   </td><td class="markdownTableBodyLeft">Calibrate Functional Block Complete    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Not yet.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Selected functional block complete.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">CALSEL   </td><td class="markdownTableBodyLeft">Select Calibration Functional Block    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Load calibration functional block.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Calibration functional block.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l00695">695</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaaf08c7acec8b147ea37c5bc0dd64ae6c" name="gaaf08c7acec8b147ea37c5bc0dd64ae6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf08c7acec8b147ea37c5bc0dd64ae6c">&#9670;&nbsp;</a></span>CALWORD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t ADC_T::CALWORD</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md26"></a>
CALWORD</h1>
<h2><a class="anchor" id="autotoc_md27"></a>
Offset: 0x6C  A/D calibration  load word register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6:0]   </td><td class="markdownTableBodyCenter">CALWORD   </td><td class="markdownTableBodyLeft">Calibration Word Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Write to this register with the previous calibration word before load calibration action    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Read this register after calibration done    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: The calibration block contains two parts "CALIBRATION" and "LOAD CALIBRATION"; if the calibration block is config as "CALIBRATION"; then this register represent the result of calibration when calibration is completed; if config as "LOAD CALIBRATION" ; config this register before loading calibration action, after loading calibration complete, the loaded calibration word will apply to the ADC;while in loading calibration function the loaded value will not be equal to the original CALWORD until calibration is done.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l00709">709</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gadd90a09a831b62d48dd09b92395997cb" name="gadd90a09a831b62d48dd09b92395997cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd90a09a831b62d48dd09b92395997cb">&#9670;&nbsp;</a></span>CAPCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::CAPCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md276"></a>
CAPCTL</h1>
<h2><a class="anchor" id="autotoc_md277"></a>
Offset: 0x54  Capture Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">INV0   </td><td class="markdownTableBodyLeft">Channel 0 Inverter ON/OFF    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Inverter OFF.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">CAPCH0EN   </td><td class="markdownTableBodyLeft">Capture Channel 0 Transition Enable/Disable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Capture function on channel 0 Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Capture function on channel 0 Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When Enabled, Capture latched the PWM-timer value and saved to CRL0 (PWM_CRL0[15:0]) for rising latch and CFL0 (PWM_CFL0[15:0]) for falling latch.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When Disabled, Capture does not update CRL0 (PWM_CRL0[15:0]) and CFL0 (PWM_CFL0[15:0]), and disable Channel 0 Interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">CAPCH0PADEN   </td><td class="markdownTableBodyLeft">Capture Input Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disable the channel 0 input capture signal from corresponding multi-function pin.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enable the channel 0 input capture signal from corresponding multi-function pin.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">CH0PDMAEN   </td><td class="markdownTableBodyLeft">Channel 0 PDMA Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Channel 0 PDMA function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Channel 0 PDMA function Enabled for the channel 0 captured data and transfer to memory.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:4]   </td><td class="markdownTableBodyCenter">PDMACAPMOD0   </td><td class="markdownTableBodyLeft">Select CRL0 Or CFL0 For PDMA Transfer    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = CRL0 will be transmitted.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = CFL0 will be transmitted.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Both CRL0 and CFL0 will be transmitted.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">CAPRELOADREN0   </td><td class="markdownTableBodyLeft">Reload CNR0 When CH0 Capture Rising Event Comes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Rising capture reload for CH0 Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Rising capture reload for CH0 Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">CAPRELOADFEN0   </td><td class="markdownTableBodyLeft">Reload CNR0 When CH0 Capture Falling Event Comes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Falling capture reload for CH0 Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Falling capture reload for CH0 Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">INV1   </td><td class="markdownTableBodyLeft">Channel 1 Inverter ON/OFF    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Inverter OFF.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">CAPCH1EN   </td><td class="markdownTableBodyLeft">Capture Channel 1 Transition Enable/Disable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Capture function on channel 1 Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Capture function on channel 1 Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When Enabled, Capture latched the PMW-counter and saved to CRL1 (PWM_CRL1[15:0]) for rising latch and CFL1 (PWM_CFL1[15:0]) for falling latch.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When Disabled, Capture does not update CRL1 (PWM_CRL1[15:0]) and CFL1 (PWM_CFL1[15:0]), and disable Channel 1 Interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[10]   </td><td class="markdownTableBodyCenter">CAPCH1PADEN   </td><td class="markdownTableBodyLeft">Capture Input Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disable the channel 1 input capture signal from corresponding multi-function pin.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enable the channel 1 input capture signal from corresponding multi-function pin.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[12]   </td><td class="markdownTableBodyCenter">CH0RFORDER   </td><td class="markdownTableBodyLeft">Channel 0 capture order control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set this bit to determine whether the PWM_CRL0 or PWM_CFL0 is the first captured data transferred to memory through PDMA when PDMACAPMOD0 =2'b11.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM_CFL0 is the first captured data to memory.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM_CRL0 is the first captured data to memory.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[13]   </td><td class="markdownTableBodyCenter">CH01CASK   </td><td class="markdownTableBodyLeft">Cascade channel 0 and channel 1 PWM timer for capturing usage    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[14]   </td><td class="markdownTableBodyCenter">CAPRELOADREN1   </td><td class="markdownTableBodyLeft">Reload CNR1 When CH1 Capture Rising Event Comes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Rising capture reload for CH1 Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Rising capture reload for CH1 Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15]   </td><td class="markdownTableBodyCenter">CAPRELOADFEN1   </td><td class="markdownTableBodyLeft">Reload CNR1 When CH1 Capture Falling Event Coming    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Capture falling reload for CH1 Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Capture falling reload for CH1 Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">INV2   </td><td class="markdownTableBodyLeft">Channel 2 Inverter ON/OFF    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Inverter OFF.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[17]   </td><td class="markdownTableBodyCenter">CAPCH2EN   </td><td class="markdownTableBodyLeft">Capture Channel 2 Transition Enable/Disable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Capture function on channel 2 Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Capture function on channel 2 Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When Enabled, Capture latched the PWM-timer value and saved to CRL2 (PWM_CRL2[15:0]) for rising latch and CFL2 (PWM_CFL2[15:0]) for falling latch.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When Disabled, Capture does not update CRL2 (PWM_CRL2[15:0]) and CFL2 (PWM_CFL2[15:0]), and disable Channel 2 Interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[18]   </td><td class="markdownTableBodyCenter">CAPCH2PADEN   </td><td class="markdownTableBodyLeft">Capture Input Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disable the channel 2 input capture signal from corresponding multi-function pin.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enable the channel 2 input capture signal from corresponding multi-function pin.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[19]   </td><td class="markdownTableBodyCenter">CH2PDMAEN   </td><td class="markdownTableBodyLeft">Channel 2 PDMA Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Channel 2 PDMA function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Channel 2 PDMA function Enabled for the channel 2 captured data and transfer to memory.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[21:20]   </td><td class="markdownTableBodyCenter">PDMACAPMOD2   </td><td class="markdownTableBodyLeft">Select CRL2 Or CFL2 For PDMA Transfer    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = CRL2 will be transmitted.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = CFL2 will be transmitted.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Both CRL2 and CFL2 will be transmitted.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[22]   </td><td class="markdownTableBodyCenter">CAPRELOADREN2   </td><td class="markdownTableBodyLeft">Reload CNR2 When CH2 Capture Rising Event Coming    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Rising capture reload for CH2 Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Rising capture reload for CH2 Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[23]   </td><td class="markdownTableBodyCenter">CAPRELOADFEN2   </td><td class="markdownTableBodyLeft">Reload CNR2 When CH2 Capture Failing Event Coming    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Failing capture reload for CH2 Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Failing capture reload for CH2 Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[24]   </td><td class="markdownTableBodyCenter">INV3   </td><td class="markdownTableBodyLeft">Channel 3 Inverter ON/OFF    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Inverter OFF.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[25]   </td><td class="markdownTableBodyCenter">CAPCH3EN   </td><td class="markdownTableBodyLeft">Capture Channel 3 Transition Enable/Disable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Capture function on channel 3 Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Capture function on channel 3 Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When Enabled, Capture latched the PMW-timer and saved to CRL3 (PWM_CRL3[15:0]) for rising latch and CFL3 (PWM_CFL3[15:0]) for falling latch.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When Disabled, Capture does not update CRL3 (PWM_CRL3[15:0]) and CFL3 (PWM_CFL3[15:0]), and disable Channel 3 Interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[26]   </td><td class="markdownTableBodyCenter">CAPCH3PADEN   </td><td class="markdownTableBodyLeft">Capture Input Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disable the channel 3 input capture signal from corresponding multi-function pin.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enable the channel 3 input capture signal from corresponding multi-function pin.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[28]   </td><td class="markdownTableBodyCenter">CH2RFORDER   </td><td class="markdownTableBodyLeft">Channel 2 capture order control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set this bit to determine whether the PWM_CRL2 or PWM_CFL2 is the first captured data transferred to memory through PDMA when PDMACAPMOD2 = 2'b11.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM_CFL2 is the first captured data to memory.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM_CRL2 is the first captured data to memory.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[29]   </td><td class="markdownTableBodyCenter">CH23CASK   </td><td class="markdownTableBodyLeft">Cascade channel 2 and channel 3 PWM counter for capturing usage    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[30]   </td><td class="markdownTableBodyCenter">CAPRELOADREN3   </td><td class="markdownTableBodyLeft">Reload CNR3 When CH3 Rising Capture Event Comes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Rising capture reload for CH3 Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Rising capture reload for CH3 Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[31]   </td><td class="markdownTableBodyCenter">CAPRELOADFEN3   </td><td class="markdownTableBodyLeft">Reload CNR3 When CH3 Falling Capture Event Comes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Falling capture reload for CH3 Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Falling capture reload for CH3 Enabled.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l06296">6296</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga60536c86136f09a69087306a65b6f9f4" name="ga60536c86136f09a69087306a65b6f9f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60536c86136f09a69087306a65b6f9f4">&#9670;&nbsp;</a></span>CAPINTEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::CAPINTEN</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md278"></a>
CAPINTEN</h1>
<h2><a class="anchor" id="autotoc_md279"></a>
Offset: 0x58  Capture interrupt enable Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">CRL_IE0   </td><td class="markdownTableBodyLeft">Channel 0 Rising Latch Interrupt Enable ON/OFF    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Rising latch interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Rising latch interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When Enabled, if Capture detects Channel 0 has rising transition, Capture issues an Interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">CFL_IE0   </td><td class="markdownTableBodyLeft">Channel 0 Falling Latch Interrupt Enable ON/OFF    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Falling latch interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Falling latch interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When Enabled, if Capture detects Channel 0 has falling transition, Capture issues an Interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">CRL_IE1   </td><td class="markdownTableBodyLeft">Channel 1 Rising Latch Interrupt Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Rising latch interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Rising latch interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When Enabled, if Capture detects Channel 1 has rising transition, Capture issues an Interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">CFL_IE1   </td><td class="markdownTableBodyLeft">Channel 1 Falling Latch Interrupt Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Falling latch interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Falling latch interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When Enabled, if Capture detects Channel 1 has falling transition, Capture issues an Interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">CRL_IE2   </td><td class="markdownTableBodyLeft">Channel 2 Rising Latch Interrupt Enable ON/OFF    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Rising latch interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Rising latch interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When Enabled, if Capture detects Channel 2 has rising transition, Capture issues an Interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[17]   </td><td class="markdownTableBodyCenter">CFL_IE2   </td><td class="markdownTableBodyLeft">Channel 2 Falling Latch Interrupt Enable ON/OFF    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Falling latch interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Falling latch interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When Enabled, if Capture detects Channel 2 has falling transition, Capture issues an Interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[24]   </td><td class="markdownTableBodyCenter">CRL_IE3   </td><td class="markdownTableBodyLeft">Channel 3 Rising Latch Interrupt Enable ON/OFF    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Rising latch interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Rising latch interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When Enabled, if Capture detects Channel 3 has rising transition, Capture issues an Interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[25]   </td><td class="markdownTableBodyCenter">CFL_IE3   </td><td class="markdownTableBodyLeft">Channel 3 Falling Latch Interrupt Enable ON/OFF    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Falling latch interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Falling latch interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When Enabled, if Capture detects Channel 3 has falling transition, Capture issues an Interrupt.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l06338">6338</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga0c11ac4d6481b29e81e38f6288f7d3dc" name="ga0c11ac4d6481b29e81e38f6288f7d3dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c11ac4d6481b29e81e38f6288f7d3dc">&#9670;&nbsp;</a></span>CAPINTSTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::CAPINTSTS</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md280"></a>
CAPINTSTS</h1>
<h2><a class="anchor" id="autotoc_md281"></a>
Offset: 0x5C  Capture Interrupt Indication Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">CAPIF0   </td><td class="markdownTableBodyLeft">Capture0 Interrupt Indication Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If channel 0 rising latch interrupt (CRL_IE0, PWM_CAPINTEN[0]) is enabled, a rising transition occurs at input channel 0 will result in CAPIF0 to high; Similarly, a falling transition will cause CAPIF0 to be set high if channel 0 falling latch interrupt (CFL_IE0, PWM_CAPINTEN[1]) is enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This flag is cleared by software with a write 1 on it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">CRLI0   </td><td class="markdownTableBodyLeft">PWM_CRL0 Latched Indicator Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When input channel 0 has a rising transition, PWM0_CRL0 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing 1 to it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">CFLI0   </td><td class="markdownTableBodyLeft">PWM_CFL0 Latched Indicator Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When input channel 0 has a falling transition, PWM0_CFL0 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing 1 to it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">CAPOVR0   </td><td class="markdownTableBodyLeft">Capture Rising Flag Over Run For Channel 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This flag indicate CRL0 update faster than software reading it when it is set    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit will be cleared automatically when user clears CRLI0 (PWM_CAPINTSTS[1]).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">CAPOVF0   </td><td class="markdownTableBodyLeft">Capture Falling Flag Over Run For Channel 0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This flag indicate CFL0 update faster than software read it when it is set    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit will be cleared automatically when user clear CFLI0 (PWM_CAPINTSTS[2])    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">CAPIF1   </td><td class="markdownTableBodyLeft">Capture1 Interrupt Indication Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If channel 1 rising latch interrupt (CRL_IE1, PWM_CAPINTEN[8]) is enabled, a rising transition occurs at input channel 1 will result in CAPIF1 to high; Similarly, a falling transition will cause CAPIF1 to be set high if channel 1 falling latch interrupt (CFL_IE1, PWM_CAPINTEN[9]) is enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This flag is cleared by software with a write 1 on it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">CRLI1   </td><td class="markdownTableBodyLeft">PWM_CRL1 Latched Indicator Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When input channel 1 has a rising transition, PWM_CRL1 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing 1 to it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[10]   </td><td class="markdownTableBodyCenter">CFLI1   </td><td class="markdownTableBodyLeft">PWM_CFL1 Latched Indicator Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When input channel 1 has a falling transition, PWM_CFL1 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing 1 to it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[11]   </td><td class="markdownTableBodyCenter">CAPOVR1   </td><td class="markdownTableBodyLeft">Capture Rising Flag Over Run For Channel 1    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This flag indicate CRL1 update faster than software reading it when it is set    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit will be cleared automatically when user clear CRLI1 (PWM_CAPINTSTS[9])    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[12]   </td><td class="markdownTableBodyCenter">CAPOVF1   </td><td class="markdownTableBodyLeft">Capture Falling Flag Over Run For Channel 1    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This flag indicate CFL1 update faster than software reading it when it is set    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit will be cleared automatically when user clear CFLI1 (PWM_CAPINTSTS[10])    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">CAPIF2   </td><td class="markdownTableBodyLeft">Capture2 Interrupt Indication Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If channel 2 rising latch interrupt (CRL_IE2, PWM_CAPINTEN[16]) is enabled, a rising transition occurs at input channel 2 will result in CAPIF2 to high; Similarly, a falling transition will cause CAPIF2 to be set high if channel 2 falling latch interrupt (CFL_IE2, PWM_CAPINTEN[17]) is enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This flag is cleared by software with a write 1 on it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[17]   </td><td class="markdownTableBodyCenter">CRLI2   </td><td class="markdownTableBodyLeft">PWM_CRL2 Latched Indicator Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When input channel 2 has a rising transition, PWM0_CRL2 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing 1 to it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[18]   </td><td class="markdownTableBodyCenter">CFLI2   </td><td class="markdownTableBodyLeft">PWM_CFL2 Latched Indicator Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When input channel 2 has a falling transition, PWM0_CFL2 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing 1 to it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[19]   </td><td class="markdownTableBodyCenter">CAPOVR2   </td><td class="markdownTableBodyLeft">Capture Rising Flag Over Run For Channel 2    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This flag indicate CRL2 update faster than software reading it when it is set    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit will be cleared automatically when user clear CRLI2 (PWM_CAPINTSTS[17])    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[20]   </td><td class="markdownTableBodyCenter">CAPOVF2   </td><td class="markdownTableBodyLeft">Capture Falling Flag Over Run For Channel 2    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This flag indicate CFL2 update faster than software reading it when it is set    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit will be cleared automatically when user clear CFLI2 (PWM_CAPINTSTS[18])    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[24]   </td><td class="markdownTableBodyCenter">CAPIF3   </td><td class="markdownTableBodyLeft">Capture3 Interrupt Indication Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If channel 3 rising latch interrupt (CRL_IE3, PWM_CAPINTEN[24]) is enabled, a rising transition occurs at input channel 3 will result in CAPIF3 to high; Similarly, a falling transition will cause CAPIF3 to be set high if channel 3 falling latch interrupt (CFL_IE3, PWM_CAPINTEN[25]) is enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This flag is cleared by software with a write 1 on it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[25]   </td><td class="markdownTableBodyCenter">CRLI3   </td><td class="markdownTableBodyLeft">PWM_CRL3 Latched Indicator Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When input channel 3 has a rising transition, PWM_CRL3 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing 1 to it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[26]   </td><td class="markdownTableBodyCenter">CFLI3   </td><td class="markdownTableBodyLeft">PWM_CFL3 Latched Indicator Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When input channel 3 has a falling transition, PWM_CFL3 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing 1 to it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[27]   </td><td class="markdownTableBodyCenter">CAPOVR3   </td><td class="markdownTableBodyLeft">Capture Rising Flag Over Run For Channel 3    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This flag indicate CRL3update faster than software reading it when it is set    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit will be cleared automatically when user clear CRLI3 (PWM_CAPINTSTS[25])    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[28]   </td><td class="markdownTableBodyCenter">CAPOVF3   </td><td class="markdownTableBodyLeft">Capture Falling Flag Over Run For Channel 3    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This flag indicate CFL3 update faster than software reading it when it is set    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit will be cleared automatically when user clear CFLI3 (PWM_CAPINTSTS[26])   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l06400">6400</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga3d2d24398c805a164fbb1f4840652a35" name="ga3d2d24398c805a164fbb1f4840652a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d2d24398c805a164fbb1f4840652a35">&#9670;&nbsp;</a></span>CAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t RTC_T::CAR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md322"></a>
CAR</h1>
<h2><a class="anchor" id="autotoc_md323"></a>
Offset: 0x20  Calendar Alarm Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3:0]   </td><td class="markdownTableBodyCenter">1DAY   </td><td class="markdownTableBodyLeft">1 Day Calendar Digit of Alarm Setting (0~9)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5:4]   </td><td class="markdownTableBodyCenter">10DAY   </td><td class="markdownTableBodyLeft">10 Day Calendar Digit of Alarm Setting (0~3)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[11:8]   </td><td class="markdownTableBodyCenter">1MON   </td><td class="markdownTableBodyLeft">1 Month Calendar Digit of Alarm Setting (0~9)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[12]   </td><td class="markdownTableBodyCenter">10MON   </td><td class="markdownTableBodyLeft">10 Month Calendar Digit of Alarm Setting (0~1)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[19:16]   </td><td class="markdownTableBodyCenter">1YEAR   </td><td class="markdownTableBodyLeft">1 Year Calendar Digit of Alarm Setting (0~9)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[23:20]   </td><td class="markdownTableBodyCenter">10YEAR   </td><td class="markdownTableBodyLeft">10 Year Calendar Digit of Alarm Setting (0~9)   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l07216">7216</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga36ea5c8cb37f89bb4ba6dfd1ea44dca1" name="ga36ea5c8cb37f89bb4ba6dfd1ea44dca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36ea5c8cb37f89bb4ba6dfd1ea44dca1">&#9670;&nbsp;</a></span>CBCR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t PDMA_T::CBCR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md104"></a>
CBCR</h1>
<h2><a class="anchor" id="autotoc_md105"></a>
Offset: 0x1C  PDMA Current Transfer Byte Count Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23:0]   </td><td class="markdownTableBodyCenter">PDMA_CBCR   </td><td class="markdownTableBodyLeft">PDMA Current Byte Count Register (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field indicates the current remained byte count of PDMA.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: These fields will be changed when PDMA finish data transfer (data transfer to destination address),   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l02192">2192</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga71808ef5d48dfb05afba27eaacbc65c8" name="ga71808ef5d48dfb05afba27eaacbc65c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71808ef5d48dfb05afba27eaacbc65c8">&#9670;&nbsp;</a></span>CDAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t PDMA_T::CDAR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md102"></a>
CDAR</h1>
<h2><a class="anchor" id="autotoc_md103"></a>
Offset: 0x18  PDMA Current Destination Address Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]   </td><td class="markdownTableBodyCenter">PDMA_CDAR   </td><td class="markdownTableBodyLeft">PDMA Current Destination Address Register (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field indicates the destination address where the PDMA transfer is just occurring.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l02179">2179</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaa350009fd0f58831db2cf141cf5a81f2" name="gaa350009fd0f58831db2cf141cf5a81f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa350009fd0f58831db2cf141cf5a81f2">&#9670;&nbsp;</a></span>CFL0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t PWM_T::CFL0</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md284"></a>
CFL0</h1>
<h2><a class="anchor" id="autotoc_md285"></a>
Offset: 0x64  Capture Falling Latch Register (Channel 0)</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CFL   </td><td class="markdownTableBodyLeft">Capture Falling Latch Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Latch the PWM counter when Channel 0/1/2/3 has Falling transition.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CFL_H   </td><td class="markdownTableBodyLeft">Upper Half Word Of 32-Bit Capture Data When Cascade Enabled    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When cascade is enabled for capture channel 0, 2, the original 16 bit counter extend to 32 bit, and capture result CFL0 and CFL2 are also extend to 32 bit,   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l06428">6428</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gafa61f9f184253185fef38f0df2d1806f" name="gafa61f9f184253185fef38f0df2d1806f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa61f9f184253185fef38f0df2d1806f">&#9670;&nbsp;</a></span>CFL1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t PWM_T::CFL1</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md288"></a>
CFL1</h1>
<h2><a class="anchor" id="autotoc_md289"></a>
Offset: 0x6C  Capture Falling Latch Register (Channel 1)</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CFL   </td><td class="markdownTableBodyLeft">Capture Falling Latch Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Latch the PWM counter when Channel 0/1/2/3 has Falling transition.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CFL_H   </td><td class="markdownTableBodyLeft">Upper Half Word Of 32-Bit Capture Data When Cascade Enabled    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When cascade is enabled for capture channel 0, 2, the original 16 bit counter extend to 32 bit, and capture result CFL0 and CFL2 are also extend to 32 bit,   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l06456">6456</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga45f84dd5fd63d4b4f5365441cf7c4eb5" name="ga45f84dd5fd63d4b4f5365441cf7c4eb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45f84dd5fd63d4b4f5365441cf7c4eb5">&#9670;&nbsp;</a></span>CFL2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t PWM_T::CFL2</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md292"></a>
CFL2</h1>
<h2><a class="anchor" id="autotoc_md293"></a>
Offset: 0x74  Capture Falling Latch Register (Channel 2)</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CFL   </td><td class="markdownTableBodyLeft">Capture Falling Latch Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Latch the PWM counter when Channel 0/1/2/3 has Falling transition.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CFL_H   </td><td class="markdownTableBodyLeft">Upper Half Word Of 32-Bit Capture Data When Cascade Enabled    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When cascade is enabled for capture channel 0, 2, the original 16 bit counter extend to 32 bit, and capture result CFL0 and CFL2 are also extend to 32 bit,   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l06484">6484</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga45a7dcc8be3bef81caec04b1da0b0ca2" name="ga45a7dcc8be3bef81caec04b1da0b0ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45a7dcc8be3bef81caec04b1da0b0ca2">&#9670;&nbsp;</a></span>CFL3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t PWM_T::CFL3</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md296"></a>
CFL3</h1>
<h2><a class="anchor" id="autotoc_md297"></a>
Offset: 0x7C  Capture Falling Latch Register (Channel 3)</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CFL   </td><td class="markdownTableBodyLeft">Capture Falling Latch Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Latch the PWM counter when Channel 0/1/2/3 has Falling transition.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CFL_H   </td><td class="markdownTableBodyLeft">Upper Half Word Of 32-Bit Capture Data When Cascade Enabled    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When cascade is enabled for capture channel 0, 2, the original 16 bit counter extend to 32 bit, and capture result CFL0 and CFL2 are also extend to 32 bit,   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l06512">6512</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gab507dbddc46ba55a5cc05b3de901e132" name="gab507dbddc46ba55a5cc05b3de901e132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab507dbddc46ba55a5cc05b3de901e132">&#9670;&nbsp;</a></span>CHECKSUM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t DMA_CRC_T::CHECKSUM</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md82"></a>
CHECKSUM</h1>
<h2><a class="anchor" id="autotoc_md83"></a>
Offset: 0x88  DMA CRC Check Sum Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]   </td><td class="markdownTableBodyCenter">CRC_CHECKSUM   </td><td class="markdownTableBodyLeft">CRC Checksum Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field indicates the CRC checksum   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l01912">1912</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga8a552a9d8396e7a1a9c405359018a349" name="ga8a552a9d8396e7a1a9c405359018a349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a552a9d8396e7a1a9c405359018a349">&#9670;&nbsp;</a></span>CHEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t ADC_T::CHEN</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md12"></a>
CHEN</h1>
<h2><a class="anchor" id="autotoc_md13"></a>
Offset: 0x4C  A/D Channel Enable Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">CHEN0   </td><td class="markdownTableBodyLeft">Analog Input Channel 0 Enable Control (Convert Input Voltage From PA.0 )    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If more than one channel in single mode is enabled by software, the least channel is converted and other enabled channels will be ignored.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">CHEN1   </td><td class="markdownTableBodyLeft">Analog Input Channel 1 Enable Control (Convert Input Voltage From PA.1 )    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">CHEN2   </td><td class="markdownTableBodyLeft">Analog Input Channel 2 Enable Control (Convert Input Voltage From PA.2 )    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">CHEN3   </td><td class="markdownTableBodyLeft">Analog Input Channel 3 Enable Control (Convert Input Voltage From PA.3 )    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">CHEN4   </td><td class="markdownTableBodyLeft">Analog Input Channel 4 Enable Control (Convert Input Voltage From PA.4 )    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">CHEN5   </td><td class="markdownTableBodyLeft">Analog Input Channel 5 Enable Control (Convert Input Voltage From PA.5 )    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">CHEN6   </td><td class="markdownTableBodyLeft">Analog Input Channel 6 Enable Control (Convert Input Voltage From PA.6 )    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">CHEN7   </td><td class="markdownTableBodyLeft">Analog Input Channel 7 Enable Control (Convert Input Voltage From PA.7 )    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[14]   </td><td class="markdownTableBodyCenter">CHEN14   </td><td class="markdownTableBodyLeft">Analog Input Channel 14 Enable Control (Convert VTEMP)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15]   </td><td class="markdownTableBodyCenter">CHEN15   </td><td class="markdownTableBodyLeft">Analog Input Channel 15 Enable Control (Convert Int_VREF)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">CHEN16   </td><td class="markdownTableBodyLeft">Analog Input Channel 16 Enable Control (Convert AVDD)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[17]   </td><td class="markdownTableBodyCenter">CHEN17   </td><td class="markdownTableBodyLeft">Analog Input Channel 17 Enable Control (Convert AVSS)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l00529">529</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga6ea1e761f8c180884bc051c73db22e13" name="ga6ea1e761f8c180884bc051c73db22e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ea1e761f8c180884bc051c73db22e13">&#9670;&nbsp;</a></span>CLKDIV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SPI_T::CLKDIV</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md374"></a>
CLKDIV</h1>
<h2><a class="anchor" id="autotoc_md375"></a>
Offset: 0x08  SPI Clock Divider Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]   </td><td class="markdownTableBodyCenter">DIVIDER1   </td><td class="markdownTableBodyLeft">Clock Divider 1    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The value is the 1th frequency divider of the PCLK to generate the serial clock of SPI_SCLK.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The desired frequency is obtained according to the following equation: fsclk = feclk / (DIVIDER1 + 1)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Where feclk is the SPI peripheral clock source.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It is defined in the CLK_SEL2[21:20] in Clock control section (CLK_BA + 0x18).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[23:16]   </td><td class="markdownTableBodyCenter">DIVIDER2   </td><td class="markdownTableBodyLeft">Clock Divider 2    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The value is the 2nd frequency divider of the PCLK to generate the serial clock of SPI_SCLK.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The desired frequency is obtained according to the following equation: fsclk = feclk / (DIVIDER2 + 1)   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l08625">8625</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaecdde8616f159af8c864c8c111e52414" name="gaecdde8616f159af8c864c8c111e52414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecdde8616f159af8c864c8c111e52414">&#9670;&nbsp;</a></span>CLKDIV0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t CLK_T::CLKDIV0</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md46"></a>
CLKDIV0</h1>
<h2><a class="anchor" id="autotoc_md47"></a>
Offset: 0x1C  Clock Divider Number Register 0</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3:0]   </td><td class="markdownTableBodyCenter">HCLK_N   </td><td class="markdownTableBodyLeft">HCLK Clock Divide Number From HCLK Clock Source    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The HCLK clock frequency = (HCLK Clock Source frequency) / (HCLK_N + 1).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[11:8]   </td><td class="markdownTableBodyCenter">UART_N   </td><td class="markdownTableBodyLeft">UART Clock Divide Number From UART Clock Source    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The UART clock frequency = (UART Clock Source frequency ) / (UART_N + 1).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23:16]   </td><td class="markdownTableBodyCenter">ADC_N   </td><td class="markdownTableBodyLeft">ADC Clock Divide Number From ADC Clock Source    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The ADC clock frequency = (ADC Clock Source frequency ) / (ADC_N + 1).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:28]   </td><td class="markdownTableBodyCenter">SC0_N   </td><td class="markdownTableBodyLeft">SC 0 Clock Divide Number From SC 0 Clock Source    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The SC 0 clock frequency = (SC0 Clock Source frequency ) / (SC0_N + 1).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l01247">1247</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga16bc8804dd7c329491e87a4c24dfd86c" name="ga16bc8804dd7c329491e87a4c24dfd86c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16bc8804dd7c329491e87a4c24dfd86c">&#9670;&nbsp;</a></span>CLKDIV1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t CLK_T::CLKDIV1</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md48"></a>
CLKDIV1</h1>
<h2><a class="anchor" id="autotoc_md49"></a>
Offset: 0x20  Clock Divider Number Register 1</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3:0]   </td><td class="markdownTableBodyCenter">SC1_N   </td><td class="markdownTableBodyLeft">SC 1 Clock Divide Number From SC 1 Clock Source    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The SC 1 clock frequency = (SC 1 Clock Source frequency ) / (SC1_N + 1).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[11:8]   </td><td class="markdownTableBodyCenter">TMR0_N   </td><td class="markdownTableBodyLeft">Timer0 Clock Divide Number From Timer0 Clock Source    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The Timer0 clock frequency = (Timer0 Clock Source frequency ) / (TMR0_N + 1).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:12]   </td><td class="markdownTableBodyCenter">TMR1_N   </td><td class="markdownTableBodyLeft">Timer1 Clock Divide Number From Timer1 Clock Source    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The Timer1 clock frequency = (Timer1 Clock Source frequency ) / (TMR1_N + 1).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[19:16]   </td><td class="markdownTableBodyCenter">TMR2_N   </td><td class="markdownTableBodyLeft">Timer2 Clock Divide Number From Timer2 Clock Source    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The Timer2 clock frequency = (Timer2 Clock Source frequency ) / (TMR2_N + 1).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23:20]   </td><td class="markdownTableBodyCenter">TMR3_N   </td><td class="markdownTableBodyLeft">Timer3 Clock Divide Number From Timer3 Clock Source    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The Timer3 clock frequency = (Timer3 Clock Source frequency ) / (TMR3_N + 1).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l01267">1267</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga575284c06ad67e614037859cf59f6993" name="ga575284c06ad67e614037859cf59f6993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga575284c06ad67e614037859cf59f6993">&#9670;&nbsp;</a></span>CLKSEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::CLKSEL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md250"></a>
CLKSEL</h1>
<h2><a class="anchor" id="autotoc_md251"></a>
Offset: 0x04  PWM Clock Select Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2:0]   </td><td class="markdownTableBodyCenter">CLKSEL0   </td><td class="markdownTableBodyLeft">Timer 0 Clock Source Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Select clock input for timer 0.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Table is the same as CLKSEL3)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[6:4]   </td><td class="markdownTableBodyCenter">CLKSEL1   </td><td class="markdownTableBodyLeft">Timer 1 Clock Source Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Select clock input for timer 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Table is the same as CLKSEL3)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[10:8]   </td><td class="markdownTableBodyCenter">CLKSEL2   </td><td class="markdownTableBodyLeft">Timer 2 Clock Source Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Select clock input for timer 2.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Table is the same as CLKSEL3)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[14:12]   </td><td class="markdownTableBodyCenter">CLKSEL3   </td><td class="markdownTableBodyLeft">Timer 3 Clock Source Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Select clock input for timer 3.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">000 = input clock is divided by 2.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">001 = input clock is divided by 4.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">010 = input clock is divided by 8.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">011 = input clock is divided by 16.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">100 = input clock is divided by 1.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l05784">5784</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gae5d0e2a48518b0d44641f594a763b619" name="gae5d0e2a48518b0d44641f594a763b619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5d0e2a48518b0d44641f594a763b619">&#9670;&nbsp;</a></span>CLKSEL0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t CLK_T::CLKSEL0</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md40"></a>
CLKSEL0</h1>
<h2><a class="anchor" id="autotoc_md41"></a>
Offset: 0x10  Clock Source Select Control Register 0</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2:0]   </td><td class="markdownTableBodyCenter">HCLK_S   </td><td class="markdownTableBodyLeft">HCLK Clock Source Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a protected register. Please refer to open lock sequence to program it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Before Clock Source switches, the related clock sources (pre-select and new-select) must be turn on    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The 3-bit default value is reloaded with the value of CFOSC (Config0[26:24]) in user configuration register in Flash controller by any reset.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Therefore the default value is either 000b or 111b.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">000 = HXT    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">001 = LXT    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">010 = PLL Clock    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">011 = LIRC    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">111 = HIRC    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others = Reserved   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l01134">1134</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga9cad9e775d46b22aad65c5caa3ba9cbf" name="ga9cad9e775d46b22aad65c5caa3ba9cbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cad9e775d46b22aad65c5caa3ba9cbf">&#9670;&nbsp;</a></span>CLKSEL1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t CLK_T::CLKSEL1</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md42"></a>
CLKSEL1</h1>
<h2><a class="anchor" id="autotoc_md43"></a>
Offset: 0x14  Clock Source Select Control Register 1</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1:0]   </td><td class="markdownTableBodyCenter">UART_S   </td><td class="markdownTableBodyLeft">UART 0/1 Clock Source Selection (UART0 And UART1 Use The Same Clock Source Selection)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = HXT    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = LXT    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = PLL Clock    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = HIRC    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5:4]   </td><td class="markdownTableBodyCenter">PWM0_CH01_S   </td><td class="markdownTableBodyLeft">PWM0 Channel 0 And Channel 1 Clock Source Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM0 channel 0 and channel 1 use the same Engine clock source, both of them with the same prescaler    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = HXT    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = LXT    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = HCLK    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = HIRC    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[7:6]   </td><td class="markdownTableBodyCenter">PWM0_CH23_S   </td><td class="markdownTableBodyLeft">PWM0 Channel 2 And Channel 3 Clock Source Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM0 channel 2 and channel 3 use the same Engine clock source, both of them with the same prescaler    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = HXT    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = LXT    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = HCLK    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = HIRC    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[10:8]   </td><td class="markdownTableBodyCenter">TMR0_S   </td><td class="markdownTableBodyLeft">Timer0 Clock Source Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">000 = HXT    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">001 = LXT    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">010 = LIRC    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">011 = External Pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">100 = HIRC    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others = HCLK    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[14:12]   </td><td class="markdownTableBodyCenter">TMR1_S   </td><td class="markdownTableBodyLeft">Timer1 Clock Source Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">000 = HXT    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">001 = LXT    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">010 = LIRC    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">011 = External Pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">100 = HIRC    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others = HCLK    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[18]   </td><td class="markdownTableBodyCenter">LCD_S   </td><td class="markdownTableBodyLeft">LCD Clock Source Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Clock Source from LXT.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[21:19]   </td><td class="markdownTableBodyCenter">ADC_S   </td><td class="markdownTableBodyLeft">ADC Clock Source Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">000 = HXT    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">001 = LXT    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">010 = PLL clock    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">011 = HIRC    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">others = HCLK   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l01184">1184</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga505ef1b8c8d11745b09418636c576b6f" name="ga505ef1b8c8d11745b09418636c576b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga505ef1b8c8d11745b09418636c576b6f">&#9670;&nbsp;</a></span>CLKSEL2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t CLK_T::CLKSEL2</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md44"></a>
CLKSEL2</h1>
<h2><a class="anchor" id="autotoc_md45"></a>
Offset: 0x18  Clock Source Select Control Register 2</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1:0]   </td><td class="markdownTableBodyCenter">FRQDIV1_S   </td><td class="markdownTableBodyLeft">Clock Divider Clock1 Source Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = HXT    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = LXT    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = HCLK    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = HIRC    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3:2]   </td><td class="markdownTableBodyCenter">FRQDIV0_S   </td><td class="markdownTableBodyLeft">Clock Divider0 Clock Source Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = HXT    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = LXT    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = HCLK    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = HIRC    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[10:8]   </td><td class="markdownTableBodyCenter">TMR2_S   </td><td class="markdownTableBodyLeft">Timer2 Clock Source Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">000 = HXT    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">001 = LXT    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">010 = LIRC    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">011 = External Pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">100 = HIRC    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others = HCLK    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[14:12]   </td><td class="markdownTableBodyCenter">TMR3_S   </td><td class="markdownTableBodyLeft">Timer3 Clock Source Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">000 = HXT    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">001 = LXT    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">010 = LIRC    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">011 = External Pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">100 = HIRC    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others = HCLK    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[19:18]   </td><td class="markdownTableBodyCenter">SC_S   </td><td class="markdownTableBodyLeft">SC Clock Source Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = HXT    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = PLL Clock    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = HIRC    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = HCLK    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[20]   </td><td class="markdownTableBodyCenter">SPI0_S   </td><td class="markdownTableBodyLeft">SPI0 Clock Source Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PLL.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = HCLK.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[21]   </td><td class="markdownTableBodyCenter">SPI1_S   </td><td class="markdownTableBodyLeft">SPI1 Clock Source Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PLL.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = HCLK.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l01229">1229</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga939046f1ff107551dfeedab4aca2c20d" name="ga939046f1ff107551dfeedab4aca2c20d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga939046f1ff107551dfeedab4aca2c20d">&#9670;&nbsp;</a></span>CLKSTATUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t CLK_T::CLKSTATUS</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md38"></a>
CLKSTATUS</h1>
<h2><a class="anchor" id="autotoc_md39"></a>
Offset: 0x0C  Clock status monitor Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">HXT_STB   </td><td class="markdownTableBodyLeft">HXT Clock Source Stable Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = HXT clock is not stable or not enable.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = HXT clock is stable.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">LXT_STB   </td><td class="markdownTableBodyLeft">LXT Clock Source Stable Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = LXT clock is not stable or not enable.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = LXT clock is stable.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">PLL_STB   </td><td class="markdownTableBodyLeft">PLL Clock Source Stable Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PLL clock is not stable or not enable.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PLL clock is stable.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">LIRC_STB   </td><td class="markdownTableBodyLeft">LIRC Clock Source Stable Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = LIRC clock is not stable or not enable.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = LIRC clock is stable.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">HIRC_STB   </td><td class="markdownTableBodyLeft">HIRC Clock Source Stable Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = HIRC clock is not stable or not enable.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = HIRC clock is stable.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">CLK_SW_FAIL   </td><td class="markdownTableBodyLeft">Clock Switch Fail Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Clock switch success.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Clock switch fail.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit will be set when target switch Clock Source is not stable. This bit is write 1 clear   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l01113">1113</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga8dc44efebe26ce6f4913a84a2513c9fe" name="ga8dc44efebe26ce6f4913a84a2513c9fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8dc44efebe26ce6f4913a84a2513c9fe">&#9670;&nbsp;</a></span>CLR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t RTC_T::CLR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md314"></a>
CLR</h1>
<h2><a class="anchor" id="autotoc_md315"></a>
Offset: 0x10  Calendar Loading Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3:0]   </td><td class="markdownTableBodyCenter">1DAY   </td><td class="markdownTableBodyLeft">1 Day Calendar Digit (0~9)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5:4]   </td><td class="markdownTableBodyCenter">10DAY   </td><td class="markdownTableBodyLeft">10 Day Calendar Digit (0~3)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[11:8]   </td><td class="markdownTableBodyCenter">1MON   </td><td class="markdownTableBodyLeft">1 Month Calendar Digit (0~9)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[12]   </td><td class="markdownTableBodyCenter">10MON   </td><td class="markdownTableBodyLeft">10 Month Calendar Digit (0~1)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[19:16]   </td><td class="markdownTableBodyCenter">1YEAR   </td><td class="markdownTableBodyLeft">1 Year Calendar Digit (0~9)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[23:20]   </td><td class="markdownTableBodyCenter">10YEAR   </td><td class="markdownTableBodyLeft">10 Year Calendar Digit (0~9)   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l07152">7152</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga91eb63011da0934d7d8edcfb58566417" name="ga91eb63011da0934d7d8edcfb58566417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91eb63011da0934d7d8edcfb58566417">&#9670;&nbsp;</a></span>CMPR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t TIMER_T::CMPR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md396"></a>
CMPR</h1>
<h2><a class="anchor" id="autotoc_md397"></a>
Offset: 0x08  Timer x Compare Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23:0]   </td><td class="markdownTableBodyCenter">TMR_CMP   </td><td class="markdownTableBodyLeft">Timer Compared Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">TMR_CMP is a 24-bit compared register.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the internal 24-bit up-counter counts and its value is equal to TMR_CMP value, a Timer Interrupt is requested if the timer interrupt is enabled with TMR_EN (TMRx_CTL [0]) is enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The TMR_CMP value defines the timer counting cycle time.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Time-out period = (Period of timer clock input) * (8-bit PRESCALE_CNT + 1) * (24-bit TMR_CMP).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: Never write 0x0 or 0x1 in TMR_CMP, or the core will run into unknown state.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: No matter TMR_EN (TMRx_CTL [0]) is 0 or 1, whenever software write a new value into this register, TIMER will restart counting using this new value and abort previous count.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l09208">9208</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga21ba1290b1f30db4da4280030ccdbcf5" name="ga21ba1290b1f30db4da4280030ccdbcf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21ba1290b1f30db4da4280030ccdbcf5">&#9670;&nbsp;</a></span>CMPR0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t ADC_T::CMPR0</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md14"></a>
CMPR0</h1>
<h2><a class="anchor" id="autotoc_md15"></a>
Offset: 0x50  A/D Compare Register 0</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">CMPEN   </td><td class="markdownTableBodyLeft">Compare Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Compare Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Compare Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set this bit to 1 to enable compare CMPD[11:0] with specified channel conversion result when converted data is loaded into ADC_RESULTx register.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When this bit is set to 1, and CMPMATCNT is 0, the CMPF will be set once the match is hit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">CMPIE   </td><td class="markdownTableBodyLeft">Compare Interrupt Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Compare function interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Compare function interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the compare function is enabled and the compare condition matches the setting of CMPCOND and CMPMATCNT, CMPF bit will be asserted, in the meanwhile, if CMPIE is set to 1, a compare interrupt request is generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">CMPCOND   </td><td class="markdownTableBodyLeft">Compare Condition    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Set the compare condition as that when a 12-bit A/D conversion result is less than the 12-bit CMPD (ADCMPRx[27:16]), the internal match counter will increase one.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Set the compare condition as that when a 12-bit A/D conversion result is greater or equal to the 12-bit CMPD (ADCMPRx[27:16]), the internal match counter will increase by one.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When the internal counter reaches the value to (CMPMATCNT +1), the CMPF bit will be set.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[7:3]   </td><td class="markdownTableBodyCenter">CMPCH   </td><td class="markdownTableBodyLeft">Compare Channel Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field selects the channel whose conversion result is selected to be compared.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[11:8]   </td><td class="markdownTableBodyCenter">CMPMATCNT   </td><td class="markdownTableBodyLeft">Compare Match Count    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the specified A/D channel analog conversion result matches the compare condition defined by CMPCOND[2], the internal match counter will increase 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the internal counter reaches the value to (CMPMATCNT +1), the CMPF bit will be set.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[27:16]   </td><td class="markdownTableBodyCenter">CMPD   </td><td class="markdownTableBodyLeft">Comparison Data    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The 12 bits data is used to compare with conversion result of specified channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Software can use it to monitor the external analog input pin voltage variation in scan mode without imposing a load on software.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l00560">560</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaecaf7bd402b9e48d435b3d55bcd1992f" name="gaecaf7bd402b9e48d435b3d55bcd1992f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecaf7bd402b9e48d435b3d55bcd1992f">&#9670;&nbsp;</a></span>CMPR1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t ADC_T::CMPR1</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md16"></a>
CMPR1</h1>
<h2><a class="anchor" id="autotoc_md17"></a>
Offset: 0x54  A/D Compare Register 1</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">CMPEN   </td><td class="markdownTableBodyLeft">Compare Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Compare Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Compare Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set this bit to 1 to enable compare CMPD[11:0] with specified channel conversion result when converted data is loaded into ADC_RESULTx register.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When this bit is set to 1, and CMPMATCNT is 0, the CMPF will be set once the match is hit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">CMPIE   </td><td class="markdownTableBodyLeft">Compare Interrupt Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Compare function interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Compare function interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the compare function is enabled and the compare condition matches the setting of CMPCOND and CMPMATCNT, CMPF bit will be asserted, in the meanwhile, if CMPIE is set to 1, a compare interrupt request is generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">CMPCOND   </td><td class="markdownTableBodyLeft">Compare Condition    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Set the compare condition as that when a 12-bit A/D conversion result is less than the 12-bit CMPD (ADCMPRx[27:16]), the internal match counter will increase one.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Set the compare condition as that when a 12-bit A/D conversion result is greater or equal to the 12-bit CMPD (ADCMPRx[27:16]), the internal match counter will increase by one.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When the internal counter reaches the value to (CMPMATCNT +1), the CMPF bit will be set.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[7:3]   </td><td class="markdownTableBodyCenter">CMPCH   </td><td class="markdownTableBodyLeft">Compare Channel Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field selects the channel whose conversion result is selected to be compared.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[11:8]   </td><td class="markdownTableBodyCenter">CMPMATCNT   </td><td class="markdownTableBodyLeft">Compare Match Count    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the specified A/D channel analog conversion result matches the compare condition defined by CMPCOND[2], the internal match counter will increase 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the internal counter reaches the value to (CMPMATCNT +1), the CMPF bit will be set.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[27:16]   </td><td class="markdownTableBodyCenter">CMPD   </td><td class="markdownTableBodyLeft">Comparison Data    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The 12 bits data is used to compare with conversion result of specified channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Software can use it to monitor the external analog input pin voltage variation in scan mode without imposing a load on software.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l00591">591</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga3a6b1cd30e7ad401b1dff3f181a0a6c4" name="ga3a6b1cd30e7ad401b1dff3f181a0a6c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a6b1cd30e7ad401b1dff3f181a0a6c4">&#9670;&nbsp;</a></span>CON</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t I2C_T::CON</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md198"></a>
CON</h1>
<h2><a class="anchor" id="autotoc_md199"></a>
Offset: 0x00  I2C Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">IPEN   </td><td class="markdownTableBodyLeft">I2C Function Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = I2C function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = I2C function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">ACK   </td><td class="markdownTableBodyLeft">Assert Acknowledge Control Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = When this bit is set to 0 prior to address or data received, a Not acknowledged (high level to SDA) will be returned during the acknowledge clock pulse.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = When this bit is set to 1 prior to address or data received, an acknowledged will be returned during the acknowledge clock pulse on the SCL line when:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(a): A slave is acknowledging the address sent from master.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(b): The receiver devices are acknowledging the data sent by transmitter.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">STOP   </td><td class="markdownTableBodyLeft">I2C STOP Control Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In Master mode, set this bit to 1 to transmit a STOP condition to bus then the controller will check the bus condition if a STOP condition is detected and this bit will be cleared by hardware automatically.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In Slave mode, set this bit to 1 to reset the controller to the defined "not addressed" Slave mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This means it is NO LONGER in the slave receiver mode to receive data from the master transmit device.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Will be cleared by hardware automatically if a STOP condition is detected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Sends a STOP condition to bus in Master mode or reset the controller to "not addressed" in Slave mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">START   </td><td class="markdownTableBodyLeft">I2C START Command    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Setting this bit to 1 to enter Master mode, the device sends a START or repeat START condition to bus when the bus is free and it will be cleared to 0 after the START command is active and the STATUS has been updated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = After START or repeat START is active.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Sends a START or repeat START condition to bus.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">I2C_STS   </td><td class="markdownTableBodyLeft">I2C Status    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When a new state is present in the I2CSTATUS register, if the INTEN bit is set, the I2C interrupt is requested.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It must write one by software to this bit after the I2CINTSTS[0] is set to 1 and the I2C protocol function will go ahead until the STOP is active or the IPEN is disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = I2C's Status disabled and the I2C protocol function will go ahead.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = I2C's Status active.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">INTEN   </td><td class="markdownTableBodyLeft">Interrupt Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = I2C interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = I2C interrupt Enabled.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l04928">4928</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga2dd0ebcfad612a3b1f86f6a70ba0c386" name="ga2dd0ebcfad612a3b1f86f6a70ba0c386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2dd0ebcfad612a3b1f86f6a70ba0c386">&#9670;&nbsp;</a></span>CON2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t I2C_T::CON2</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md218"></a>
CON2</h1>
<h2><a class="anchor" id="autotoc_md219"></a>
Offset: 0x40  I2C Control Register 2</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">WKUPEN   </td><td class="markdownTableBodyLeft">I2C Wake-Up Function Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = I2C wake-up function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = I2C wake-up function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">OVER_INTEN   </td><td class="markdownTableBodyLeft">I2C OVER RUN Interrupt Control Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Overrun event interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Send a interrupt to system when the TWOFF bit is enabled and there is over run event in received fifo.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">UNDER_INTEN   </td><td class="markdownTableBodyLeft">I2C UNDER RUN Interrupt Control Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Under run event interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Send a interrupt to system when the TWOFF bit is enabled and there is under run event happened in transmitted fifo.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">TWOFF_EN   </td><td class="markdownTableBodyLeft">TWO LEVEL FIFO Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">NOSTRETCH   </td><td class="markdownTableBodyLeft">NO STRETCH The I2C BUS    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The I2C SCL bus is stretched by hardware if the INTSTS (I2CINTSTS[0]) is not cleared in master mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The I2C SCL bus is not stretched by hardware if the INTSTS is not cleared in master mode.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l05093">5093</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaa8d835ee4132082a088bc7481e600ab7" name="gaa8d835ee4132082a088bc7481e600ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8d835ee4132082a088bc7481e600ab7">&#9670;&nbsp;</a></span>CR <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t ACMP_T::CR[2]</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md0"></a>
CR0/1</h1>
<h2><a class="anchor" id="autotoc_md1"></a>
Offset: 0x00,0x04  Analog Comparator 0/1 Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">ACMPEN   </td><td class="markdownTableBodyLeft">Comparator ACMP0/1 Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Comparator output needs to wait 10 us stable time after ACMPEN(ACMP0EN/ACMP1EN) is set.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">ACMPIE   </td><td class="markdownTableBodyLeft">Comparator ACMP Interrupt Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = ACMP interrupt function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = ACMP interrupt function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Interrupt generated if ACMPIE(ACMP0IE/ACMP1IE) bit is set to "1" after ACMP0/1 output changed.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">ACMP_HYSEN   </td><td class="markdownTableBodyLeft">Comparator ACMP0/1 Hysteresis Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = ACMP0 Hysteresis function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = ACMP0 Hysteresis function Enabled. The typical range is 20mV.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5:4]   </td><td class="markdownTableBodyCenter">CN   </td><td class="markdownTableBodyLeft">Comparator ACMP0/1 Negative Input Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = The comparator reference pin ACMP0/1_N is selected as the negative comparator input.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = The internal comparator reference voltage (CRV) is selected as the negative comparator input.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = The internal reference voltage (Int_VREF) is selected as the negative comparator input.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = The AGND is selected as the negative comparator input.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">ACMP0_EX   </td><td class="markdownTableBodyLeft">Comparator ACMP0 Swap    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No swap to the comparator inputs and output.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Swap the comparator inputs with ACMP0_Px and ACMP0_N, and invert the polarity of comparator 0 output.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit swaps the comparator inputs and inverts the comparator output.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[19]   </td><td class="markdownTableBodyCenter">ACOMP0_PN_AutoEx   </td><td class="markdownTableBodyLeft">Comparator Analog ACMP0_Px &amp; ACMP0_N Input Swap Function Automatically    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is only for sigma-delta ADC mode use.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled to swap comparator ACMP0 input function, ACMP0_Px and ACMP0_N, automatically.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled to swap comparator ACMP0 input function, ACMP0_Px and ACMP0_N, automatically.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[20]   </td><td class="markdownTableBodyCenter">ACMP0_FILTER   </td><td class="markdownTableBodyLeft">Comparator ACMP0 Output Filter    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Comparator ACMP0 output is not filtered by internal RC filter.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Comparator ACMP0 output is filtered by internal RC filter.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[21]   </td><td class="markdownTableBodyCenter">CPO0_SEL   </td><td class="markdownTableBodyLeft">Comparator ACMP0 Output To Timer Path Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Comparator ACMP0 output to Timer is through internal path.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Comparator ACMP0 output to Timer is through external pin (through PF.4).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[30:29]   </td><td class="markdownTableBodyCenter">CPP0SEL   </td><td class="markdownTableBodyLeft">Comparator ACMP0 Positive Input Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Input from PA.4.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Input from PA.3.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Input from PA.2.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Input from PA.1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[31]   </td><td class="markdownTableBodyCenter">ACMP_WKEUP_EN   </td><td class="markdownTableBodyLeft">Comparator ACMP0/1 Wake-Up Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Wake-up function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Wake-up function Enabled when the system enters Power-down mode.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l00206">206</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga7c3ab78a735c6154aafb45290d791a94" name="ga7c3ab78a735c6154aafb45290d791a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c3ab78a735c6154aafb45290d791a94">&#9670;&nbsp;</a></span>CR <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t ADC_T::CR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md10"></a>
CR</h1>
<h2><a class="anchor" id="autotoc_md11"></a>
Offset: 0x48  A/D Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">ADEN   </td><td class="markdownTableBodyLeft">A/D Converter Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Before starting A/D conversion, this bit should be set to 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Clear it to 0 to disable A/D converter analog circuit power consumption.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">ADIE   </td><td class="markdownTableBodyLeft">A/D Interrupt Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = A/D interrupt function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = A/D interrupt function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">A/D conversion end interrupt request is generated if ADIE bit is set to 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3:2]   </td><td class="markdownTableBodyCenter">ADMD   </td><td class="markdownTableBodyLeft">A/D Converter Operation Mode    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Single conversion    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Reserved    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Single-cycle scan    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Continuous scan    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:4]   </td><td class="markdownTableBodyCenter">TRGS   </td><td class="markdownTableBodyLeft">Hardware Trigger Source    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field must keep 00    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Software should disable TRGE and ADST before change TRGS.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In hardware trigger mode, the ADST bit is set by the external trigger from STADC, However software has the highest priority to set or cleared ADST bit at any time.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:6]   </td><td class="markdownTableBodyCenter">TRGCOND   </td><td class="markdownTableBodyLeft">External Trigger Condition    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">These two bits decide external pin STADC trigger event is level or edge.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The signal must be kept at stable state at least 8 PCLKs for level trigger and 4 PCLKs at high and low state.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Low level    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = High level    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Falling edge    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Rising edge    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">TRGE   </td><td class="markdownTableBodyLeft">External Trigger Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Enable or disable triggering of A/D conversion by external STADC pin.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">PTEN   </td><td class="markdownTableBodyLeft">PDMA Transfer Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PDMA data transfer Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PDMA data transfer in ADC_RESULT 0~17 Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When A/D conversion is completed, the converted data is loaded into ADC_RESULT 0~10, software can enable this bit to generate a PDMA data transfer request.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When PTEN=1, software must set ADIE=0 to disable interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PDMA can access ADC_RESULT 0-17 registers by block or single transfer mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[10]   </td><td class="markdownTableBodyCenter">DIFF   </td><td class="markdownTableBodyLeft">Differential Mode Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = ADC is operated in single-ended mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = ADC is operated in differential mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The A/D analog input ADC_CH0/ADC_CH1 consists of a differential pair.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">So as ADC_CH2/ADC_CH3, ADC_CH4/ADC_CH5, ADC_CH6/ADC_CH7, ADC_CH8/ADC_CH9 and ADC_CH10/ADC_CH11.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The even channel defines as plus analog input voltage (Vplus) and the odd channel defines as minus analog input voltage (Vminus).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Differential input voltage (Vdiff) = Vplus - Vminus, where Vplus is the analog input; Vminus is the inverted analog input.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In differential input mode, only the even number of the two corresponding channels needs to be enabled in CHEN (ADCHER[11:0]).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The conversion result will be placed to the corresponding data register of the enabled channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Calibration should calibrated each time when switching between single-ended and differential mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[11]   </td><td class="markdownTableBodyCenter">ADST   </td><td class="markdownTableBodyLeft">A/D Conversion Start    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Conversion stopped and A/D converter enter idle state.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Conversion starts.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">ADST bit can be set to 1 from two sources: software write and external pin STADC.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">ADST is cleared to 0 by hardware automatically at the end of single mode and single-cycle scan mode on specified channels.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In continuous scan mode, A/D conversion is continuously performed sequentially unless software writes 0 to this bit or chip reset.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: After ADC conversion done, SW needs to wait at least one ADC clock before to set this bit high again.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[13:12]   </td><td class="markdownTableBodyCenter">TMSEL   </td><td class="markdownTableBodyLeft">Select A/D Enable Time-Out Source    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = TMR0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = TMR1    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = TMR2    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = TMR3    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[15]   </td><td class="markdownTableBodyCenter">TMTRGMOD   </td><td class="markdownTableBodyLeft">Timer Event Trigger ADC Conversion    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = This function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = ADC Enabled by TIMER OUT event. Setting TMSEL to select timer event from timer0~3    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[17:16]   </td><td class="markdownTableBodyCenter">REFSEL   </td><td class="markdownTableBodyLeft">Reference Voltage Source Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Reserved    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Select Int_VREF as reference voltage    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Select VREF as reference voltage    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Reserved    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[19:18]   </td><td class="markdownTableBodyCenter">RESSEL   </td><td class="markdownTableBodyLeft">Resolution Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = 6 bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = 8 bits    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = 10 bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = 12 bits    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:24]   </td><td class="markdownTableBodyCenter">TMPDMACNT   </td><td class="markdownTableBodyLeft">PDMA Count    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When each timer event occur PDMA will transfer TMPDMACNT +1 ADC result in the amount of this register setting    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: The total amount of PDMA transferring data should be set in PDMA byte count register.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When PDMA finish is set, ADC will not be enabled and start transfer even though the timer event occurred.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l00482">482</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga8d24b8fe02f6a146b26cd13985051308" name="ga8d24b8fe02f6a146b26cd13985051308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d24b8fe02f6a146b26cd13985051308">&#9670;&nbsp;</a></span>CR <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t WWDT_T::CR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md446"></a>
CR</h1>
<h2><a class="anchor" id="autotoc_md447"></a>
Offset: 0x04  Window Watchdog Timer Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">WWDTEN   </td><td class="markdownTableBodyLeft">Window Watchdog Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set this bit to enable Window Watchdog timer.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Window Watchdog timer function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Window Watchdog timer function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[11:8]   </td><td class="markdownTableBodyCenter">PERIODSEL   </td><td class="markdownTableBodyLeft">WWDT Pre-Scale Period Select    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">These three bits select the pre-scale for the WWDT counter period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[21:16]   </td><td class="markdownTableBodyCenter">WINCMP   </td><td class="markdownTableBodyLeft">WWDT Window Compare Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set this register to adjust the valid reload window.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: SW only can write WWDTRLD when WWDT counter value between 0 and WINCMP.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If SW writes WWDTRLD when WWDT counter value larger than WWCMP, WWDT will generate RESET signal.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31]   </td><td class="markdownTableBodyCenter">DBGEN   </td><td class="markdownTableBodyLeft">WWDT Debug Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = WWDT stopped count if system is in Debug mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = WWDT still counted even system is in Debug mode.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10480">10480</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga29f9787deab9252b057fa563f3759187" name="ga29f9787deab9252b057fa563f3759187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29f9787deab9252b057fa563f3759187">&#9670;&nbsp;</a></span>CRL0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t PWM_T::CRL0</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md282"></a>
CRL0</h1>
<h2><a class="anchor" id="autotoc_md283"></a>
Offset: 0x60  Capture Rising Latch Register (Channel 0)</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CRL   </td><td class="markdownTableBodyLeft">Capture Rising Latch Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Latch the PWM counter when Channel 0/1/2/3 has rising transition.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CRL_H   </td><td class="markdownTableBodyLeft">Upper Half Word Of 32-Bit Capture Data When Cascade Enabled    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When cascade is enabled for capture channel 0, 2,the original 16 bit counter extend to 32 bit, and capture result CRL0 and CRL2 are also extend to 32 bit,   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l06414">6414</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gad72ee1e1b23d26cc06fe4868d4db611a" name="gad72ee1e1b23d26cc06fe4868d4db611a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad72ee1e1b23d26cc06fe4868d4db611a">&#9670;&nbsp;</a></span>CRL1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t PWM_T::CRL1</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md286"></a>
CRL1</h1>
<h2><a class="anchor" id="autotoc_md287"></a>
Offset: 0x68  Capture Rising Latch Register (Channel 1)</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CRL   </td><td class="markdownTableBodyLeft">Capture Rising Latch Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Latch the PWM counter when Channel 0/1/2/3 has rising transition.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CRL_H   </td><td class="markdownTableBodyLeft">Upper Half Word Of 32-Bit Capture Data When Cascade Enabled    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When cascade is enabled for capture channel 0, 2,the original 16 bit counter extend to 32 bit, and capture result CRL0 and CRL2 are also extend to 32 bit,   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l06442">6442</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga504a797400871a6f73459f37a0810794" name="ga504a797400871a6f73459f37a0810794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga504a797400871a6f73459f37a0810794">&#9670;&nbsp;</a></span>CRL2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t PWM_T::CRL2</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md290"></a>
CRL2</h1>
<h2><a class="anchor" id="autotoc_md291"></a>
Offset: 0x70  Capture Rising Latch Register (Channel 2)</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CRL   </td><td class="markdownTableBodyLeft">Capture Rising Latch Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Latch the PWM counter when Channel 0/1/2/3 has rising transition.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CRL_H   </td><td class="markdownTableBodyLeft">Upper Half Word Of 32-Bit Capture Data When Cascade Enabled    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When cascade is enabled for capture channel 0, 2,the original 16 bit counter extend to 32 bit, and capture result CRL0 and CRL2 are also extend to 32 bit,   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l06470">6470</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga65842f44c6f7f39283c170bdb0ca328f" name="ga65842f44c6f7f39283c170bdb0ca328f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65842f44c6f7f39283c170bdb0ca328f">&#9670;&nbsp;</a></span>CRL3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t PWM_T::CRL3</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md294"></a>
CRL3</h1>
<h2><a class="anchor" id="autotoc_md295"></a>
Offset: 0x78  Capture Rising Latch Register (Channel 3)</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CRL   </td><td class="markdownTableBodyLeft">Capture Rising Latch Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Latch the PWM counter when Channel 0/1/2/3 has rising transition.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CRL_H   </td><td class="markdownTableBodyLeft">Upper Half Word Of 32-Bit Capture Data When Cascade Enabled    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When cascade is enabled for capture channel 0, 2,the original 16 bit counter extend to 32 bit, and capture result CRL0 and CRL2 are also extend to 32 bit,   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l06498">6498</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga769c202442b98c7705ed366570418d4a" name="ga769c202442b98c7705ed366570418d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga769c202442b98c7705ed366570418d4a">&#9670;&nbsp;</a></span>CSAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t PDMA_T::CSAR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md100"></a>
CSAR</h1>
<h2><a class="anchor" id="autotoc_md101"></a>
Offset: 0x14  PDMA Current Source Address Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]   </td><td class="markdownTableBodyCenter">PDMA_CSAR   </td><td class="markdownTableBodyLeft">PDMA Current Source Address Register (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field indicates the source address where the PDMA transfer is just occurring.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l02167">2167</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga9d21db3829051558647d9e50ec276543" name="ga9d21db3829051558647d9e50ec276543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d21db3829051558647d9e50ec276543">&#9670;&nbsp;</a></span>CSR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PDMA_T::CSR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md92"></a>
CSR</h1>
<h2><a class="anchor" id="autotoc_md93"></a>
Offset: 0x00  PDMA Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">PDMACEN   </td><td class="markdownTableBodyLeft">PDMA Channel Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Setting this bit to "1" enables PDMA's operation.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: SW_RST will clear this bit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">SW_RST   </td><td class="markdownTableBodyLeft">Software Engine Reset    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No effect.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Reset the internal state machine and pointers.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The contents of control register will not be cleared.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit will be auto cleared after few clock cycles.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3:2]   </td><td class="markdownTableBodyCenter">MODE_SEL   </td><td class="markdownTableBodyLeft">PDMA Mode Select    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Memory to Memory mode (Memory-to-Memory).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = IP to Memory mode (APB-to-Memory)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Memory to IP mode (Memory-to-APB).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:4]   </td><td class="markdownTableBodyCenter">SAD_SEL   </td><td class="markdownTableBodyLeft">Transfer Source Address Direction Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Transfer Source address is incremented successively.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Transfer Source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Transfer Source address is wrap around (When the PDMA_CBCR is equal to zero, the PDMA_CSAR and PDMA_CBCR register will be updated by PDMA_SAR and PDMA_BCR automatically.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PDMA will start another transfer without software trigger until PDMA_EN disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the PDMA_EN is disabled, the PDMA will complete the active transfer but the remained data which in the PDMA_BUF will not transfer to destination address).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[7:6]   </td><td class="markdownTableBodyCenter">DAD_SEL   </td><td class="markdownTableBodyLeft">Transfer Destination Address Direction Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Transfer Destination address is incremented successively    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Transfer Destination address is fixed (This feature can be used when data where transferred from multiple sources to a single destination)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Transfer Destination address is wrapped around (When the PDMA_CBCR is equal to zero, the PDMA_CDAR and PDMA_CBCR register will be updated by PDMA_DAR and PDMA_BCR automatically.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PDMA will start another transfer without software trigger until PDMA_EN disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the PDMA_EN is disabled, the PDMA will complete the active transfer but the remained data which in the PDMA_BUF will not transfer to destination address).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[12]   </td><td class="markdownTableBodyCenter">TO_EN   </td><td class="markdownTableBodyLeft">Time-Out Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit will enable PDMA internal counter. While this counter counts to zero, the TO_IS will be set.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PDMA internal counter Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PDMA internal counter Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[20:19]   </td><td class="markdownTableBodyCenter">APB_TWS   </td><td class="markdownTableBodyLeft">Peripheral Transfer Width Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = One word (32 bits) is transferred for every PDMA operation.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = One byte (8 bits) is transferred for every PDMA operation.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = One half-word (16 bits) is transferred for every PDMA operation.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This field is meaningful only when MODE_SEL is IP to Memory mode (APB-to-Memory) or Memory to IP mode (Memory-to-APB).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23]   </td><td class="markdownTableBodyCenter">TRIG_EN   </td><td class="markdownTableBodyLeft">TRIG_EN    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No effect.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PDMA data read or write transfer Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: When PDMA transfer completed, this bit will be cleared automatically.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: If the bus error occurs, all PDMA transfer will be stopped.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Software must reset all PDMA channel, and then trig again.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l02114">2114</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga11450e004bab24c0dbe2b152d95e93fc" name="ga11450e004bab24c0dbe2b152d95e93fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11450e004bab24c0dbe2b152d95e93fc">&#9670;&nbsp;</a></span>CTL <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t DMA_CRC_T::CTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md64"></a>
CTL</h1>
<h2><a class="anchor" id="autotoc_md65"></a>
Offset: 0x00  DMA CRC Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">CRCCEN   </td><td class="markdownTableBodyLeft">CRC Channel Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Setting this bit to 1 enables CRC's operation.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When operating in CRC DMA mode (TRIG_EN = 1), if user clear this bit, the DMA operation will be continuous until all CRC DMA operation done, and the TRIG_EN bit will asserted until all CRC DMA operation done.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">But in this case, the CRC_DMAISR [BLKD_IF] flag will inactive, user can read CRC result by reading CRC_CHECKSUM register when TRIG_EN = 0.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When operating in CRC DMA mode (TRIG_EN = 1), if user want to stop the transfer immediately, user can write 1 to CRC_RST bit to stop the transmission.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">CRC_RST   </td><td class="markdownTableBodyLeft">CRC Engine Reset    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Writing 0 to this bit has no effect.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Writing 1 to this bit will reset the internal CRC state machine and internal buffer.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The contents of control register will not be cleared.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit will be auto cleared after few clock cycles.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When operating in CPU PIO mode, setting this bit will reload the initial seed value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[23]   </td><td class="markdownTableBodyCenter">TRIG_EN   </td><td class="markdownTableBodyLeft">Trigger Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No effect.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = CRC DMA data read or write transfer Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: If this bit assert that indicates the CRC engine operation in CRC DMA mode, so don't filled any data in CRC_WDATA register.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: When CRC DMA transfer completed, this bit will be cleared automatically.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note3: If the bus error occurs, all CRC DMA transfer will be stopped.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Software must reset all DMA channel, and then trigger again.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[24]   </td><td class="markdownTableBodyCenter">WDATA_RVS   </td><td class="markdownTableBodyLeft">Write Data Order Reverse    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No bit order reverse for CRC write data in.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Bit order reverse for CRC write data in (per byre).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: If the write data is 0xAABBCCDD, the bit order reverse for CRC write data in is 0x55DD33BB    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[25]   </td><td class="markdownTableBodyCenter">CHECKSUM_RVS   </td><td class="markdownTableBodyLeft">Checksum Reverse    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No bit order reverse for CRC checksum.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Bit order reverse for CRC checksum.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: If the checksum data is 0XDD7B0F2E, the bit order reverse for CRC checksum is 0x74F0DEBB    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[26]   </td><td class="markdownTableBodyCenter">WDATA_COM   </td><td class="markdownTableBodyLeft">Write Data Complement    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No bit order reverse for CRC write data in.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = 1's complement for CRC write data in.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[27]   </td><td class="markdownTableBodyCenter">CHECKSUM_COM   </td><td class="markdownTableBodyLeft">Checksum Complement    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No bit order reverse for CRC checksum.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = 1's complement for CRC checksum.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[29:28]   </td><td class="markdownTableBodyCenter">CPU_WDLEN   </td><td class="markdownTableBodyLeft">CPU Write Data Length    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When operating in CPU PIO mode (CRCCEN= 1, TRIG_EN = 0), this field indicates the write data length.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = The data length is 8-bit mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = The data length is 16-bit mode    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = The data length is 32-bit mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Reserved    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This field is only used for CPU PIO mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: When the data length is 8-bit mode, the valid data is CRC_WDATA [7:0], and if the data length is 16 bit mode, the valid data is CRC_WDATA [15:0].    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:30]   </td><td class="markdownTableBodyCenter">CRC_MODE   </td><td class="markdownTableBodyLeft">CRC Polynomial Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = CRC-CCITT Polynomial Mode    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = CRC-8 Polynomial Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = CRC-16 Polynomial Mode    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = CRC-32 Polynomial Mode   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l01776">1776</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga9455b650a0a22ebfeb3ed2fd92ac539b" name="ga9455b650a0a22ebfeb3ed2fd92ac539b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9455b650a0a22ebfeb3ed2fd92ac539b">&#9670;&nbsp;</a></span>CTL <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t LCD_T::CTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md222"></a>
CTL</h1>
<h2><a class="anchor" id="autotoc_md223"></a>
Offset: 0x00  LCD Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">EN   </td><td class="markdownTableBodyLeft">LCD Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = LCD controller operation Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = LCD controller operation Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3:1]   </td><td class="markdownTableBodyCenter">MUX   </td><td class="markdownTableBodyLeft">Mux Select    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">000 = Static.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">001 = 1/2 duty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">010 = 1/3 duty.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">011 = 1/4 duty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">100 = 1/5 duty.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">101 = 1/6 duty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">110 = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">111 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: User does not need to set PD_H_MFP bit field, but only to set the MUX bit field to switch LCD_SEG0 and LCD_SEG1 to LCD_COM4 and LCD_COM5.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[6:4]   </td><td class="markdownTableBodyCenter">FREQ   </td><td class="markdownTableBodyLeft">LCD Frequency Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">000 = LCD_CLK Divided by 32.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">001 = LCD_CLK Divided by 64.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">010 = LCD_CLK Divided by 96.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">011 = LCD_CLK Divided by 128.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">100 = LCD_CLK Divided by 192.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">101 = LCD_CLK Divided by 256.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">110 = LCD_CLK Divided by 384.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">111 = LCD_CLK Divided by 512.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">BLINK   </td><td class="markdownTableBodyLeft">LCD Blinking Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Blinking Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Blinking Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">PDDISP_EN   </td><td class="markdownTableBodyLeft">Power Down Display Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The LCD can be programmed to be displayed or not be displayed at power down state by PDDISP_EN setting.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = LCD display Disabled ( LCD is put out) at power down state.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = LCD display Enabled (LCD keeps the display) at power down state.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">PDINT_EN   </td><td class="markdownTableBodyLeft">Power Down Interrupt Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the power down request is triggered from system management, LCD controller will execute the frame completely to avoid the DC component.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the frame is executed completely, the LCD power down interrupt signal is generated to inform system management that LCD controller is ready to enter power down state, if PDINT_EN is set to 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Otherwise, if PDINT_EN is set to 0, the LCD power down interrupt signal is blocked and the interrupt is disabled to send to system management.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Power Down Interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Power Down Interrupt Enabled.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l05288">5288</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga0a5218f3d6ce38a982289ba890e94ebc" name="ga0a5218f3d6ce38a982289ba890e94ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a5218f3d6ce38a982289ba890e94ebc">&#9670;&nbsp;</a></span>CTL <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::CTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md252"></a>
CTL</h1>
<h2><a class="anchor" id="autotoc_md253"></a>
Offset: 0x08  PWM Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">CH0EN   </td><td class="markdownTableBodyLeft">PWM-Timer 0 Enable/Disable Start Run    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM-Timer 0 Running Stopped.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM-Timer 0 Start Run Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">CH0INV   </td><td class="markdownTableBodyLeft">PWM-Timer 0 Output Inverter ON/OFF    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Inverter OFF.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Inverter ON.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">CH0MOD   </td><td class="markdownTableBodyLeft">PWM-Timer 0 Continuous/One-Shot Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = One-Shot Mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Continuous Mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: If there is a rising transition at this bit, it will cause CN and CM of PWM0_DUTY0 to be cleared.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">DZEN01   </td><td class="markdownTableBodyLeft">Dead-Zone 0 Generator Enable/Disable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When Dead-Zone Generator is enabled, the pair of PWM0 and PWM1 becomes a complementary pair.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">DZEN23   </td><td class="markdownTableBodyLeft">Dead-Zone 2 Generator Enable/Disable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When Dead-Zone Generator is enabled, the pair of PWM2 and PWM3 becomes a complementary pair.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">CH1EN   </td><td class="markdownTableBodyLeft">PWM-Timer 1 Enable/Disable Start Run    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM-Timer 1 Running Stopped.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM-Timer 1 Start Run Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[10]   </td><td class="markdownTableBodyCenter">CH1INV   </td><td class="markdownTableBodyLeft">PWM-Timer 1 Output Inverter ON/OFF    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Inverter OFF.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Inverter ON.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[11]   </td><td class="markdownTableBodyCenter">CH1MOD   </td><td class="markdownTableBodyLeft">PWM-Timer 1 Continuous/One-Shot Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = One-Shot Mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Continuous Mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: If there is a rising transition at this bit, it will cause CN and CM of PWM0_DUTY1 to be cleared.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">CH2EN   </td><td class="markdownTableBodyLeft">PWM-Timer 2 Enable/Disable Start Run    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM-Timer 2 Running Stopped.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM-Timer 2 Start Run Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[18]   </td><td class="markdownTableBodyCenter">CH2INV   </td><td class="markdownTableBodyLeft">PWM-Timer 2 Output Inverter ON/OFF    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Inverter OFF.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Inverter ON.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[19]   </td><td class="markdownTableBodyCenter">CH2MOD   </td><td class="markdownTableBodyLeft">PWM-Timer 2 Continuous/One-Shot Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = One-Shot Mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Continuous Mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: If there is a rising transition at this bit, it will cause CN and CM of PWM0_DUTY2 be cleared.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[24]   </td><td class="markdownTableBodyCenter">CH3EN   </td><td class="markdownTableBodyLeft">PWM-Timer 3 Enable/Disable Start Run    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM-Timer 3 Running Stopped.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM-Timer 3 Start Run Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[26]   </td><td class="markdownTableBodyCenter">CH3INV   </td><td class="markdownTableBodyLeft">PWM-Timer 3 Output Inverter ON/OFF    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Inverter OFF.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Inverter ON.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[27]   </td><td class="markdownTableBodyCenter">CH3MOD   </td><td class="markdownTableBodyLeft">PWM-Timer 3 Continuous/One-Shot Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = One-Shot Mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Continuous Mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: If there is a rising transition at this bit, it will cause CN and CM of PWM0_DUTY3 to be cleared.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[30]   </td><td class="markdownTableBodyCenter">PWMTYPE01   </td><td class="markdownTableBodyLeft">Channel 0,1 Counter Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Edge-aligned Mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Center-aligned Mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[31]   </td><td class="markdownTableBodyCenter">PWMTYPE23   </td><td class="markdownTableBodyLeft">Channel 2,3 Counter Mode    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Edge-aligned Mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Center-aligned Mode.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l05848">5848</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga657b6619f178ac1a923485d599c1b0f7" name="ga657b6619f178ac1a923485d599c1b0f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga657b6619f178ac1a923485d599c1b0f7">&#9670;&nbsp;</a></span>CTL <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SC_T::CTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md336"></a>
CTL</h1>
<h2><a class="anchor" id="autotoc_md337"></a>
Offset: 0x04  SC Control Register.</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">SC_CEN   </td><td class="markdownTableBodyLeft">SC Engine Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set this bit to "1" to enable SC operation.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If this bit is cleared, SC will force all transition to IDLE state.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">DIS_RX   </td><td class="markdownTableBodyLeft">RX Transition Disable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Receiver Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Receiver Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">DIS_TX   </td><td class="markdownTableBodyLeft">TX Transition Disable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Transceiver Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Transceiver Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">AUTO_CON_EN   </td><td class="markdownTableBodyLeft">Auto Convention Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Auto-convention Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Auto-convention Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When hardware receives TS in answer to reset state and the TS is direct convention, CON_SEL will be set to 00 automatically, otherwise if the TS is inverse convention, CON_SEL will be set to 11.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If software enables auto convention function, the setting step must be done before Answer to Reset state and the first data must be 0x3B or 0x3F.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">After hardware received first data and stored it at buffer, hardware will decided the convention and change the SC_CTL[CON_SEL] register automatically.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the first data is not 0x3B or 0x3F, hardware will generate an interrupt INT_ACON_ERR(if SC_IER [ACON_ERR_IE = "1"] to CPU.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:4]   </td><td class="markdownTableBodyCenter">CON_SEL   </td><td class="markdownTableBodyLeft">Convention Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Direct convention.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Inverse convention.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: If AUTO_CON_EN is enabled, this field must be ignored.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:6]   </td><td class="markdownTableBodyCenter">RX_FTRI_LEV   </td><td class="markdownTableBodyLeft">RX Buffer Trigger Level    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the number of bytes in the receiving buffer equals the RX_FTRI_LEV, the RDA_IF will be set (if IER [RDA_IEN] is enabled, an interrupt will be generated).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = INTR_RDA Trigger Level 1 byte.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = INTR_RDA Trigger Level 2 bytes.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = INTR_RDA Trigger Level 3 bytes.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[12:8]   </td><td class="markdownTableBodyCenter">BGT   </td><td class="markdownTableBodyLeft">Block Guard Time (BGT)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field indicates the counter for block guard time.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">According to ISO7816-3, in T=0 mode, software must fill 15 (real block guard time = 16) to this field and in T=1 mode software must fill 21 (real block guard time = 22) to it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In TX mode, hardware will auto hold off first character until BGT has elapsed regardless of the TX data.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In RX mode, software can enable SC_ALTCTL [RX_BGT_EN] to detect the first coming character timing.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the incoming data timing less than BGT, an interrupt will be generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: The real block guard time is BGT + 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[14:13]   </td><td class="markdownTableBodyCenter">TMR_SEL   </td><td class="markdownTableBodyLeft">Timer Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Disable all internal timer function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Enable internal 24 bit timer.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Software can configure it by setting SC_TMR0 [23:0].    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SC_TMR1 and SC_TMR2 will be ignored in this mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Enable internal 24 bit timer and 8 bit internal timer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Software can configure the 24 bit timer by setting SC_TMR0 [23:0] and configure the 8 bit timer by setting SC_TMR1 [7:0].    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SC_TMR2 will be ignored in this mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Enable internal 24 bit timer and two 8 bit timers.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Software can configure them by setting SC_TMR0 [23:0], SC_TMR1 [7:0] and SC_TMR2 [7:0].    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[15]   </td><td class="markdownTableBodyCenter">SLEN   </td><td class="markdownTableBodyLeft">Stop Bit Length    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field indicates the length of stop bit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The stop bit length is 2 ETU.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The stop bit length is 1 ETU.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: The default stop bit length is 2.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[18:16]   </td><td class="markdownTableBodyCenter">RX_ERETRY   </td><td class="markdownTableBodyLeft">RX Error Retry Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field indicates the maximum number of receiver retries that are allowed when parity error has occurred.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: The real maximum retry number is RX_ERETRY + 1, so 8 is the maximum retry number.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: This field can not be changed when RX_ERETRY_EN enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The change flow is to disable RX_ETRTRY_EN first and then fill new retry value.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[19]   </td><td class="markdownTableBodyCenter">RX_ERETRY_EN   </td><td class="markdownTableBodyLeft">RX Error Retry Enable Register    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit enables receiver retry function when parity error has occurred.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RX error retry function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RX error retry function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: User must fill RX_ERETRY value before enabling this bit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[22:20]   </td><td class="markdownTableBodyCenter">TX_ERETRY   </td><td class="markdownTableBodyLeft">TX Error Retry Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field indicates the maximum number of transmitter retries that are allowed when parity error has occurred.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: The real retry number is TX_ERETRY + 1, so 8 is the maximum retry number.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: This field can not be changed when TX_ERETRY_EN enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The change flow is to disable TX_ETRTRY_EN first and then fill new retry value.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[23]   </td><td class="markdownTableBodyCenter">TX_ERETRY_EN   </td><td class="markdownTableBodyLeft">TX Error Retry Enable Register    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit enables transmitter retry function when parity error has occurred.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = TX error retry function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = TX error retry function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: User must fill TX_ERETRY value before enabling this bit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[25:24]   </td><td class="markdownTableBodyCenter">CD_DEB_SEL   </td><td class="markdownTableBodyLeft">Card Detect De-Bounce Select Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field indicates the card detect de-bounce selection.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field indicates the card detect de-bounce selection.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = De-bounce sample card insert once per 384 (128 * 3) engine clocks and de-bounce sample card removal once per 128 engine clocks.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = De-bounce sample card insert once per 192 (64 * 3) engine clocks and de-bounce sample card removal once per 64 engine clocks.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = De-bounce sample card insert once per 96 (32 * 3) engine clocks and de-bounce sample card removal once per 32 engine clocks.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = De-bounce sample card insert once per 48 (16 * 3) engine clocks and de-bounce sample card removal once per 16 engine clocks.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l07658">7658</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga069fd6acdea1842f24bba35267ff3ea5" name="ga069fd6acdea1842f24bba35267ff3ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga069fd6acdea1842f24bba35267ff3ea5">&#9670;&nbsp;</a></span>CTL <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SPI_T::CTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md370"></a>
CTL</h1>
<h2><a class="anchor" id="autotoc_md371"></a>
Offset: 0x00  SPI Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">GO_BUSY   </td><td class="markdownTableBodyLeft">SPI Transfer Control Bit And Busy Status    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Writing this bit "0" will stop data transfer if SPI is transferring.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = In Master mode, writing "1" to this bit will start the SPI data transfer; In Slave mode, writing '1' to this bit indicates that the salve is ready to communicate with a master.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the FIFO mode is disabled, during the data transfer, this bit keeps the value of '1'.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">As the transfer is finished, this bit will be cleared automatically.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Software can read this bit to check if the SPI is in busy status.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In FIFO mode, this bit will be controlled by hardware.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Software should not modify this bit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In slave mode, this bit always returns 1 when software reads this register.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In master mode, this bit reflects the busy or idle status of SPI.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: When FIFO mode is disabled, all configurations should be set before writing "1" to the GO_BUSY bit in the SPI_CTL register.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: When FIFO bit is disabled and the software uses TX or RX PDMA function to transfer data, this bit will be cleared after the PDMA controller finishes the data transfer.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">RX_NEG   </td><td class="markdownTableBodyLeft">Receive At Negative Edge    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The received data is latched on the rising edge of SPI_SCLK.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The received data is latched on the falling edge of SPI_SCLK.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">TX_NEG   </td><td class="markdownTableBodyLeft">Transmit At Negative Edge    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The transmitted data output is changed on the rising edge of SPI_SCLK.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The transmitted data output is changed on the falling edge of SPI_SCLK.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:3]   </td><td class="markdownTableBodyCenter">TX_BIT_LEN   </td><td class="markdownTableBodyLeft">Transmit Bit Length    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field specifies how many bits can be transmitted / received in one transaction.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The minimum bit length is 8 bits and can be up to 32 bits.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00000 = 32 bits are transmitted in one transaction.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01000 = 8 bits are transmitted in one transaction.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01001 = 9 bits are transmitted in one transaction.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01010 = 10 bits are transmitted in one transaction.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">--&mdash;    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11111 = 31 bits are transmitted in one transaction.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[10]   </td><td class="markdownTableBodyCenter">LSB   </td><td class="markdownTableBodyLeft">Send LSB First    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The MSB, which bit of transmit/receive register depends on the setting of TX_BITLEN, is transmitted/received first.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The LSB, bit 0 of the SPI_TX0/1, is sent first to the the SPI data output pin, and the first bit received from the SPI data input pin will be put in the LSB position of the SPI_RX register (SPI_RX0/1).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[11]   </td><td class="markdownTableBodyCenter">CLKP   </td><td class="markdownTableBodyLeft">Clock Polarity    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The default level of SCLK is low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The default level of SCLK is high.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[15:12]   </td><td class="markdownTableBodyCenter">SP_CYCLE   </td><td class="markdownTableBodyLeft">Suspend Interval (Master Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">These four bits provide configurable suspend interval between two successive transmit/receive transaction in a transfer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The suspend interval is from the last falling clock edge of the current transaction to the first rising clock edge of the successive transaction if CLKP = "0".    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If CLKP = "1", the interval is from the rising clock edge to the falling clock edge.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The default value is 0x3. The desired suspend interval is obtained according to the following equation:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(SP_CYCLE[3:0) + 0.5) * period of SPICLK    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Ex:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SP_CYCLE = 0x0 .... 0.5 SPICLK clock cycle.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SP_CYCLE = 0x1 .... 1.5 SPICLK clock cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">......    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SP_CYCLE = 0xE .... 14.5 SPICLK clock cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SP_CYCLE = 0xF .... 15.5 SPICLK clock cycle.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the Variable Clock function is enabled, the minimum period of suspend interval (the transmit data in FIFO buffer is not empty) between the successive transaction is (6.5 + SP_CYCLE) * SPICLK clock cycle    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[17]   </td><td class="markdownTableBodyCenter">INTEN   </td><td class="markdownTableBodyLeft">Interrupt Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = SPI Interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = SPI Interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[18]   </td><td class="markdownTableBodyCenter">SLAVE   </td><td class="markdownTableBodyLeft">Slave Mode    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = SPI controller set as Master mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = SPI controller set as Slave mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[19]   </td><td class="markdownTableBodyCenter">REORDER   </td><td class="markdownTableBodyLeft">Byte Reorder Function Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disable byte reorder function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enable byte reorder function and insert a byte suspend interval among each byte.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The setting of TX_BIT_LEN must be configured as 00b ( 32 bits/ word).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The suspend interval is defined in SP_CYCLE.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Byte Suspend is only used in SPI Byte Reorder mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[21]   </td><td class="markdownTableBodyCenter">FIFOM   </td><td class="markdownTableBodyLeft">FIFO Mode Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = FIFO mode Disabled (in Normal mode).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = FIFO mode Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[22]   </td><td class="markdownTableBodyCenter">TWOB   </td><td class="markdownTableBodyLeft">2-Bit Transfer Mode Active    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = 2-bit transfer mode Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = 2-bit transfer mode Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23]   </td><td class="markdownTableBodyCenter">VARCLK_EN   </td><td class="markdownTableBodyLeft">Variable Clock Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The serial clock output frequency is fixed and only decided by the value of DIVIDER1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The serial clock output frequency is variable.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The output frequency is decided by the value of VARCLK (SPI_VARCLK), DIVIDER1, and DIVIDER2.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[28]   </td><td class="markdownTableBodyCenter">DUAL_IO_DIR   </td><td class="markdownTableBodyLeft">Dual IO Mode Direction    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Date read in the Dual I/O Mode function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Data write in the Dual I/O Mode function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[29]   </td><td class="markdownTableBodyCenter">DUAL_IO_EN   </td><td class="markdownTableBodyLeft">Dual IO Mode Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Dual I/O Mode function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Dual I/O Mode function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31]   </td><td class="markdownTableBodyCenter">WKEUP_EN   </td><td class="markdownTableBodyLeft">Wake-Up Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Wake-up function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Wake-up function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When the system enters Power-down mode, the system can be wake-up from the SPI controller when this bit is enabled and if there is any toggle in the SPICLK port.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">After the system wake-up, this bit must be cleared by user to disable the wake-up requirement.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l08551">8551</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gabb8d9df4695b742a04b52a7a64594322" name="gabb8d9df4695b742a04b52a7a64594322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb8d9df4695b742a04b52a7a64594322">&#9670;&nbsp;</a></span>CTL <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t TIMER_T::CTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md392"></a>
CTL</h1>
<h2><a class="anchor" id="autotoc_md393"></a>
Offset: 0x00  Timer x Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">TMR_EN   </td><td class="markdownTableBodyLeft">Timer Counter Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Stops/Suspends counting.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Starts counting.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: Set TMR_EN to 1 enables 24-bit counter keeps up counting from the last stop counting value.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: This bit is auto-cleared by hardware in one-shot mode (MODE_SEL (TMRx_CTL[5:4]) = 00) once the value of 24-bit up counter equals the TMRx_CMPR.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">SW_RST   </td><td class="markdownTableBodyLeft">Software Reset    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set this bit will reset the timer counter, pre-scale counter and also force TMR_EN (TMRx_CTL [0]) to 0.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No effect.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Reset Timer's pre-scale counter, internal 24-bit up-counter and TMR_EN (TMRx_CTL [0]) bit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit will be auto cleared and takes at least 3 TMRx_CLK clock cycles.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">WAKE_EN   </td><td class="markdownTableBodyLeft">Wake-Up Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When WAKE_EN is set and the TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1]) is set, the timer controller will generate a wake-up trigger event to CPU.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Wake-up trigger event Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Wake-up trigger event Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">DBGACK_EN   </td><td class="markdownTableBodyLeft">ICE Debug Mode Acknowledge Ineffective Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = ICE debug mode acknowledgement effects TIMER counting and TIMER counter will be held while ICE debug mode acknowledged.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = ICE debug mode acknowledgement is ineffective and TIMER counter will keep going no matter ICE debug mode acknowledged or not.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5:4]   </td><td class="markdownTableBodyCenter">MODE_SEL   </td><td class="markdownTableBodyLeft">Timer Operating Mode Select    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = The timer is operating in the one-shot mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In this mode, the associated interrupt signal is generated (if TMR_IER [TMR_IE] is enabled) once the value of 24-bit up counter equals the TMRx_CMPR.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">And TMR_CTL [TMR_EN] is automatically cleared by hardware.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = The timer is operating in the periodic mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In this mode, the associated interrupt signal is generated periodically (if TMR_IER [TMR_IE] is enabled) while the value of 24-bit up counter equals the TMRx_CMPR.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">After that, the 24-bit counter will be reset and starts counting from zero again.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = The timer is operating in the periodic mode with output toggling.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In this mode, the associated interrupt signal is generated periodically (if TMR_IER [TMR_IE] is enabled) while the value of 24-bit up counter equals the TMRx_CMPR.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">After that, the 24-bit counter will be reset and starts counting from zero again.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">At the same time, timer controller will also toggle the output pin TMRx_TOG_OUT to its inverse level (from low to high or from high to low).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: The default level of TMRx_TOG_OUT after reset is low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = The timer is operating in continuous counting mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In this mode, the associated interrupt signal is generated when TMR_DR = TMR_CMPR (if TMR_IER [TMR_IE] is enabled).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">However, the 24-bit up-counter counts continuously without reset.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">ACMP_EN_TMR   </td><td class="markdownTableBodyLeft">ACMP Trigger Timer Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit high enables the functionality that when ACMP0 is in sigma-delta mode, it could enable Timer.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = ACMP0 trigger timer functionality disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = ACMP0 trigger timer functionality enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">TMR_ACT   </td><td class="markdownTableBodyLeft">Timer Active Status Bit (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates the timer counter status of timer.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Timer is not active.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Timer is in active.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">ADC_TEEN   </td><td class="markdownTableBodyLeft">Timer Trigger ADC Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit controls if TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1]) could trigger ADC.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When ADC_TEEN is set, TMR_IS (TMRx_ISR[0]) is set and the CAP_TRG_EN (TMRx_CTL[11]) is low, the timer controller will generate an internal trigger event to ADC controller.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When ADC_TEEN is set, TCAP_IS (TMRx_ISR[1]) is set and the CAP_TRG_EN (TMRx_CTL[11]) is high, the timer controller will generate an internal trigger event to ADC controller.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1]) trigger ADC Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1]) trigger ADC Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[10]   </td><td class="markdownTableBodyCenter">PDMA_TEEN   </td><td class="markdownTableBodyLeft">Timer Trigger PDMA Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit controls if TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1]) could trigger PDMA.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When PDMA_TEEN is set, TMR_IS (TMRx_ISR[0]) is set and the CAP_TRG_EN (TMRx_CTL[11]) is low, the timer controller will generate an internal trigger event to PDMA controller.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When PDMA_TEEN is set, TCAP_IS (TMRx_ISR[1]) is set and the CAP_TRG_EN (TMRx_CTL[11]) is high, the timer controller will generate an internal trigger event to PDMA controller.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1]) trigger PDMA Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1]) trigger PDMA Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[11]   </td><td class="markdownTableBodyCenter">CAP_TRG_EN   </td><td class="markdownTableBodyLeft">TCAP_IS Trigger Mode Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit controls if the TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1]) is used to trigger PDMA and ADC while TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1]) is set.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If this bit is low and TMR_IS (TMRx_ISR[0]) is set, timer will generate an internal trigger event to PDMA or ADC while related trigger enable bit (PDMA_TEEN (TMRx_CTL[10]) or ADC_TEEN (TMRx_CTL[8])) is set.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If this bit is set high and TCAP_IS (TMRx_ISR[0]) is set, timer will generate an internal trigger event to PDMA or ADC while related trigger enable bit (PDMA_TEEN (TMRx_CTL[10]) or ADC_TEEN (TMRx_CTL[8])) is set.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = TMR_IS (TMRx_ISR[0]) is used to trigger PDMA and ADC.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = TCAP_IS (TMRx_ISR[1]) is used to trigger PDMA and ADC.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[12]   </td><td class="markdownTableBodyCenter">EVENT_EN   </td><td class="markdownTableBodyLeft">Event Counting Mode Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When EVENT_EN is set, the increase of 24-bit up-counting timer is controlled by external event pin.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">While the transition of external event pin matches the definition of EVENT_EDGE (TMRx_CTL[13]), the 24-bit up-counting timer increases by 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Or, the 24-bit up-counting timer will keep its value unchanged.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Timer counting is not controlled by external event pin.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Timer counting is controlled by external event pin.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[13]   </td><td class="markdownTableBodyCenter">EVENT_EDGE   </td><td class="markdownTableBodyLeft">Event Counting Mode Edge Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates which edge of external event pin enabling the timer to increase 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = A falling edge of external event enabling the timer to increase 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = A rising edge of external event enabling the timer to increase 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[14]   </td><td class="markdownTableBodyCenter">EVNT_DEB_EN   </td><td class="markdownTableBodyLeft">External Event De-Bounce Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When EVNT_DEB_EN is set, the external event pin de-bounce circuit will be enabled to eliminate the bouncing of the signal.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In de-bounce circuit the external event pin will be sampled 4 times by TMRx_CLK.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = De-bounce circuit Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = De-bounce circuit Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When EVENT_EN (TMRx_CTL[12]) is enabled, enable this bit is recommended.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">And, while EVENT_EN (TMRx_CTL[12]) is disabled, disable this bit is recommended to save power consumption.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">TCAP_EN   </td><td class="markdownTableBodyLeft">TC Pin Functional Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit controls if the transition on TC pin could be used as timer counter reset function or timer capture function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The transition on TC pin is ignored.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The transition on TC pin will result in the capture or reset of 24-bit timer counter.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For TMRx_CTL, if INTR_TRG_EN (TMRx_CTL[24]) is set, the TCAP_EN will be forced to low and the TC pin transition is ignored (where x = 0 or 2).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For TMRx+1_CTL, if INTR_TRG_EN (TMRx_CTL[24]) is set, the TCAP_EN will be forced to high (where x = 0 or 2).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[17]   </td><td class="markdownTableBodyCenter">TCAP_MODE   </td><td class="markdownTableBodyLeft">TC Pin Function Mode Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates if the transition on TC pin is used as timer counter reset function or timer capture function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The transition on TC pin is used as timer capture function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The transition on TC pin is used as timer counter reset function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For TMRx+1_CTL, if INTR_TRG_EN (TMRx_CTL[24]) is set, the TCAP_MODE will be forced to low (where x = 0 or 2).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[19:18]   </td><td class="markdownTableBodyCenter">TCAP_EDGE   </td><td class="markdownTableBodyLeft">TC Pin Edge Detect Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field defines that active transition of Tcapture pin is for timer counter reset function or for timer capture function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For timer counter reset function and free-counting mode of timer capture function, the configurations are:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = A falling edge (1 to 0 transition) on Tcapture pin is an active transition.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = A rising edge (0 to 1 transition) on Tcapture pin is an active transition.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Both falling edge (1 to 0 transition) and rising edge (0 to 1 transition) on Tcapture pin are active transitions.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Both falling edge (1 to 0 transition) and rising edge (0 to 1 transition) on Tcapture pin are active transitions.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For trigger-counting mode of timer capture function, the configurations are:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = 1st falling edge on Tcapture pin triggers 24-bit timer to start counting, while 2nd falling edge triggers 24-bit timer to stop counting.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = 1st rising edge on Tcapture pin triggers 24-bit timer to start counting, while 2nd rising edge triggers 24-bit timer to stop counting.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Falling edge on Tcapture pin triggers 24-bit timer to start counting, while rising edge triggers 24-bit timer to stop counting.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Rising edge on Tcapture pin triggers 24-bit timer to start counting, while falling edge triggers 24-bit timer to stop counting.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For TMRx+1_CTL, if INTR_TRG_EN is set, the TCAP_EDGE will be forced to 11.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[20]   </td><td class="markdownTableBodyCenter">TCAP_CNT_MOD   </td><td class="markdownTableBodyLeft">Timer Capture Counting Mode Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates the behavior of 24-bit up-counting timer while TCAP_EN (TMRx_CTL[16]) is set to high.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If this bit is 0, the free-counting mode, the behavior of 24-bit up-counting timer is defined by MODE_SEL (TMRx_CTL[5:4]) field.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When TCAP_EN (TMRx_CTL[16]) is set, TCAP_MODE (TMRx_CTL[17]) is 0, and the transition of TC pin matches the TCAP_EDGE (TMRx_CTL[19:18]) setting, the value of 24-bit up-counting timer will be saved into register TMRx_TCAP.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If this bit is 1, Trigger-counting mode, 24-bit up-counting timer will be not counting and keep its value at 0.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When TCAP_EN (TMRx_CTL[16]) is set, TCAP_MODE (TMRx_CTL[17]) is 0, and once the transition of external pin matches the 1st transition of TCAP_EDGE (TMRx_CTL[19:18]) setting, the 24-bit up-counting timer will start counting.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">And then if the transition of external pin matches the 2nd transition of TCAP_EDGE (TMRx_CTL[19:18]) setting, the 24-bit up-counting timer will stop counting.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">And its value will be saved into register TMRx_TCAP.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Capture with free-counting timer mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Capture with trigger-counting timer mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For TMRx+1_CTL, if INTR_TRG_EN (TMRx_CTL[24]) is set, the TCAP_CNT_MOD will be forced to high, the capture with Trigger-counting Timer mode (where x = 0 or 2).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[22]   </td><td class="markdownTableBodyCenter">TCAP_DEB_EN   </td><td class="markdownTableBodyLeft">TC Pin De-Bounce Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When CAP_DEB_EN (TMRx_CTL[22]) is set, the TC pin de-bounce circuit will be enabled to eliminate the bouncing of the signal.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In de-bounce circuit the TC pin signal will be sampled 4 times by TMRx_CLK.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = De-bounce circuit Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = De-bounce circuit Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When TCAP_EN (TMRx_CTL[16]) is enabled, enable this bit is recommended.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">And, while TCAP_EN (TMRx_CTL[16]) is disabled, disable this bit is recommended to save power consumption.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When CAP_SRC (TMRx_ECTL[16]) is high, the capture signal is from internal of chip and the de-bounce circuit would not take effect no matter this bit is high or low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For Timer 1 and 3, when INTR_TRG_EN (TMRx_CTL[24]) is high, the capture signal is from internal of chip and the de-bounce circuit would not take effect no matter this bit is high or low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[24]   </td><td class="markdownTableBodyCenter">INTR_TRG_EN   </td><td class="markdownTableBodyLeft">Inter-Timer Trigger Function Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit controls if Inter-timer Trigger function is enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If Inter-timer Trigger function is enabled, the TMRx will be in counter mode and counting with external Clock Source or event.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In addition, TMRx+1 will be in trigger-counting mode of capture function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Inter-timer trigger function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Inter-timer trigger function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For TMRx+1_CTL, this bit is ignored and the read back value is always 0.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[25]   </td><td class="markdownTableBodyCenter">INTR_TRG_MODE   </td><td class="markdownTableBodyLeft">Inter-Timer Trigger Mode Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit controls the timer operation mode when inter-timer trigger function is enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When this bit is low, the TMRx will be in counter mode and counting with external Clock Source or event.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In addition, TMRx+1 will be in trigger-counting mode of capture function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In this mode, TMRx_CMPR control when inter-timer trigger function terminated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When this bit is high, the TMRx will be in counter mode and counting with external Clock Source or event.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In addition, TMRx+1 will be in trigger-counting mode of capture function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In this mode, TMRx+1_CMPR control when inter-timer trigger function terminated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In this mode, TMRx would ignore some incoming event based on the EVNT_DROP_CNT (TMRx_ECTL[31:24]).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">And once the TMRx+1 counter value equal or large than TMRx+1_CMPR, TMRx would terminate the operation when next incoming event received.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Inter-Timer Trigger function wouldn't ignore any incoming event.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Inter-Timer Trigger function would ignore incoming event based on the EVNT_DROP_CNT (TMRx_ECTL[31:24]).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For TMRx+1_CTL, this bit is ignored and the read back value is always 0.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l09178">9178</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga9ab90d38586ab0cbf20d7b41f1190374" name="ga9ab90d38586ab0cbf20d7b41f1190374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ab90d38586ab0cbf20d7b41f1190374">&#9670;&nbsp;</a></span>CTL <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t UART_T::CTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md408"></a>
CTL</h1>
<h2><a class="anchor" id="autotoc_md409"></a>
Offset: 0x04  UART Control State Register.</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">RX_RST   </td><td class="markdownTableBodyLeft">RX Software Reset    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When RX_RST is set, all the bytes in the receiving FIFO and RX internal state machine are cleared.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No effect.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Reset the RX internal state machine and pointers.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit will be auto cleared and take at least 3 UART engine clock cycles.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">TX_RST   </td><td class="markdownTableBodyLeft">TX Software Reset    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When TX_RST is set, all the bytes in the transmitting FIFO and TX internal state machine are cleared.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No effect.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Reset the TX internal state machine and pointers.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit will be auto cleared and take at least 3 UART engine clock cycles.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">RX_DIS   </td><td class="markdownTableBodyLeft">Receiver Disable Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The receiver is disabled or not (set "1" to disable receiver)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Receiver Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Receiver Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: In RS-485 NMM mode, user can set this bit to receive data before detecting address byte.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: In RS-485 AAD mode, this bit will be setting to "1" automatically.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note3: In RS-485 AUD mode and LIN "break + sync +PID" header mode, hardware will control data automatically, so don't fill any value to this bit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">TX_DIS   </td><td class="markdownTableBodyLeft">Transfer Disable Register    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The transceiver is disabled or not (set "1" to disable transceiver)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Transfer Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Transfer Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">AUTO_RTS_EN   </td><td class="markdownTableBodyLeft">RTSn Auto-Flow Control Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RTSn auto-flow control. Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RTSn auto-flow control Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When RTSn auto-flow is enabled, if the number of bytes in the RX-FIFO equals the UART_FCR [RTS_Tri_Lev], the UART will reassert RTSn signal.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">AUTO_CTS_EN   </td><td class="markdownTableBodyLeft">CTSn Auto-Flow control Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = CTSn auto-flow control Disabled    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = CTSn auto-flow control Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When CTSn auto-flow is enabled, the UART will send data to external device when CTSn input assert (UART will not send data to device until CTSn is asserted).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">DMA_RX_EN   </td><td class="markdownTableBodyLeft">RX DMA Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit can enable or disable RX PDMA service.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RX PDMA service function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RX PDMA service function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">DMA_TX_EN   </td><td class="markdownTableBodyLeft">TX DMA Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit can enable or disable TX PDMA service.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = TX PDMA service function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = TX PDMA service function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">WAKE_CTS_EN   </td><td class="markdownTableBodyLeft">CTSn Wake-Up Function Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = CTSn wake-up system function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Wake-up function Enabled when the system is in power-down mode, an external CTSn change will wake-up system from power-down mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">WAKE_DATA_EN   </td><td class="markdownTableBodyLeft">Incoming Data Wake-Up Function Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Incoming data wake-up system Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Incoming data wake-up function Enabled when the system is in power-down mode, incoming data will wake-up system from power-down mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Hardware will clear this bit when the incoming data wake-up operation finishes and "system clock" work stable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[12]   </td><td class="markdownTableBodyCenter">ABAUD_EN   </td><td class="markdownTableBodyLeft">Auto-Baud Rate Detect Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Auto-baud rate detect function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Auto-baud rate detect function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When the auto-baud rate detect operation finishes, hardware will clear this bit and the associated interrupt (INT_ABAUD) will be generated (If ABAUD_IE (UART_IER [7]) be enabled).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[17]   </td><td class="markdownTableBodyCenter">WAKE_THRESH_EN   </td><td class="markdownTableBodyLeft">FIFO Threshold Reach Wake-Up Function Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Received FIFO threshold reach wake-up function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Received FIFO threshold reach wake-up function Enabled when the system is in power-down mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[18]   </td><td class="markdownTableBodyCenter">WAKE_RS485_AAD_EN   </td><td class="markdownTableBodyLeft">RS-485 Address Match Wake-Up Function Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RS-485 ADD mode address match wake-up function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RS-485 AAD mode address match wake-up function Enabled when the system is in power-down mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[26:24]   </td><td class="markdownTableBodyCenter">PWM_SEL   </td><td class="markdownTableBodyLeft">PWM Channel Select For Modulation    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Select the PWM channel to modulate with the UART transmit bus.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">000 = PWM channel 0 modulate with UART TX.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">001 = PWM channel 1 modulate with UART TX.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">010 = PWM channel 2 modulate with UART TX.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">011 = PWM channel 3 modulate with UART TX.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The others, no modulation of UART with PWM   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l09581">9581</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaee8e65be2579f6ca7675e9a63886ab42" name="gaee8e65be2579f6ca7675e9a63886ab42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee8e65be2579f6ca7675e9a63886ab42">&#9670;&nbsp;</a></span>CTL <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t WDT_T::CTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md438"></a>
CTL</h1>
<h2><a class="anchor" id="autotoc_md439"></a>
Offset: 0x00  Watchdog Timer Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">WTR   </td><td class="markdownTableBodyLeft">Clear Watchdog Timer    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a protected register. Please refer to open lock sequence to program it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set this bit will clear the Watchdog timer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No effect.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Reset the contents of the Watchdog timer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit will be auto cleared after few clock cycles.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">WTRE   </td><td class="markdownTableBodyLeft">Watchdog Timer Reset Function Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a protected register. Please refer to open lock sequence to program it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Setting this bit will enable the Watchdog timer reset function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Watchdog timer reset function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Watchdog timer reset function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">WTWKE   </td><td class="markdownTableBodyLeft">Watchdog Timer Wake-Up Function Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a protected register. Please refer to open lock sequence to program it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Watchdog timer Wake-up CPU function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Wake-up function Enabled so that Watchdog timer time-out can wake up CPU from power-down mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">WTE   </td><td class="markdownTableBodyLeft">Watchdog Timer Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a protected register. Please refer to open lock sequence to program it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Watchdog timer Disabled (this action will reset the internal counter).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Watchdog timer Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[6:4]   </td><td class="markdownTableBodyCenter">WTIS   </td><td class="markdownTableBodyLeft">Watchdog Timer Interval Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a protected register. Please refer to open lock sequence to program it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">These three bits select the time-out interval for the Watchdog timer.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This count is free running counter.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[9:8]   </td><td class="markdownTableBodyCenter">WTRDSEL   </td><td class="markdownTableBodyLeft">Watchdog Timer Reset Delay Select    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When watchdog timeout happened, software has a time named watchdog reset delay period to clear watchdog timer to prevent watchdog reset happened.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Software can select a suitable value of watchdog reset delay period for different watchdog timeout period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Watchdog reset delay period is 1026 watchdog clock    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Watchdog reset delay period is 130 watchdog clock    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Watchdog reset delay period is 18 watchdog clock    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Watchdog reset delay period is 3 watchdog clock    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This register will be reset if watchdog reset happened   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10348">10348</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gae9328015fb4cd6a934f99b2463a7149f" name="gae9328015fb4cd6a934f99b2463a7149f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9328015fb4cd6a934f99b2463a7149f">&#9670;&nbsp;</a></span>DAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PDMA_T::DAR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md96"></a>
DAR</h1>
<h2><a class="anchor" id="autotoc_md97"></a>
Offset: 0x08  PDMA Destination Address Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]   </td><td class="markdownTableBodyCenter">PDMA_DAR   </td><td class="markdownTableBodyLeft">PDMA Transfer Destination Address Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field indicates a 32-bit destination address of PDMA.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note : The destination address must be word alignment   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l02140">2140</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gab30093acea7930ab2ef7bc15872a1043" name="gab30093acea7930ab2ef7bc15872a1043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab30093acea7930ab2ef7bc15872a1043">&#9670;&nbsp;</a></span>DATA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t I2C_T::DATA</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md208"></a>
DATA</h1>
<h2><a class="anchor" id="autotoc_md209"></a>
Offset: 0x14  I2C DATA Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]   </td><td class="markdownTableBodyCenter">DATA   </td><td class="markdownTableBodyLeft">I2C Data Bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The DATA contains a byte of serial data to be transmitted or a byte which has just been received.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l05004">5004</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gac492ca9fe4d8ec74273c1e1a5e783316" name="gac492ca9fe4d8ec74273c1e1a5e783316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac492ca9fe4d8ec74273c1e1a5e783316">&#9670;&nbsp;</a></span>DATA0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t PWM_T::DATA0</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md262"></a>
DATA0</h1>
<h2><a class="anchor" id="autotoc_md263"></a>
Offset: 0x20  PWM Data Register 0</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">DATA   </td><td class="markdownTableBodyLeft">PWM Data Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">User can monitor PWM_DATA to know the current value in 16-bit down count counter of corresponding channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[30:16]   </td><td class="markdownTableBodyCenter">DATA_H   </td><td class="markdownTableBodyLeft">PWM Data Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">User can monitor PWM_DATA to know the current value in 32-bit down count counter of corresponding channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Notes: This will be valid only for the corresponding cascade enable bit is set    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[31]   </td><td class="markdownTableBodyCenter">sync   </td><td class="markdownTableBodyLeft">CN Value Sync With PWM Counter    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = CN value is sync to PWM counter.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = CN value is not sync to PWM counter.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: when the corresponding cascade enable bit is set, this bit will not appear in the corresponding channel   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l05995">5995</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga9db243709384d923303b4750e8593015" name="ga9db243709384d923303b4750e8593015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9db243709384d923303b4750e8593015">&#9670;&nbsp;</a></span>DATA1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t PWM_T::DATA1</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md266"></a>
DATA1</h1>
<h2><a class="anchor" id="autotoc_md267"></a>
Offset: 0x2C  PWM Data Register 1</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">DATA   </td><td class="markdownTableBodyLeft">PWM Data Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">User can monitor PWM_DATA to know the current value in 16-bit down count counter of corresponding channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[30:16]   </td><td class="markdownTableBodyCenter">DATA_H   </td><td class="markdownTableBodyLeft">PWM Data Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">User can monitor PWM_DATA to know the current value in 32-bit down count counter of corresponding channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Notes: This will be valid only for the corresponding cascade enable bit is set    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[31]   </td><td class="markdownTableBodyCenter">sync   </td><td class="markdownTableBodyLeft">CN Value Sync With PWM Counter    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = CN value is sync to PWM counter.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = CN value is not sync to PWM counter.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: when the corresponding cascade enable bit is set, this bit will not appear in the corresponding channel   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l06060">6060</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaf13cceaac2f36d56edf9a4e568056b22" name="gaf13cceaac2f36d56edf9a4e568056b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf13cceaac2f36d56edf9a4e568056b22">&#9670;&nbsp;</a></span>DATA2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t PWM_T::DATA2</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md270"></a>
DATA2</h1>
<h2><a class="anchor" id="autotoc_md271"></a>
Offset: 0x38  PWM Data Register 2</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">DATA   </td><td class="markdownTableBodyLeft">PWM Data Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">User can monitor PWM_DATA to know the current value in 16-bit down count counter of corresponding channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[30:16]   </td><td class="markdownTableBodyCenter">DATA_H   </td><td class="markdownTableBodyLeft">PWM Data Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">User can monitor PWM_DATA to know the current value in 32-bit down count counter of corresponding channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Notes: This will be valid only for the corresponding cascade enable bit is set    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[31]   </td><td class="markdownTableBodyCenter">sync   </td><td class="markdownTableBodyLeft">CN Value Sync With PWM Counter    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = CN value is sync to PWM counter.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = CN value is not sync to PWM counter.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: when the corresponding cascade enable bit is set, this bit will not appear in the corresponding channel   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l06125">6125</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaff8373e6eafa04a9b75ffc36188fffca" name="gaff8373e6eafa04a9b75ffc36188fffca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff8373e6eafa04a9b75ffc36188fffca">&#9670;&nbsp;</a></span>DATA3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t PWM_T::DATA3</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md274"></a>
DATA3</h1>
<h2><a class="anchor" id="autotoc_md275"></a>
Offset: 0x44  PWM Data Register 3</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">DATA   </td><td class="markdownTableBodyLeft">PWM Data Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">User can monitor PWM_DATA to know the current value in 16-bit down count counter of corresponding channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[30:16]   </td><td class="markdownTableBodyCenter">DATA_H   </td><td class="markdownTableBodyLeft">PWM Data Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">User can monitor PWM_DATA to know the current value in 32-bit down count counter of corresponding channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Notes: This will be valid only for the corresponding cascade enable bit is set    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[31]   </td><td class="markdownTableBodyCenter">sync   </td><td class="markdownTableBodyLeft">CN Value Sync With PWM Counter    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = CN value is sync to PWM counter.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = CN value is not sync to PWM counter.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: when the corresponding cascade enable bit is set, this bit will not appear in the corresponding channel   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l06190">6190</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gad3d4810bebd87d723aa1c2553576bc95" name="gad3d4810bebd87d723aa1c2553576bc95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3d4810bebd87d723aa1c2553576bc95">&#9670;&nbsp;</a></span>DBEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t GPIO_T::DBEN</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md186"></a>
DBEN</h1>
<h2><a class="anchor" id="autotoc_md187"></a>
Offset: 0x14  GPIO Port De-bounce Enable Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">DBEN   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Input Signal De-Bounce Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">DBEN[n] used to enable the de-bounce function for each corresponding bit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle the input signal transition is seen as the signal bounce and will not trigger the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The GPIO port [x] Pin [n] input signal de-bounce function is disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The GPIO port [x] Pin [n] input signal de-bounce function is enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The de-bounce function is valid for edge triggered interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt mode is level triggered, the de-bounce enable bit is ignored.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_DBEN, bits [15:6] are reserved.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l04294">4294</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga0c3a42efc127d5d543a646cac4861e34" name="ga0c3a42efc127d5d543a646cac4861e34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c3a42efc127d5d543a646cac4861e34">&#9670;&nbsp;</a></span>DBNCECON</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t GP_DB_T::DBNCECON</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md196"></a>
DBNCECON</h1>
<h2><a class="anchor" id="autotoc_md197"></a>
Offset: 0x180  De-bounce Cycle Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3:0]   </td><td class="markdownTableBodyCenter">DBCLKSEL   </td><td class="markdownTableBodyLeft">De-Bounce Sampling Cycle Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = Sample interrupt input once per 1 clock.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0001 = Sample interrupt input once per 2 clocks.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0010 = Sample interrupt input once per 4 clocks.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0011 = Sample interrupt input once per 8 clocks.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0100 = Sample interrupt input once per 16 clocks.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0101 = Sample interrupt input once per 32 clocks.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0110 = Sample interrupt input once per 64 clocks.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0111 = Sample interrupt input once per 128 clocks.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = Sample interrupt input once per 256 clocks.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1001 = Sample interrupt input once per 2*256 clocks.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1010 = Sample interrupt input once per 4*256clocks.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1011 = Sample interrupt input once per 8*256 clocks.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1100 = Sample interrupt input once per 16*256 clocks.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1101 = Sample interrupt input once per 32*256 clocks.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1110 = Sample interrupt input once per 64*256 clocks.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1111 = Sample interrupt input once per 128*256 clocks.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">DBCLKSRC   </td><td class="markdownTableBodyLeft">De-Bounce Counter Clock Source Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = De-bounce counter Clock Source is the HCLK.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = De-bounce counter Clock Source is the internal 10 kHz clock.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">DBCLK_ON   </td><td class="markdownTableBodyLeft">De-Bounce Clock Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit controls if the de-bounce clock is enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">However, if GPI/O pin's interrupt is enabled, the de-bounce clock will be enabled automatically no matter what the DBCLK_ON value is.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If CPU is in sleep mode, this bit didn't take effect.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">And only the GPI/O pin with interrupt enable could get de-bounce clock.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = De-bounce clock Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = De-bounce clock Enabled.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l04688">4688</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga6f8433cf17517dba01cee3cbd65f4e63" name="ga6f8433cf17517dba01cee3cbd65f4e63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f8433cf17517dba01cee3cbd65f4e63">&#9670;&nbsp;</a></span>DFBADR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t FMC_T::DFBADR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md122"></a>
DFBADR</h1>
<h2><a class="anchor" id="autotoc_md123"></a>
Offset: 0x14  Data Flash Base Address Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]   </td><td class="markdownTableBodyCenter">DFBADR   </td><td class="markdownTableBodyLeft">Data Flash Base Address    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This register indicates data flash start address. It is a read only register.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The data flash start address is defined by user.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Since on chip flash erase unit is 512 bytes, it is mandatory to keep bit 8-0 as 0.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l02581">2581</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga4faaa1d0245b10a054375cb0a45bf33c" name="ga4faaa1d0245b10a054375cb0a45bf33c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4faaa1d0245b10a054375cb0a45bf33c">&#9670;&nbsp;</a></span>DISPCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t LCD_T::DISPCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md224"></a>
DISPCTL</h1>
<h2><a class="anchor" id="autotoc_md225"></a>
Offset: 0x04  LCD Display Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">CPUMP_EN   </td><td class="markdownTableBodyLeft">Charge Pump Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2:1]   </td><td class="markdownTableBodyCenter">BIAS_SEL   </td><td class="markdownTableBodyLeft">Bias Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Static.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = 1/2 Bias.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = 1/3 Bias.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">IBRL_EN   </td><td class="markdownTableBodyLeft">Internal Bias Reference Ladder Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Bias reference ladder Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Bias reference ladder Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">BV_SEL   </td><td class="markdownTableBodyLeft">Bias Voltage Type Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = C-Type bias mode. Bias voltage source from internal bias generator.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = R-Type bias mode. Bias voltage source from external bias generator.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: The external resistor ladder should be connected to the V1 pin, V2 pin, V3 pin and VSS.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The VLCD pin should also be connected to VDD.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[10:8]   </td><td class="markdownTableBodyCenter">CPUMP_VOL_SET   </td><td class="markdownTableBodyLeft">Charge Pump Voltage Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">000 = 2.7V.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">001 = 2.8V.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">010 = 2.9V.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">011 = 3.0V.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">100 = 3.1V.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">101 = 3.2V.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">110 = 3.3V.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">111 = 3.4V.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[13:11]   </td><td class="markdownTableBodyCenter">CPUMP_FREQ   </td><td class="markdownTableBodyLeft">Charge Pump Frequency Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">000 = LCD_CLK.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">001 = LCD_CLK/2.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">010 = LCD_CLK/4.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">011 = LCD_CLK/8.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">100 = LCD_CLK/16.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">101 = LCD_CLK/32.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">110 = LCD_CLK/64.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">111 = LCD_CLK/128.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">Ext_C   </td><td class="markdownTableBodyLeft">Ext_C Mode Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This mode is similar to C-type LCD mode, but the operation current is lower than C-type mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The control register setting is same with C-type mode except this bit is set to "1".    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disable.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enable.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[18:17]   </td><td class="markdownTableBodyCenter">Res_Sel   </td><td class="markdownTableBodyLeft">R-Type Resistor Value Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The LCD operation current will be different when we select different R-type resistor value.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = 200K Ohm.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = 300K Ohm.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = 400K Ohm.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l05343">5343</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gab20c783148e5e679d8da4415cfad85b2" name="gab20c783148e5e679d8da4415cfad85b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab20c783148e5e679d8da4415cfad85b2">&#9670;&nbsp;</a></span>DIV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t I2C_T::DIV</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md204"></a>
DIV</h1>
<h2><a class="anchor" id="autotoc_md205"></a>
Offset: 0x0C  I2C clock divided Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]   </td><td class="markdownTableBodyCenter">CLK_DIV   </td><td class="markdownTableBodyLeft">I2C Clock Divided Bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The I2C clock rate bits: Data Baud Rate of I2C = PCLK /( 4 x ( CLK_DIV + 1)).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: the minimum value of CLK_DIV is 4.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l04973">4973</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaf7a436021c5a67252e0ae2e95d9ef9e4" name="gaf7a436021c5a67252e0ae2e95d9ef9e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7a436021c5a67252e0ae2e95d9ef9e4">&#9670;&nbsp;</a></span>DMA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SPI_T::DMA</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md388"></a>
DMA</h1>
<h2><a class="anchor" id="autotoc_md389"></a>
Offset: 0x38  SPI DMA Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">TX_DMA_EN   </td><td class="markdownTableBodyLeft">Transmit PDMA Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Transmit PDMA function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Transmit PDMA function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: Two transaction need minimal 18 APB clock + 8 SPI peripheral clocks suspend interval in master mode for edge mode and 18 APB clock + 9.5 SPI peripheral clocks for level mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: If the 2-bit function is enabled, the requirement timing shall append 18 APB clock based on the above clock period.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Hardware will clear this bit to 0 automatically after PDMA transfer done.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">RX_DMA_EN   </td><td class="markdownTableBodyLeft">Receiving PDMA Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Receiver PDMA function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Receiver PDMA function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Hardware will clear this bit to 0 automatically after PDMA transfer done.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In Slave mode and the FIFO bit is disabled, if the receive PDMA is enabled but the transmit PDMA is disabled, the minimal suspend interval between two successive transactions input is need to be larger than 9 SPI peripheral clock + 4 APB clock for edge mode and 9.5 SPI peripheral clock + 4 APB clock    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">PDMA_RST   </td><td class="markdownTableBodyLeft">PDMA Reset    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It is used to reset the SPI PDMA function into default state.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = After reset PDMA function or in normal operation.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Reset PDMA function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: it is auto cleared to "0" after the reset function has done.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l08804">8804</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaee2cc59012292dead10fff18f43ef71e" name="gaee2cc59012292dead10fff18f43ef71e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee2cc59012292dead10fff18f43ef71e">&#9670;&nbsp;</a></span>DMABCR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t DMA_CRC_T::DMABCR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md68"></a>
DMABCR</h1>
<h2><a class="anchor" id="autotoc_md69"></a>
Offset: 0x0C  DMA CRC Transfer Byte Count Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CRC_DMABCR   </td><td class="markdownTableBodyLeft">CRC DMA Transfer Byte Count Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field indicates a 16-bit transfer byte count number of CRC DMA   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l01803">1803</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga95f060935bd6cca5c51615de894f40f6" name="ga95f060935bd6cca5c51615de894f40f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95f060935bd6cca5c51615de894f40f6">&#9670;&nbsp;</a></span>DMACBCR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t DMA_CRC_T::DMACBCR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md72"></a>
DMACBCR</h1>
<h2><a class="anchor" id="autotoc_md73"></a>
Offset: 0x1C  DMA CRC Current Transfer Byte Count Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CRC_DMACBCR   </td><td class="markdownTableBodyLeft">CRC DMA Current Byte Count Register (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field indicates the current remained byte count of CRC_DMA.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: CRC_RST will clear this register value.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l01832">1832</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga7cf62f0df806c2ea48766d2643954acb" name="ga7cf62f0df806c2ea48766d2643954acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cf62f0df806c2ea48766d2643954acb">&#9670;&nbsp;</a></span>DMACSAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t DMA_CRC_T::DMACSAR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md70"></a>
DMACSAR</h1>
<h2><a class="anchor" id="autotoc_md71"></a>
Offset: 0x14  DMA CRC Current Source Address Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]   </td><td class="markdownTableBodyCenter">CRC_DMACSAR   </td><td class="markdownTableBodyLeft">CRC DMA Current Source Address Register (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field indicates the source address where the CRC DMA transfer is just occurring.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l01817">1817</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gad8d725245a81746f9d034d1c4242cd82" name="gad8d725245a81746f9d034d1c4242cd82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8d725245a81746f9d034d1c4242cd82">&#9670;&nbsp;</a></span>DMAIER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t DMA_CRC_T::DMAIER</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md74"></a>
DMAIER</h1>
<h2><a class="anchor" id="autotoc_md75"></a>
Offset: 0x20  DMA CRC Interrupt Enable Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">TABORT_IE   </td><td class="markdownTableBodyLeft">CRC DMA Read/Write Target Abort Interrupt Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Target abort interrupt generation Disabled during CRC DMA transfer.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Target abort interrupt generation Enabled during CRC DMA transfer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">BLKD_IE   </td><td class="markdownTableBodyLeft">CRC DMA Transfer Done Interrupt Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Interrupt generator Disabled during CRC DMA transfer done.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Interrupt generator Enabled during CRC DMA transfer done.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l01848">1848</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaeb314f9a25f38e16be8be0a3178a44a8" name="gaeb314f9a25f38e16be8be0a3178a44a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb314f9a25f38e16be8be0a3178a44a8">&#9670;&nbsp;</a></span>DMAISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t DMA_CRC_T::DMAISR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md76"></a>
DMAISR</h1>
<h2><a class="anchor" id="autotoc_md77"></a>
Offset: 0x24  DMA CRC Interrupt Status Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">TABORT_IF   </td><td class="markdownTableBodyLeft">CRC DMA Read/Write Target Abort Interrupt Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No bus ERROR response received.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Bus ERROR response received.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Software can write 1 to clear this bit to zero    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: The CRC_DMAISR [TABORT_IF] indicate bus master received ERROR response or not.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If bus master received ERROR response, it means that target abort is happened.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">DMA will stop transfer and respond this event to software then go to IDLE state.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When target abort occurred, software must reset DMA, and then transfer those data again.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">BLKD_IF   </td><td class="markdownTableBodyLeft">Block Transfer Done Interrupt Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates that CRC DMA has finished all transfer.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Not finished yet.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Done.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Software can write 1 to clear this bit to zero   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l01871">1871</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaa8c41cb44a1921f97ba4b8ab5230e0ad" name="gaa8c41cb44a1921f97ba4b8ab5230e0ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8c41cb44a1921f97ba4b8ab5230e0ad">&#9670;&nbsp;</a></span>DMASAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t DMA_CRC_T::DMASAR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md66"></a>
DMASAR</h1>
<h2><a class="anchor" id="autotoc_md67"></a>
Offset: 0x04  DMA CRC Source Address Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]   </td><td class="markdownTableBodyCenter">CRC_DMASAR   </td><td class="markdownTableBodyLeft">CRC DMA Transfer Source Address Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field indicates a 32-bit source address of CRC DMA.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note : The source address must be word alignment   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l01789">1789</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga5d1418a8fdc087ba44028f784cbd2ea2" name="ga5d1418a8fdc087ba44028f784cbd2ea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d1418a8fdc087ba44028f784cbd2ea2">&#9670;&nbsp;</a></span>DMASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t GPIO_T::DMASK</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md182"></a>
DMASK</h1>
<h2><a class="anchor" id="autotoc_md183"></a>
Offset: 0x0C  GPIO Port Data Output Write Mask Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">DMASK   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Data Output Write Mask    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">These bits are used to protect the corresponding register of GPIOx_DOUT bit [n].    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When set the DMASK[n] to "1", the corresponding DOUT[n] bit is protected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The write signal is masked, write data to the protect bit is ignored.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The corresponding GPIO_DOUT bit [n] can be updated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The corresponding GPIO_DOUT bit [n] is protected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_DMASK, bits [15:6] are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: These mask bits only take effect while CPU is doing write operation to register GPIOx_DOUT.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If CPU is doing write operation to register GPIO[x][n], these mask bits will not take effect.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l04262">4262</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gacedf474a76d41eb49d93ca976fa0afa4" name="gacedf474a76d41eb49d93ca976fa0afa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacedf474a76d41eb49d93ca976fa0afa4">&#9670;&nbsp;</a></span>DOUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t GPIO_T::DOUT</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md180"></a>
DOUT</h1>
<h2><a class="anchor" id="autotoc_md181"></a>
Offset: 0x08  GPIO Port Data Output Value Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">DOUT   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Output Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Each of these bits controls the status of a GPIO port [x] pin [n] when the GPI/O pin is configures as output or open-drain mode    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = GPIO port [x] Pin [n] will drive Low if the corresponding output mode enabling bit is set.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = GPIO port [x] Pin [n] will drive High if the corresponding output mode enabling bit is set.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_DOUT, bits [15:6] are reserved.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l04243">4243</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga7f5ea6a1af3b26e732ffec08d4d519f5" name="ga7f5ea6a1af3b26e732ffec08d4d519f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f5ea6a1af3b26e732ffec08d4d519f5">&#9670;&nbsp;</a></span>DR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t TIMER_T::DR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md402"></a>
DR</h1>
<h2><a class="anchor" id="autotoc_md403"></a>
Offset: 0x14  Timer 0 Data Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23:0]   </td><td class="markdownTableBodyCenter">TDR   </td><td class="markdownTableBodyLeft">Timer Data Register (Read)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">User can read this register for internal 24-bit timer up-counter value.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Counter Reset (Write)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">User can write any value to this register to reset internal 24-bit timer up-counter and 8-bit pre-scale counter.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This reset operation wouldn't affect any other timer control registers and circuit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">After reset completed, the 24-bit timer up-counter and 8-bit pre-scale counter restart the counting based on the TMRx_CTL register setting.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31]   </td><td class="markdownTableBodyCenter">RSTACT   </td><td class="markdownTableBodyLeft">Reset Active    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates if the counter reset operation active.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When user write this register, timer starts to reset its internal 24-bit timer up-counter and 8-bit pre-scale counter to 0.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In the same time, timer set this flag to 1 to indicate the counter reset operation is in progress.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Once the counter reset operation done, timer clear this bit to 0 automatically.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Reset operation done.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Reset operation triggered by writing TMR_DR is in progress.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only. Write operation wouldn't take any effect.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l09287">9287</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga314f75fa91026439282e77423ac2f830" name="ga314f75fa91026439282e77423ac2f830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga314f75fa91026439282e77423ac2f830">&#9670;&nbsp;</a></span>DSSR0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t DMA_GCR_T::DSSR0</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md86"></a>
DSSR0</h1>
<h2><a class="anchor" id="autotoc_md87"></a>
Offset: 0x04  DMA Service Selection Control Register 0</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[12:8]   </td><td class="markdownTableBodyCenter">CH1_SEL   </td><td class="markdownTableBodyLeft">Channel 1 Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This filed defines which peripheral is connected to PDMA channel 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">User can configure the peripheral by setting CH1_SEL.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00000 = Connect to SPI0_TX.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00001 = Connect to SPI1_TX.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00010 = Connect to UART0_TX.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00011 = Connect to UART1_TX.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00100 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00101 = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00110 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00111 = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01000 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01001 = Connect to TMR0.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01010 = Connect to TMR1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01011 = Connect to TMR2.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01100 = Connect to TMR3.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10000 = Connect to SPI0_RX.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10001 = Connect to SPI1_RX.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10010 = Connect to UART0_RX.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10011 = Connect to UART1_RX.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10100 = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10101 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10110 = Connect to ADC.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10111 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11000 = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11001 = Connect to PWM0_CH0.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11010 = Connect to PWM0_CH2.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11011 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11100 = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others = Disable to connected any peripheral.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[20:16]   </td><td class="markdownTableBodyCenter">CH2_SEL   </td><td class="markdownTableBodyLeft">Channel 2 Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This filed defines which peripheral is connected to PDMA channel 2.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">User can configure the peripheral setting by CH2_SEL.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The channel configuration is the same as CH1_SEL field.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Please refer to the explanation of CH1_SEL.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[28:24]   </td><td class="markdownTableBodyCenter">CH3_SEL   </td><td class="markdownTableBodyLeft">Channel 3 Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This filed defines which peripheral is connected to PDMA channel 3.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">User can configure the peripheral setting by CH3_SEL.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The channel configuration is the same as CH1_SEL field.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Please refer to the explanation of CH1_SEL.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l01994">1994</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga2e2b0f6d1c0549073bf2f1c4261b851b" name="ga2e2b0f6d1c0549073bf2f1c4261b851b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e2b0f6d1c0549073bf2f1c4261b851b">&#9670;&nbsp;</a></span>DSSR1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t DMA_GCR_T::DSSR1</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md88"></a>
DSSR1</h1>
<h2><a class="anchor" id="autotoc_md89"></a>
Offset: 0x08  DMA Service Selection Control Register 1</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4:0]   </td><td class="markdownTableBodyCenter">CH4_SEL   </td><td class="markdownTableBodyLeft">Channel 4 Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This filed defines which peripheral is connected to PDMA channel 4.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">User can configure the peripheral by setting CH4_SEL.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00000 = Connect to SPI0_TX.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00001 = Connect to SPI1_TX.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00010 = Connect to UART0_TX.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00011 = Connect to UART1_TX.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00100 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00101 = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00110 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00111 = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01000 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01001 = Connect to TMR0.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01010 = Connect to TMR1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01011 = Connect to TMR2.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01100 = Connect to TMR3.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10000 = Connect to SPI0_RX.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10001 = Connect to SPI1_RX.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10010 = Connect to UART0_RX.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10011 = Connect to UART1_RX.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10100 = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10101 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10110 = Connect to ADC.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10111 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11000 = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11001 = Connect to PWM0_CH0.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11010 = Connect to PWM0_CH2.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11011 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11100 = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others = Disable to connected any peripheral.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l02034">2034</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga1e445593e42699eb743ebe6ded0d416e" name="ga1e445593e42699eb743ebe6ded0d416e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e445593e42699eb743ebe6ded0d416e">&#9670;&nbsp;</a></span>DUTY0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::DUTY0</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md260"></a>
DUTY0</h1>
<h2><a class="anchor" id="autotoc_md261"></a>
Offset: 0x1C  PWM Counter/Comparator Register 0</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CN   </td><td class="markdownTableBodyLeft">PWM Counter/Timer Loaded Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CN determines the PWM period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In edge-aligned mode,    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = PWMxy_CLK/(prescale+1)*(clock divider)/(CN+1); where xy could be 01, 23, depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CM+1)/(CN+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM &gt;= CN: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM &lt; CN: PWM low width = (CN-CM) unit; PWM high width = (CM+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM = 0: PWM low width = (CN) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = one PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In center-aligned mode,    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = PWMxy_CLK/(prescale+1)*(clock divider)/(2x(CN+1)); where xy could be 01, 23, depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (2xCM+1)/(2x(CN+1)).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM &gt;= CN: PWM output is always high.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM &lt; CN: PWM low width = 2x(CN-CM)+1 unit; PWM high width = (2xCM+1) unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM = 0: PWM low width = (2xCN+1) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = one PWM clock cycle).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CN will take effect in next PWM cycle.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CM   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM determines the PWM duty.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In edge-aligned mode,    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = PWMxy_CLK/(prescale+1)*(clock divider)/(CN+1); where xy could be 01, 23, depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CM+1)/(CN+1).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM &gt;= CN: PWM output is always high.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM &lt; CN: PWM low width = (CN-CM) unit; PWM high width = (CM+1) unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM = 0: PWM low width = (CN) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = one PWM clock cycle).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In center-aligned mode,    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = PWMxy_CLK/(prescale+1)*(clock divider)/(2x(CN+1)); where xy could be 01, 23, depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (2xCM+1)/(2x(CN+1)).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM &gt;= CN: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM &lt; CN: PWM low width = 2x(CN-CM)+1 unit; PWM high width = (2xCM+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM = 0: PWM low width = (2xCN+1) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = one PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:Any write to CM will take effect in next PWM cycle.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l05976">5976</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga15e419d84971c3dd1a5e11672102f8d3" name="ga15e419d84971c3dd1a5e11672102f8d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15e419d84971c3dd1a5e11672102f8d3">&#9670;&nbsp;</a></span>DUTY1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::DUTY1</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md264"></a>
DUTY1</h1>
<h2><a class="anchor" id="autotoc_md265"></a>
Offset: 0x28  PWM Counter/Comparator Register 1</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CN   </td><td class="markdownTableBodyLeft">PWM Counter/Timer Loaded Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CN determines the PWM period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In edge-aligned mode,    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = PWMxy_CLK/(prescale+1)*(clock divider)/(CN+1); where xy could be 01, 23, depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CM+1)/(CN+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM &gt;= CN: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM &lt; CN: PWM low width = (CN-CM) unit; PWM high width = (CM+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM = 0: PWM low width = (CN) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = one PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In center-aligned mode,    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = PWMxy_CLK/(prescale+1)*(clock divider)/(2x(CN+1)); where xy could be 01, 23, depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (2xCM+1)/(2x(CN+1)).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM &gt;= CN: PWM output is always high.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM &lt; CN: PWM low width = 2x(CN-CM)+1 unit; PWM high width = (2xCM+1) unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM = 0: PWM low width = (2xCN+1) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = one PWM clock cycle).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CN will take effect in next PWM cycle.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CM   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM determines the PWM duty.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In edge-aligned mode,    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = PWMxy_CLK/(prescale+1)*(clock divider)/(CN+1); where xy could be 01, 23, depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CM+1)/(CN+1).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM &gt;= CN: PWM output is always high.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM &lt; CN: PWM low width = (CN-CM) unit; PWM high width = (CM+1) unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM = 0: PWM low width = (CN) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = one PWM clock cycle).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In center-aligned mode,    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = PWMxy_CLK/(prescale+1)*(clock divider)/(2x(CN+1)); where xy could be 01, 23, depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (2xCM+1)/(2x(CN+1)).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM &gt;= CN: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM &lt; CN: PWM low width = 2x(CN-CM)+1 unit; PWM high width = (2xCM+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM = 0: PWM low width = (2xCN+1) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = one PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:Any write to CM will take effect in next PWM cycle.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l06041">6041</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gad6147d61adbaeeda64cb1b628d74e771" name="gad6147d61adbaeeda64cb1b628d74e771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6147d61adbaeeda64cb1b628d74e771">&#9670;&nbsp;</a></span>DUTY2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::DUTY2</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md268"></a>
DUTY2</h1>
<h2><a class="anchor" id="autotoc_md269"></a>
Offset: 0x34  PWM Counter/Comparator Register 2</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CN   </td><td class="markdownTableBodyLeft">PWM Counter/Timer Loaded Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CN determines the PWM period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In edge-aligned mode,    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = PWMxy_CLK/(prescale+1)*(clock divider)/(CN+1); where xy could be 01, 23, depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CM+1)/(CN+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM &gt;= CN: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM &lt; CN: PWM low width = (CN-CM) unit; PWM high width = (CM+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM = 0: PWM low width = (CN) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = one PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In center-aligned mode,    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = PWMxy_CLK/(prescale+1)*(clock divider)/(2x(CN+1)); where xy could be 01, 23, depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (2xCM+1)/(2x(CN+1)).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM &gt;= CN: PWM output is always high.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM &lt; CN: PWM low width = 2x(CN-CM)+1 unit; PWM high width = (2xCM+1) unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM = 0: PWM low width = (2xCN+1) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = one PWM clock cycle).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CN will take effect in next PWM cycle.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CM   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM determines the PWM duty.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In edge-aligned mode,    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = PWMxy_CLK/(prescale+1)*(clock divider)/(CN+1); where xy could be 01, 23, depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CM+1)/(CN+1).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM &gt;= CN: PWM output is always high.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM &lt; CN: PWM low width = (CN-CM) unit; PWM high width = (CM+1) unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM = 0: PWM low width = (CN) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = one PWM clock cycle).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In center-aligned mode,    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = PWMxy_CLK/(prescale+1)*(clock divider)/(2x(CN+1)); where xy could be 01, 23, depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (2xCM+1)/(2x(CN+1)).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM &gt;= CN: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM &lt; CN: PWM low width = 2x(CN-CM)+1 unit; PWM high width = (2xCM+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM = 0: PWM low width = (2xCN+1) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = one PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:Any write to CM will take effect in next PWM cycle.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l06106">6106</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga98e5ffc188d1b543dc3cbe0557100aba" name="ga98e5ffc188d1b543dc3cbe0557100aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98e5ffc188d1b543dc3cbe0557100aba">&#9670;&nbsp;</a></span>DUTY3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::DUTY3</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md272"></a>
DUTY3</h1>
<h2><a class="anchor" id="autotoc_md273"></a>
Offset: 0x40  PWM Counter/Comparator Register 3</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CN   </td><td class="markdownTableBodyLeft">PWM Counter/Timer Loaded Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CN determines the PWM period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In edge-aligned mode,    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = PWMxy_CLK/(prescale+1)*(clock divider)/(CN+1); where xy could be 01, 23, depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CM+1)/(CN+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM &gt;= CN: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM &lt; CN: PWM low width = (CN-CM) unit; PWM high width = (CM+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM = 0: PWM low width = (CN) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = one PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In center-aligned mode,    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = PWMxy_CLK/(prescale+1)*(clock divider)/(2x(CN+1)); where xy could be 01, 23, depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (2xCM+1)/(2x(CN+1)).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM &gt;= CN: PWM output is always high.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM &lt; CN: PWM low width = 2x(CN-CM)+1 unit; PWM high width = (2xCM+1) unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM = 0: PWM low width = (2xCN+1) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = one PWM clock cycle).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CN will take effect in next PWM cycle.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CM   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM determines the PWM duty.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In edge-aligned mode,    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = PWMxy_CLK/(prescale+1)*(clock divider)/(CN+1); where xy could be 01, 23, depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CM+1)/(CN+1).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM &gt;= CN: PWM output is always high.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM &lt; CN: PWM low width = (CN-CM) unit; PWM high width = (CM+1) unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM = 0: PWM low width = (CN) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = one PWM clock cycle).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In center-aligned mode,    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = PWMxy_CLK/(prescale+1)*(clock divider)/(2x(CN+1)); where xy could be 01, 23, depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (2xCM+1)/(2x(CN+1)).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM &gt;= CN: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM &lt; CN: PWM low width = 2x(CN-CM)+1 unit; PWM high width = (2xCM+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CM = 0: PWM low width = (2xCN+1) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = one PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:Any write to CM will take effect in next PWM cycle.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l06171">6171</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gac4a7833299d2b3a61dc3d46dbe69c610" name="gac4a7833299d2b3a61dc3d46dbe69c610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4a7833299d2b3a61dc3d46dbe69c610">&#9670;&nbsp;</a></span>DWR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t RTC_T::DWR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md318"></a>
DWR</h1>
<h2><a class="anchor" id="autotoc_md319"></a>
Offset: 0x18  Day of the Week Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2:0]   </td><td class="markdownTableBodyCenter">DWR   </td><td class="markdownTableBodyLeft">Day Of The Week Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">000 = Sunday.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">001 = Monday.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">010 = Tuesday.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">011 = Wednesday.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">100 = Thursday.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">101 = Friday.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">110 = Saturday.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l07184">7184</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaf6e91877db4ad3b35116bbd1c281bda6" name="gaf6e91877db4ad3b35116bbd1c281bda6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6e91877db4ad3b35116bbd1c281bda6">&#9670;&nbsp;</a></span>ECTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t TIMER_T::ECTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md406"></a>
ECTL</h1>
<h2><a class="anchor" id="autotoc_md407"></a>
Offset: 0x20  Timer x Extended Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">EVNT_GEN_EN   </td><td class="markdownTableBodyLeft">Event Generator Function Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When this bit is high, timer would generate a high pulse event out when it increases the 24-bit up counter and the polarity of signal defined by EVNT_GEN_SRC (TMRx_ECTL[12]) is same as the polarity defined by EVNT_GEN_POL (TMRx_ECTL[1]).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Event generator function disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Event generator function enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">EVNT_GEN_POL   </td><td class="markdownTableBodyLeft">Event Generator Reference Input Source Polarity Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When this bit is low and EVNT_GEN_EN (TMRx_ECTL[0]) is high, timer would generate a high pulse event out when it increases the 24-bit up counter and the polarity of signal defined by EVNT_GEN_SRC (TMRx_ECTL[12]) is low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When this bit is high and EVNT_GEN_EN (TMRx_ECTL[0]) is high, timer would generate a low pulse event pulse out when it increases the 24-bit up counter and the polarity of signal defined by EVNT_GEN_SRC (TMRx_ECTL[12]) is high.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit only affects timer's operation when EVNT_GEN_EN (TMRx_ECTL[0]) is high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Timer generates a high pulse event out when it increase the 24-bit up counter and the polarity of signal defined by EVNT_GEN_SRC (TMRx_ECTL[12]) is low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Timer generates a high pulse event out when it increase the 24-bit up counter and the polarity of signal defined by EVNT_GEN_SRC (TMRx_ECTL[12]) is high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">EVNT_CNT_SRC   </td><td class="markdownTableBodyLeft">Event Counting Source Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit defines the TMRx+1 event counting source is from external event pin TMx+1 or internal signal from TMRx's event generator output (where x = 0 or 2).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The event counting source is from external event pin.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The event counting source is from TMRx's event generator output.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is only available in TMRx+1 (where x = 0 or 2).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[12]   </td><td class="markdownTableBodyCenter">EVNT_GEN_SRC   </td><td class="markdownTableBodyLeft">Event Generator Reference Input Source Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit defines the event generator function controlled by external event pin or internal event signals from ACMP0.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The event generator reference source is from external event pin.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The event generator reference source is from ACMP0.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is only available in TMRx (where x = 0 or 2).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">CAP_SRC   </td><td class="markdownTableBodyLeft">Capture Function Source Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit defines timer counter reset function or timer capture function controlled by transition of TC pin or transition of internal signals from other functional blocks of this chip.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Transition of TC pin selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Transition of internal signals from ACMP0.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When this bit is high, the EVNT_DEB_EN (TMRx_CTL[14]) would not take effect.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[31:24]   </td><td class="markdownTableBodyCenter">EVNT_DROP_CNT   </td><td class="markdownTableBodyLeft">Event Drop Count    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field indicates timer to drop how many events after inter-timer trigger function enable.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For example, if user writes 0x7 to this field, timer would drop 7 first incoming events and starts the inter-timer trigger operation when it get 8th event.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field would affect timer's operation only when inter-timer trigger function enabled (INTR_TRG_EN (TMRx_CTL[24]) = 1) and ITNR_TRG_MODE (TMRx_CTL[25]) = 1.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l09343">9343</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga34a0768b1f83a855a84af99cfe1939fd" name="ga34a0768b1f83a855a84af99cfe1939fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34a0768b1f83a855a84af99cfe1939fd">&#9670;&nbsp;</a></span>EGTR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SC_T::EGTR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md340"></a>
EGTR</h1>
<h2><a class="anchor" id="autotoc_md341"></a>
Offset: 0x0C  SC Extend Guard Time Register.</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]   </td><td class="markdownTableBodyCenter">EGT   </td><td class="markdownTableBodyLeft">Extended Guard Time    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field indicates the extended guard timer value.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: The counter is ETU based and the real extended guard time is EGT.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l07761">7761</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga45c091e2ae29b2e35d20f989adc427a2" name="ga45c091e2ae29b2e35d20f989adc427a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45c091e2ae29b2e35d20f989adc427a2">&#9670;&nbsp;</a></span>ETUCR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SC_T::ETUCR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md344"></a>
ETUCR</h1>
<h2><a class="anchor" id="autotoc_md345"></a>
Offset: 0x14  SC ETU Control Register.</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[11:0]   </td><td class="markdownTableBodyCenter">ETU_RDIV   </td><td class="markdownTableBodyLeft">ETU Rate Divider    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The field indicates the clock rate divider.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The real ETU is ETU_RDIV + 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: Software can configure this field, but this field must be greater than 0x04.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: Software can configure this field, but if the error rate is equal to 2%, this field must be greater than 0x040.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[15]   </td><td class="markdownTableBodyCenter">COMPEN_EN   </td><td class="markdownTableBodyLeft">Compensation Mode Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit enables clock compensation function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When this bit enabled, hardware will alternate between n clock cycles and (n-1) clock cycles, where n is the value to be written into the ETU_RDIV register.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Compensation function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Compensation function Enabled.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l07796">7796</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga54f4a365cae899c3df7a6916da301e84" name="ga54f4a365cae899c3df7a6916da301e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54f4a365cae899c3df7a6916da301e84">&#9670;&nbsp;</a></span>FCR <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t LCD_T::FCR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md244"></a>
FCR</h1>
<h2><a class="anchor" id="autotoc_md245"></a>
Offset: 0x30  LCD frame counter control register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">FCEN   </td><td class="markdownTableBodyLeft">LCD Frame Counter Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">FCINTEN   </td><td class="markdownTableBodyLeft">LCD Frame Counter Interrupt Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Frame counter interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Frame counter interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3:2]   </td><td class="markdownTableBodyCenter">PRESCL   </td><td class="markdownTableBodyLeft">Frame Counter Pre-Scaler Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = CLKframe/1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = CLKframe/2.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = CLKframe/4.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = CLKframe/8.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[9:4]   </td><td class="markdownTableBodyCenter">FCV   </td><td class="markdownTableBodyLeft">Frame Counter Top Value    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">These 6 bits contain the top value of the Frame counter.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l05530">5530</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga49587e6682033dfe454dd2009b2a4341" name="ga49587e6682033dfe454dd2009b2a4341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49587e6682033dfe454dd2009b2a4341">&#9670;&nbsp;</a></span>FCR <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t RTC_T::FCR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md310"></a>
FCR</h1>
<h2><a class="anchor" id="autotoc_md311"></a>
Offset: 0x08  RTC Frequency Compensation Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[21:0]   </td><td class="markdownTableBodyCenter">FCR   </td><td class="markdownTableBodyLeft">Frequency Compensation Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">FCR = 32768 * 0x200000 / (LXT period).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LXT period: the clock period (Hz) of LXT.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l07120">7120</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaa25ad7fbb1cb93402ce992f10d34d48a" name="gaa25ad7fbb1cb93402ce992f10d34d48a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa25ad7fbb1cb93402ce992f10d34d48a">&#9670;&nbsp;</a></span>FCSTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t LCD_T::FCSTS</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md246"></a>
FCSTS</h1>
<h2><a class="anchor" id="autotoc_md247"></a>
Offset: 0x34  LCD frame counter status</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">FCSTS   </td><td class="markdownTableBodyLeft">LCD Frame Counter Status    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Frame counter value does not reach FCV (Frame Count TOP value).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Frame counter value reaches FCV (Frame Count TOP value).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the FCINTEN is s enabled, the frame counter overflow Interrupt is generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">PDSTS   </td><td class="markdownTableBodyLeft">Power-Down Interrupt Status    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Inform system manager that LCD controller is not ready to enter power-down state until this bit becomes 1 if power down is set and one frame is not executed completely.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Inform system manager that LCD controller is ready to enter power-down state if power down is set and one frame is executed completely   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l05547">5547</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga4cd9a89d3d1c7a3a6f3e3c5c4beb0727" name="ga4cd9a89d3d1c7a3a6f3e3c5c4beb0727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cd9a89d3d1c7a3a6f3e3c5c4beb0727">&#9670;&nbsp;</a></span>FFCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SPI_T::FFCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md390"></a>
FFCTL</h1>
<h2><a class="anchor" id="autotoc_md391"></a>
Offset: 0x3C  SPI FIFO Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">RX_CLR   </td><td class="markdownTableBodyLeft">Receiving FIFO Counter Clear    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No clear the received FIFO.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Clear the received FIFO.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is used to clear the receiver counter in FIFO Mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit can be written "1" to clear the receiver counter and this bit will be cleared to "0" automatically after clearing receiving counter.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">After the clear operation, the flag of RX_EMPTY in SPI_STATUS[0] will be set to "1".    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">TX_CLR   </td><td class="markdownTableBodyLeft">Transmitting FIFO Counter Clear    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No clear the transmitted FIFO.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Clear the transmitted FIFO.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is used to clear the transmit counter in FIFO Mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit can be written "1" to clear the transmitting counter and this bit will be cleared to "0" automatically after clearing transmitting counter.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">After the clear operation, the flag of TX_EMPTY in SPI_STATUS[2] will be set to "1".    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">RXINT_EN   </td><td class="markdownTableBodyLeft">RX Threshold Interrupt Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Rx threshold interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RX threshold interrupt Enable.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">TXINT_EN   </td><td class="markdownTableBodyLeft">TX Threshold Interrupt Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = TX threshold interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = TX threshold interrupt Enable.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">RXOVINT_EN   </td><td class="markdownTableBodyLeft">RX FIFO Over Run Interrupt Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RX FIFO over run interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RX FIFO over run interrupt Enable.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">TIMEOUT_EN   </td><td class="markdownTableBodyLeft">RX Read Time Out Function Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RX read Timeout function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RX read Timeout function Enable.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[26:24]   </td><td class="markdownTableBodyCenter">RX_THRESHOLD   </td><td class="markdownTableBodyLeft">Received FIFO Threshold    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If RX valid data counts large than RXTHRESHOLD, RXINT_STS (SPI_STATUS[8]) will set to 1,.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[30:28]   </td><td class="markdownTableBodyCenter">TX_THRESHOLD   </td><td class="markdownTableBodyLeft">Transmit FIFO Threshold    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If TX valid data counts small or equal than TXTHRESHOLD, TXINT_STS (SPI_STATUS[10]) will set to 1.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l08842">8842</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga05aca80545648c67739ed834eaa01f79" name="ga05aca80545648c67739ed834eaa01f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05aca80545648c67739ed834eaa01f79">&#9670;&nbsp;</a></span>FRQDIV0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t CLK_T::FRQDIV0</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md52"></a>
FRQDIV0</h1>
<h2><a class="anchor" id="autotoc_md53"></a>
Offset: 0x28  Frequency Divider0 Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3:0]   </td><td class="markdownTableBodyCenter">FSEL   </td><td class="markdownTableBodyLeft">Divider Output Frequency Selection Bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The formula of output frequency is    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">FCLK0 = FRQDIV0_CLK/2^(N+1),.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Where FRQDIV0_CLK is the input clock frequency, Fout is the frequency of divider output clock and N is the 4-bit value of FSEL[3:0].    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">FDIV_EN   </td><td class="markdownTableBodyLeft">Frequency Divider Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Frequency Divider Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Frequency Divider Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">DIV1   </td><td class="markdownTableBodyLeft">Output Frequency Divide By 1    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Output frequency is equal to FCLK0.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Output frequency is equal to FRQDIV0_CLK.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l01320">1320</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga331ce92b94015f5c199d9bf36ab5874a" name="ga331ce92b94015f5c199d9bf36ab5874a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga331ce92b94015f5c199d9bf36ab5874a">&#9670;&nbsp;</a></span>FRQDIV1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t CLK_T::FRQDIV1</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md58"></a>
FRQDIV1</h1>
<h2><a class="anchor" id="autotoc_md59"></a>
Offset: 0x38  Frequency Divider1 Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3:0]   </td><td class="markdownTableBodyCenter">FSEL   </td><td class="markdownTableBodyLeft">Divider Output Frequency Selection Bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The formula of output frequency is    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">FCLK1 = FRQDIV1_CLK /2^(N+1),.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Where FRQDIV1_CLK is the input clock frequency, Fout is the frequency of divider output clock and N is the 4-bit value of FSEL[3:0].    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">FDIV_EN   </td><td class="markdownTableBodyLeft">Frequency Divider Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Frequency Divider Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Frequency Divider Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">DIV1   </td><td class="markdownTableBodyLeft">Output Frequency Divide By 1    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Output frequency is equal to FCLK1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Output frequency is equal to FRQDIV1_CLK.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l01374">1374</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga4147906e727e2bef07512303f1364881" name="ga4147906e727e2bef07512303f1364881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4147906e727e2bef07512303f1364881">&#9670;&nbsp;</a></span>FSR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t UART_T::FSR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md418"></a>
FSR</h1>
<h2><a class="anchor" id="autotoc_md419"></a>
Offset: 0x18  UART FIFO State Status Register.</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">RX_OVER_F   </td><td class="markdownTableBodyLeft">RX Overflow Error Status Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set when RX-FIFO overflow.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the number of bytes of received data is greater than RX-FIFO (UART_RBR) size, 16 bytes of UART0/UART1, this bit will be set.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RX FIFO is not overflow.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RX FIFO is overflow.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only, but it can be cleared by writing "1" to it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">RX_EMPTY_F   </td><td class="markdownTableBodyLeft">Receiver FIFO Empty (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit initiate RX-FIFO empty or not.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the last byte of RX-FIFO has been read by CPU, hardware sets this bit high.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It will be cleared when UART receives any new data.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RX FIFO is not empty.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RX FIFO is empty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">RX_FULL_F   </td><td class="markdownTableBodyLeft">Receiver FIFO Full (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit initiates RX-FIFO full or not.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set when RX_POINTER_F is equal to 16, otherwise is cleared by hardware.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RX FIFO is not full.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RX FIFO is full.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">PE_F   </td><td class="markdownTableBodyLeft">Parity Error State Status Flag (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set to logic "1" whenever the received character does not have a valid "parity bit", and it is reset whenever the CPU writes "1" to this bit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No parity error is generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Parity error is generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only, but it can be cleared by writing "1" to it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">FE_F   </td><td class="markdownTableBodyLeft">Framing Error Status Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set to logic "1" whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as a logic "0"), and it is reset whenever the CPU writes "1" to this bit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No framing error is generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Framing error is generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only, but it can be cleared by writing "1" to it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">BI_F   </td><td class="markdownTableBodyLeft">Break Status Flag (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set to a logic "1" whenever the received data input(RX) is held in the "spacing state" (logic "0") for longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits) and it is reset whenever the CPU writes "1" to this bit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No Break interrupt is generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Break interrupt is generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only, but it can be cleared by writing "1" to it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">TX_OVER_F   </td><td class="markdownTableBodyLeft">TX Overflow Error Interrupt Status Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If TX-FIFO (UART_THR) is full, an additional write to UART_THR will cause this bit to logic "1".    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = TX FIFO is not overflow.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = TX FIFO is overflow.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only, but it can be cleared by writing "1" to it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">TX_EMPTY_F   </td><td class="markdownTableBodyLeft">Transmitter FIFO Empty (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates TX-FIFO empty or not.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the last byte of TX-FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It will be cleared when writing data into THR (TX-FIFO not empty).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = TX FIFO is not empty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = TX FIFO is empty.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[10]   </td><td class="markdownTableBodyCenter">TX_FULL_F   </td><td class="markdownTableBodyLeft">Transmitter FIFO Full (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates TX-FIFO full or not.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set when TX_POINTER_F is equal to 16, otherwise is cleared by hardware.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = TX FIFO is not full.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = TX FIFO is full.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[11]   </td><td class="markdownTableBodyCenter">TE_F   </td><td class="markdownTableBodyLeft">Transmitter Empty Status Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Bit is set by hardware when TX is inactive. (TX shift register does not have data)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Bit is cleared automatically when TX-FIFO is transfer data to TX shift register or TX is empty but the transfer does not finish.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = TX FIFO is not empty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = TX FIFO is empty.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[20:16]   </td><td class="markdownTableBodyCenter">RX_POINTER_F   </td><td class="markdownTableBodyLeft">RX-FIFO Pointer (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field indicates the RX-FIFO Buffer Pointer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When UART receives one byte from external device, RX_POINTER_F increases one.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When one byte of RX-FIFO is read by CPU, RX_POINTER_F decreases one.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[28:24]   </td><td class="markdownTableBodyCenter">TX_POINTER_F   </td><td class="markdownTableBodyLeft">TX-FIFO Pointer (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field indicates the TX-FIFO Buffer Pointer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When CPU writes one byte data into UART_THR, TX_POINTER_F increases one.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When one byte of TX-FIFO is transferred to Transmitter Shift Register, TX_POINTER_F decreases one.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l09855">9855</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga51ae34e470c8bc57f5a3a56bc25ca1b6" name="ga51ae34e470c8bc57f5a3a56bc25ca1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51ae34e470c8bc57f5a3a56bc25ca1b6">&#9670;&nbsp;</a></span>FUN_SEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t UART_T::FUN_SEL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md430"></a>
FUN_SEL</h1>
<h2><a class="anchor" id="autotoc_md431"></a>
Offset: 0x38  UART Function Select Register.</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1:0]   </td><td class="markdownTableBodyCenter">FUN_SEL   </td><td class="markdownTableBodyLeft">Function Select Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = UART function mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = LIN function mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = IrDA Function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = RS-485 Function.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10015">10015</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga1afa8bc188cd8faa4c924f86426c8559" name="ga1afa8bc188cd8faa4c924f86426c8559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1afa8bc188cd8faa4c924f86426c8559">&#9670;&nbsp;</a></span>GCRCSR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t DMA_GCR_T::GCRCSR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md84"></a>
GCRCSR</h1>
<h2><a class="anchor" id="autotoc_md85"></a>
Offset: 0x00  DMA Global Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">CLK1_EN   </td><td class="markdownTableBodyLeft">PDMA Controller Channel 1 Clock Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[10]   </td><td class="markdownTableBodyCenter">CLK2_EN   </td><td class="markdownTableBodyLeft">PDMA Controller Channel 2 Clock Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[11]   </td><td class="markdownTableBodyCenter">CLK3_EN   </td><td class="markdownTableBodyLeft">PDMA Controller Channel 3 Clock Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[12]   </td><td class="markdownTableBodyCenter">CLK4_EN   </td><td class="markdownTableBodyLeft">PDMA Controller Channel 4 Clock Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[24]   </td><td class="markdownTableBodyCenter">CRC_CLK_EN   </td><td class="markdownTableBodyLeft">CRC Controller Clock Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l01944">1944</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga5b047759aa8f5953e4fc72fe3ad26b75" name="ga5b047759aa8f5953e4fc72fe3ad26b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b047759aa8f5953e4fc72fe3ad26b75">&#9670;&nbsp;</a></span>GCRISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t DMA_GCR_T::GCRISR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md90"></a>
GCRISR</h1>
<h2><a class="anchor" id="autotoc_md91"></a>
Offset: 0x0C  DMA Global Interrupt Status Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">INTR1   </td><td class="markdownTableBodyLeft">Interrupt Status Of Channel 1 (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is the interrupt status of PDMA channel1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">INTR2   </td><td class="markdownTableBodyLeft">Interrupt Status Of Channel 2 (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is the interrupt status of PDMA channel2.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">INTR3   </td><td class="markdownTableBodyLeft">Interrupt Status Of Channel 3 (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is the interrupt status of PDMA channel3.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">INTR4   </td><td class="markdownTableBodyLeft">Interrupt Status Of Channel 4 (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is the interrupt status of PDMA channel4.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">INTRCRC   </td><td class="markdownTableBodyLeft">Interrupt Status Of CRC Controller (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is the interrupt status of CRC controller   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l02055">2055</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga5c28784c32bb49716e0486c490be2e7e" name="ga5c28784c32bb49716e0486c490be2e7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c28784c32bb49716e0486c490be2e7e">&#9670;&nbsp;</a></span>IER <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PDMA_T::IER</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md106"></a>
IER</h1>
<h2><a class="anchor" id="autotoc_md107"></a>
Offset: 0x20  PDMA Interrupt Enable Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">TABORT_IE   </td><td class="markdownTableBodyLeft">PDMA Read/Write Target Abort Interrupt Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Target abort interrupt generation Disabled during PDMA transfer.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Target abort interrupt generation Enabled during PDMA transfer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">TD_IE   </td><td class="markdownTableBodyLeft">PDMA Transfer Done Interrupt Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Interrupt generator Disabled when PDMA transfer is done.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Interrupt generator Enabled when PDMA transfer is done.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:2]   </td><td class="markdownTableBodyCenter">WRA_BCR_IE   </td><td class="markdownTableBodyLeft">Wrap Around Byte Count Interrupt Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0001 = Interrupt enable of PDMA_CBCR equals 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0100 = Interrupt enable of PDMA_CBCR equals 1/2 PDMA_BCR.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">TO_IE   </td><td class="markdownTableBodyLeft">Time-Out Interrupt Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Time-out interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Time-out interrupt Enabled.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l02214">2214</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaa332e6a57141c2ae9a44acc296a8ca18" name="gaa332e6a57141c2ae9a44acc296a8ca18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa332e6a57141c2ae9a44acc296a8ca18">&#9670;&nbsp;</a></span>IER <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t GPIO_T::IER</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md190"></a>
IER</h1>
<h2><a class="anchor" id="autotoc_md191"></a>
Offset: 0x1C  GPIO Port Interrupt Enable Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">FIER0   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">FIER[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit "1" also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When set the FIER[n] bit "1":    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PIN[n] state low-level or high-to-low change interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PIN[n] state low-level or high-to-low change interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_IER, bits [15:6] are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">FIER1   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">FIER[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit "1" also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When set the FIER[n] bit "1":    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PIN[n] state low-level or high-to-low change interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PIN[n] state low-level or high-to-low change interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_IER, bits [15:6] are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">FIER2   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">FIER[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit "1" also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When set the FIER[n] bit "1":    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PIN[n] state low-level or high-to-low change interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PIN[n] state low-level or high-to-low change interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_IER, bits [15:6] are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">FIER3   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">FIER[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit "1" also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When set the FIER[n] bit "1":    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PIN[n] state low-level or high-to-low change interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PIN[n] state low-level or high-to-low change interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_IER, bits [15:6] are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">FIER4   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">FIER[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit "1" also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When set the FIER[n] bit "1":    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PIN[n] state low-level or high-to-low change interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PIN[n] state low-level or high-to-low change interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_IER, bits [15:6] are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">FIER5   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">FIER[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit "1" also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When set the FIER[n] bit "1":    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PIN[n] state low-level or high-to-low change interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PIN[n] state low-level or high-to-low change interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_IER, bits [15:6] are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">FIER6   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">FIER[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit "1" also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When set the FIER[n] bit "1":    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PIN[n] state low-level or high-to-low change interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PIN[n] state low-level or high-to-low change interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_IER, bits [15:6] are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">FIER7   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">FIER[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit "1" also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When set the FIER[n] bit "1":    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PIN[n] state low-level or high-to-low change interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PIN[n] state low-level or high-to-low change interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_IER, bits [15:6] are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">FIER8   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">FIER[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit "1" also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When set the FIER[n] bit "1":    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PIN[n] state low-level or high-to-low change interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PIN[n] state low-level or high-to-low change interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_IER, bits [15:6] are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">FIER9   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">FIER[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit "1" also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When set the FIER[n] bit "1":    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PIN[n] state low-level or high-to-low change interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PIN[n] state low-level or high-to-low change interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_IER, bits [15:6] are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[10]   </td><td class="markdownTableBodyCenter">FIER10   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">FIER[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit "1" also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When set the FIER[n] bit "1":    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PIN[n] state low-level or high-to-low change interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PIN[n] state low-level or high-to-low change interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_IER, bits [15:6] are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[11]   </td><td class="markdownTableBodyCenter">FIER11   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">FIER[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit "1" also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When set the FIER[n] bit "1":    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PIN[n] state low-level or high-to-low change interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PIN[n] state low-level or high-to-low change interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_IER, bits [15:6] are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[12]   </td><td class="markdownTableBodyCenter">FIER12   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">FIER[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit "1" also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When set the FIER[n] bit "1":    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PIN[n] state low-level or high-to-low change interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PIN[n] state low-level or high-to-low change interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_IER, bits [15:6] are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[13]   </td><td class="markdownTableBodyCenter">FIER13   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">FIER[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit "1" also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When set the FIER[n] bit "1":    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PIN[n] state low-level or high-to-low change interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PIN[n] state low-level or high-to-low change interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_IER, bits [15:6] are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[14]   </td><td class="markdownTableBodyCenter">FIER14   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">FIER[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit "1" also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When set the FIER[n] bit "1":    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PIN[n] state low-level or high-to-low change interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PIN[n] state low-level or high-to-low change interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_IER, bits [15:6] are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[15]   </td><td class="markdownTableBodyCenter">FIER15   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">FIER[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit "1" also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When set the FIER[n] bit "1":    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PIN[n] state low-level or high-to-low change interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PIN[n] state low-level or high-to-low change interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_IER, bits [15:6] are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">RIER0   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">RIER[x] used to enable the interrupt for each of the corresponding input GPIO_PIN[x].    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit "1" also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When set the RIER[x] bit "1":    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level mode trigger, the input PIN[x] state at level "high" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge mode trigger, the input PIN[x] state change from "low-to-high" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PIN[x] level-high or low-to-high interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PIN[x] level-high or low-to-high interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_IE, bits [31:22] are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[17]   </td><td class="markdownTableBodyCenter">RIER1   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">RIER[x] used to enable the interrupt for each of the corresponding input GPIO_PIN[x].    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit "1" also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When set the RIER[x] bit "1":    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level mode trigger, the input PIN[x] state at level "high" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge mode trigger, the input PIN[x] state change from "low-to-high" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PIN[x] level-high or low-to-high interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PIN[x] level-high or low-to-high interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_IE, bits [31:22] are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[18]   </td><td class="markdownTableBodyCenter">RIER2   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">RIER[x] used to enable the interrupt for each of the corresponding input GPIO_PIN[x].    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit "1" also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When set the RIER[x] bit "1":    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level mode trigger, the input PIN[x] state at level "high" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge mode trigger, the input PIN[x] state change from "low-to-high" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PIN[x] level-high or low-to-high interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PIN[x] level-high or low-to-high interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_IE, bits [31:22] are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[19]   </td><td class="markdownTableBodyCenter">RIER3   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">RIER[x] used to enable the interrupt for each of the corresponding input GPIO_PIN[x].    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit "1" also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When set the RIER[x] bit "1":    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level mode trigger, the input PIN[x] state at level "high" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge mode trigger, the input PIN[x] state change from "low-to-high" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PIN[x] level-high or low-to-high interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PIN[x] level-high or low-to-high interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_IE, bits [31:22] are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[20]   </td><td class="markdownTableBodyCenter">RIER4   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">RIER[x] used to enable the interrupt for each of the corresponding input GPIO_PIN[x].    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit "1" also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When set the RIER[x] bit "1":    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level mode trigger, the input PIN[x] state at level "high" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge mode trigger, the input PIN[x] state change from "low-to-high" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PIN[x] level-high or low-to-high interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PIN[x] level-high or low-to-high interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_IE, bits [31:22] are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[21]   </td><td class="markdownTableBodyCenter">RIER5   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">RIER[x] used to enable the interrupt for each of the corresponding input GPIO_PIN[x].    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit "1" also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When set the RIER[x] bit "1":    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level mode trigger, the input PIN[x] state at level "high" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge mode trigger, the input PIN[x] state change from "low-to-high" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PIN[x] level-high or low-to-high interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PIN[x] level-high or low-to-high interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_IE, bits [31:22] are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[22]   </td><td class="markdownTableBodyCenter">RIER6   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">RIER[x] used to enable the interrupt for each of the corresponding input GPIO_PIN[x].    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit "1" also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When set the RIER[x] bit "1":    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level mode trigger, the input PIN[x] state at level "high" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge mode trigger, the input PIN[x] state change from "low-to-high" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PIN[x] level-high or low-to-high interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PIN[x] level-high or low-to-high interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_IE, bits [31:22] are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[23]   </td><td class="markdownTableBodyCenter">RIER7   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">RIER[x] used to enable the interrupt for each of the corresponding input GPIO_PIN[x].    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit "1" also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When set the RIER[x] bit "1":    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level mode trigger, the input PIN[x] state at level "high" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge mode trigger, the input PIN[x] state change from "low-to-high" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PIN[x] level-high or low-to-high interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PIN[x] level-high or low-to-high interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_IE, bits [31:22] are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[24]   </td><td class="markdownTableBodyCenter">RIER8   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">RIER[x] used to enable the interrupt for each of the corresponding input GPIO_PIN[x].    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit "1" also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When set the RIER[x] bit "1":    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level mode trigger, the input PIN[x] state at level "high" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge mode trigger, the input PIN[x] state change from "low-to-high" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PIN[x] level-high or low-to-high interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PIN[x] level-high or low-to-high interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_IE, bits [31:22] are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[25]   </td><td class="markdownTableBodyCenter">RIER9   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">RIER[x] used to enable the interrupt for each of the corresponding input GPIO_PIN[x].    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit "1" also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When set the RIER[x] bit "1":    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level mode trigger, the input PIN[x] state at level "high" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge mode trigger, the input PIN[x] state change from "low-to-high" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PIN[x] level-high or low-to-high interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PIN[x] level-high or low-to-high interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_IE, bits [31:22] are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[26]   </td><td class="markdownTableBodyCenter">RIER10   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">RIER[x] used to enable the interrupt for each of the corresponding input GPIO_PIN[x].    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit "1" also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When set the RIER[x] bit "1":    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level mode trigger, the input PIN[x] state at level "high" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge mode trigger, the input PIN[x] state change from "low-to-high" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PIN[x] level-high or low-to-high interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PIN[x] level-high or low-to-high interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_IE, bits [31:22] are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[27]   </td><td class="markdownTableBodyCenter">RIER11   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">RIER[x] used to enable the interrupt for each of the corresponding input GPIO_PIN[x].    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit "1" also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When set the RIER[x] bit "1":    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level mode trigger, the input PIN[x] state at level "high" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge mode trigger, the input PIN[x] state change from "low-to-high" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PIN[x] level-high or low-to-high interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PIN[x] level-high or low-to-high interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_IE, bits [31:22] are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[28]   </td><td class="markdownTableBodyCenter">RIER12   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">RIER[x] used to enable the interrupt for each of the corresponding input GPIO_PIN[x].    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit "1" also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When set the RIER[x] bit "1":    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level mode trigger, the input PIN[x] state at level "high" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge mode trigger, the input PIN[x] state change from "low-to-high" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PIN[x] level-high or low-to-high interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PIN[x] level-high or low-to-high interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_IE, bits [31:22] are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[29]   </td><td class="markdownTableBodyCenter">RIER13   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">RIER[x] used to enable the interrupt for each of the corresponding input GPIO_PIN[x].    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit "1" also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When set the RIER[x] bit "1":    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level mode trigger, the input PIN[x] state at level "high" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge mode trigger, the input PIN[x] state change from "low-to-high" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PIN[x] level-high or low-to-high interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PIN[x] level-high or low-to-high interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_IE, bits [31:22] are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[30]   </td><td class="markdownTableBodyCenter">RIER14   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">RIER[x] used to enable the interrupt for each of the corresponding input GPIO_PIN[x].    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit "1" also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When set the RIER[x] bit "1":    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level mode trigger, the input PIN[x] state at level "high" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge mode trigger, the input PIN[x] state change from "low-to-high" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PIN[x] level-high or low-to-high interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PIN[x] level-high or low-to-high interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_IE, bits [31:22] are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[31]   </td><td class="markdownTableBodyCenter">RIER15   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">RIER[x] used to enable the interrupt for each of the corresponding input GPIO_PIN[x].    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit "1" also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When set the RIER[x] bit "1":    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level mode trigger, the input PIN[x] state at level "high" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge mode trigger, the input PIN[x] state change from "low-to-high" will generate the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PIN[x] level-high or low-to-high interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PIN[x] level-high or low-to-high interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_IE, bits [31:22] are reserved.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l04613">4613</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gae664041daf8c26402757b67aaa5677e2" name="gae664041daf8c26402757b67aaa5677e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae664041daf8c26402757b67aaa5677e2">&#9670;&nbsp;</a></span>IER <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SC_T::IER</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md346"></a>
IER</h1>
<h2><a class="anchor" id="autotoc_md347"></a>
Offset: 0x18  SC Interrupt Enable Register.</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">RDA_IE   </td><td class="markdownTableBodyLeft">Receive Data Reach Interrupt Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field is used for received data reaching trigger level (SC_CTL [RX_FTRI_LEV]) interrupt enable.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = INT_RDR Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = INT_RDR Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">TBE_IE   </td><td class="markdownTableBodyLeft">Transmit Buffer Empty Interrupt Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field is used for transmit buffer empty interrupt enable.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = INT_THRE Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = INT_THRE Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">TERR_IE   </td><td class="markdownTableBodyLeft">Transfer Error Interrupt Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field is used for transfer error interrupt enable.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The transfer error states is at SC_TRSR register which includes receiver break error (RX_EBR_F), frame error (RX_EFR_F), parity error (RX_EPA_F), receiver buffer overflow error (RX_OVER_F), transmit buffer overflow error (TX_OVER_F), receiver retry over limit error (RX_OVER_ERETRY) and transmitter retry over limit error (TX_OVER_ERETRY).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = INT_TERR Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = INT_TERR Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">TMR0_IE   </td><td class="markdownTableBodyLeft">Timer0 Interrupt Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field is used for TMR0 interrupt enable.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = INT_TMR0 Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = INT_TMR0 Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">TMR1_IE   </td><td class="markdownTableBodyLeft">Timer1 Interrupt Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field is used for TMR1 interrupt enable.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = INT_TMR1 Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = INT_TMR1 Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">TMR2_IE   </td><td class="markdownTableBodyLeft">Timer2 Interrupt Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field is used for TMR2 interrupt enable.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = INT_TMR2 Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = INT_TMR2 Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">BGT_IE   </td><td class="markdownTableBodyLeft">Block Guard Time Interrupt Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field is used for block guard time interrupt enable.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = INT_BGT Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = INT_BGT Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">CD_IE   </td><td class="markdownTableBodyLeft">Card Detect Interrupt Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field is used for card detect interrupt enable.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The card detect status register is SC_PINCSR [CD_CH] and SC_PINCSR[CD_CL].    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = INT_CD Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = INT_CD Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">INIT_IE   </td><td class="markdownTableBodyLeft">Initial End Interrupt Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field is used for activation (SC_ALTCTL [ACT_EN]), deactivation (SC_ALTCTL [DACT_EN]) and warm reset (SC_ALTCTL [WARST_EN]) sequence interrupt enable.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = INT_INIT Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = INT_INIT Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">RTMR_IE   </td><td class="markdownTableBodyLeft">Receiver Buffer Time-Out Interrupt Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field is used for receiver buffer time-out interrupt enable.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = INT_RTMR Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = INT_RTMR Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[10]   </td><td class="markdownTableBodyCenter">ACON_ERR_IE   </td><td class="markdownTableBodyLeft">Auto Convention Error Interrupt Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field is used for auto convention error interrupt enable.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = INT_ACON_ERR Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = INT_ACON_ERR Enabled.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l07852">7852</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga1b93de0ad6cd08676926bcff6888c10d" name="ga1b93de0ad6cd08676926bcff6888c10d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b93de0ad6cd08676926bcff6888c10d">&#9670;&nbsp;</a></span>IER <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t TIMER_T::IER</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md398"></a>
IER</h1>
<h2><a class="anchor" id="autotoc_md399"></a>
Offset: 0x0C  Timer x Interrupt Enable Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">TMR_IE   </td><td class="markdownTableBodyLeft">Timer Interrupt Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Timer Interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Timer Interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: If timer interrupt is enabled, the timer asserts its interrupt signal when the associated counter is equal to TMR_CMPR.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">TCAP_IE   </td><td class="markdownTableBodyLeft">Timer Capture Function Interrupt Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Timer External Pin Function Interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Timer External Pin Function Interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: If timer external pin function interrupt is enabled, the timer asserts its interrupt signal when the TCAP_EN (TMRx_CTL[16]) is set and the transition of external pin matches the TCAP_EDGE (TMRx_CTL[19:18]) setting   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l09226">9226</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga202d78662da8b815cb7e16a997244a1f" name="ga202d78662da8b815cb7e16a997244a1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga202d78662da8b815cb7e16a997244a1f">&#9670;&nbsp;</a></span>IER <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t UART_T::IER</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md412"></a>
IER</h1>
<h2><a class="anchor" id="autotoc_md413"></a>
Offset: 0x0C  UART Interrupt Enable Register.</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">RDA_IE   </td><td class="markdownTableBodyLeft">Receive Data Available Interrupt Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = INT_RDA Masked off.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = INT_RDA Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">THRE_IE   </td><td class="markdownTableBodyLeft">Transmit Holding Register Empty Interrupt Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = INT_THRE Masked off.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = INT_THRE Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">RLS_IE   </td><td class="markdownTableBodyLeft">Receive Line Status Interrupt Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = INT_RLS Masked off.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = INT_RLS Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">MODEM_IE   </td><td class="markdownTableBodyLeft">Modem Status Interrupt Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = INT_MOS Masked off.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = INT_MOS Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">RTO_IE   </td><td class="markdownTableBodyLeft">RX Time-Out Interrupt Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = INT_TOUT Masked off.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = INT_TOUT Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">BUF_ERR_IE   </td><td class="markdownTableBodyLeft">Buffer Error Interrupt Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = INT_BUT_ERR Masked off.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = INT_BUF_ERR Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">WAKE_IE   </td><td class="markdownTableBodyLeft">Wake-Up Interrupt Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = INT_WAKE Masked off.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = INT_WAKE Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">ABAUD_IE   </td><td class="markdownTableBodyLeft">Auto-Baud Rate Interrupt Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = INT_ABAUD Masked off.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = INT_ABAUD Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">LIN_IE   </td><td class="markdownTableBodyLeft">LIN Interrupt Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = INT_LIN Masked off.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = INT_LIN Enabled.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l09666">9666</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga780f43a9d3391b6c63694ffda079d3ca" name="ga780f43a9d3391b6c63694ffda079d3ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga780f43a9d3391b6c63694ffda079d3ca">&#9670;&nbsp;</a></span>IER <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t WDT_T::IER</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md440"></a>
IER</h1>
<h2><a class="anchor" id="autotoc_md441"></a>
Offset: 0x04  Watchdog Timer Interrupt Enable Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">WDT_IE   </td><td class="markdownTableBodyLeft">Watchdog Timer Interrupt Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Watchdog timer interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Watchdog timer interrupt Enabled.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10361">10361</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga817777175020f4492081e6e323fcb39e" name="ga817777175020f4492081e6e323fcb39e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga817777175020f4492081e6e323fcb39e">&#9670;&nbsp;</a></span>IER <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t WWDT_T::IER</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md448"></a>
IER</h1>
<h2><a class="anchor" id="autotoc_md449"></a>
Offset: 0x08  Window Watchdog Timer Interrupt Enable Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">WWDTIE   </td><td class="markdownTableBodyLeft">WWDT Interrupt Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Setting this bit will enable the Watchdog timer interrupt function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Watchdog timer interrupt function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Watchdog timer interrupt function Enabled.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10494">10494</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga238fd487ce9252ecbab0003630cdeb27" name="ga238fd487ce9252ecbab0003630cdeb27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga238fd487ce9252ecbab0003630cdeb27">&#9670;&nbsp;</a></span>IMD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t GPIO_T::IMD</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md188"></a>
IMD</h1>
<h2><a class="anchor" id="autotoc_md189"></a>
Offset: 0x18  GPIO Port Interrupt Mode Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">IMD   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Edge Or Level Detection Interrupt Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">IMD[n] used to control the interrupt is by level trigger or by edge trigger.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is by edge trigger, the trigger source is control de-bounce.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Edge trigger interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Level trigger interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOX_IER.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The de-bounce function is valid for edge triggered interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt mode is level triggered, the de-bounce enable bit is ignored.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_IMD, bits [15:6] are reserved.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l04315">4315</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaa1b69ac1224067d2efd37f74bfc176f9" name="gaa1b69ac1224067d2efd37f74bfc176f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1b69ac1224067d2efd37f74bfc176f9">&#9670;&nbsp;</a></span>INIR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t RTC_T::INIR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md306"></a>
INIR</h1>
<h2><a class="anchor" id="autotoc_md307"></a>
Offset: 0x00  RTC Initiation Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">ACTIVE   </td><td class="markdownTableBodyLeft">RTC Active Status (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RTC is at reset state.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RTC is at normal active state.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[31:1]   </td><td class="markdownTableBodyCenter">INIR   </td><td class="markdownTableBodyLeft">RTC Initiation (Write Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When RTC block is powered on, RTC is at reset state.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">User has to write a number (0x a5eb1357) to INIR to make RTC leaving reset state.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Once the INIR is written as 0xa5eb1357, the RTC will be in un-reset state permanently.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The INIR is a write-only field and read value will be always "0".   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l07091">7091</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga8c44a4ecdebb23c29b983637fd66c9dc" name="ga8c44a4ecdebb23c29b983637fd66c9dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c44a4ecdebb23c29b983637fd66c9dc">&#9670;&nbsp;</a></span>Int_VREFCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SYS_T::Int_VREFCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md164"></a>
Int_VREFCTL</h1>
<h2><a class="anchor" id="autotoc_md165"></a>
Offset: 0x6C  Internal Voltage Reference Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">BGP_EN   </td><td class="markdownTableBodyLeft">Band-Gap Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a protected register. Please refer to open lock sequence to program it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Band-gap is the reference voltage of internal reference voltage.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">User must enable band-gap if want to enable internal 1.5, 1.8V or 2.5V reference voltage.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">REG_EN   </td><td class="markdownTableBodyLeft">Regulator Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Enable internal 1.5, 1.8V or 2.5V reference voltage.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a protected register. Please refer to open lock sequence to program it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3:2]   </td><td class="markdownTableBodyCenter">SEL25   </td><td class="markdownTableBodyLeft">Regulator Output Voltage Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Select internal reference voltage level.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a protected register. Please refer to open lock sequence to program it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = 1.5V.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = 1.8V.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = 2.5V.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = 2.5V.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">EXT_MODE   </td><td class="markdownTableBodyLeft">Regulator External Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a protected register. Please refer to open lock sequence to program it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Users can output regulator output voltage in VREF pin if EXT_MODE is high.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No connection with external VREF pin.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Connect to external VREF pin.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Connect a 1uF to 10uF capacitor to AVSS will let internal voltage reference be more stable.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[11:8]   </td><td class="markdownTableBodyCenter">VREF_TRIM   </td><td class="markdownTableBodyLeft">Internal Voltage Reference Trim   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l03488">3488</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga1fbc063a076e84e9b8f17ebcee04879e" name="ga1fbc063a076e84e9b8f17ebcee04879e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fbc063a076e84e9b8f17ebcee04879e">&#9670;&nbsp;</a></span>INTEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::INTEN</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md254"></a>
INTEN</h1>
<h2><a class="anchor" id="autotoc_md255"></a>
Offset: 0x0C  PWM Interrupt Enable Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">TMIE0   </td><td class="markdownTableBodyLeft">PWM Timer 0 Interrupt Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">TMIE1   </td><td class="markdownTableBodyLeft">PWM Timer 1 Interrupt Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">TMIE2   </td><td class="markdownTableBodyLeft">PWM Timer 2 Interrupt Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">TMIE3   </td><td class="markdownTableBodyLeft">PWM Timer 3 Interrupt Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l05870">5870</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga2b528aee5b81928cfa6e84f205ac5e88" name="ga2b528aee5b81928cfa6e84f205ac5e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b528aee5b81928cfa6e84f205ac5e88">&#9670;&nbsp;</a></span>INTSTS <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t I2C_T::INTSTS</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md200"></a>
INTSTS</h1>
<h2><a class="anchor" id="autotoc_md201"></a>
Offset: 0x04  I2C Interrupt Status Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">INTSTS   </td><td class="markdownTableBodyLeft">I2C STATUS's Interrupt Status    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No bus event occurred.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = New state is presented in the I2CSTATUS. Software can write 1 to cleat this bit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">TIF   </td><td class="markdownTableBodyLeft">Time-Out Status    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No Time-out flag. Software can cleat this flag.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Time-Out flag active and it is set by hardware. It can interrupt CPU when INTEN bit is set.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">WAKEUP_ACK_DONE   </td><td class="markdownTableBodyLeft">Wakeup Address Frame Acknowledge Bit Done    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The ACK bit cycle of address match frame isn't done.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The ACK bit cycle of address match frame is done in power-down.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l04947">4947</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gac535addafa0eb3c00a1fba2f4d845451" name="gac535addafa0eb3c00a1fba2f4d845451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac535addafa0eb3c00a1fba2f4d845451">&#9670;&nbsp;</a></span>INTSTS <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::INTSTS</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md256"></a>
INTSTS</h1>
<h2><a class="anchor" id="autotoc_md257"></a>
Offset: 0x10  PWM Interrupt Indication Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">TMINT0   </td><td class="markdownTableBodyLeft">PWM Timer 0 Interrupt Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Flag is set by hardware when PWM0 down counter reaches 0, software can clear this bit by writing a one to it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">TMINT1   </td><td class="markdownTableBodyLeft">PWM Timer 1 Interrupt Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Flag is set by hardware when PWM1 down counter reaches 0, software can clear this bit by writing a one to it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">TMINT2   </td><td class="markdownTableBodyLeft">PWM Timer 2 Interrupt Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Flag is set by hardware when PWM2 down counter reaches 0, software can clear this bit by writing a one to it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">TMINT3   </td><td class="markdownTableBodyLeft">PWM Timer 3 Interrupt Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Flag is set by hardware when PWM3 down counter reaches 0, software can clear this bit by writing a one to it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">Duty0Syncflag   </td><td class="markdownTableBodyLeft">Duty0 Synchronize Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Duty0 has been synchronized to PWM_CLK domain of channel 0, 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Duty0 is synchronizing to PWM_CLK domain of channel 0, 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: software should check this flag when writing duty0, if this flag is set, and user ignore this flag and change duty0, the corresponding CNR and CMR may be wrong for one duty cycle    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">Duty1Syncflag   </td><td class="markdownTableBodyLeft">Duty1 Synchronize Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Duty1 has been synchronized to PWM_CLK domain of channel 0, 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Duty1 is synchronizing to PWM_CLK domain of channel 0, 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: software should check this flag when writing duty1, if this flag is set, and user ignore this flag and change duty1, the corresponding CNR and CMR may be wrong for one duty cycle    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">Duty2Syncflag   </td><td class="markdownTableBodyLeft">Duty2 Synchronize Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Duty2 has been synchronized to PWM_CLK domain of channel 2, 3.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Duty2 is synchronizing to PWM_CLK domain of channel 2, 3.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: software should check this flag when writing duty2, if this flag is set, and user ignore this flag and change duty2, the corresponding CNR and CMR may be wrong for one duty cycle    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">Duty3Syncflag   </td><td class="markdownTableBodyLeft">Duty3 Synchronize Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Duty3 has been synchronized to PWM_CLK domain of channel 2, 3.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Duty3 is synchronizing to PWM_CLK domain of channel 2, 3.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: software should check this flag when writing duty3, if this flag is set, and user ignore this flag and change duty3, the corresponding CNR and CMR may be wrong for one duty cycle    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">PresSyncFlag   </td><td class="markdownTableBodyLeft">Prescale Synchronize Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Two Prescales have been synchronized to corresponding PWM_CLK (of channel 0,1 or channel 2, 3) domain respectively.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Prescale01 is synchronizing to PWM_CLK domain of channel 0,1 or Prescaler23 is synchronizing to PWM_CLK domain of channel 2, 3.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: software should check this flag when writing Prescale, if this flag is set, and user ignore this flag and change Prescale, the Prescale may be wrong for one prescale cycle   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l05908">5908</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga2d8aba8c61ac18aec3989ca8c6429fcf" name="ga2d8aba8c61ac18aec3989ca8c6429fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d8aba8c61ac18aec3989ca8c6429fcf">&#9670;&nbsp;</a></span>IPRST_CTL1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SYS_T::IPRST_CTL1</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md130"></a>
IPRST_CTL1</h1>
<h2><a class="anchor" id="autotoc_md131"></a>
Offset: 0x08  Peripheral Reset Control Resister1</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">CHIP_RST   </td><td class="markdownTableBodyLeft">Chip One-Shot Reset    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a protected register. Please refer to open lock sequence to program it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Setting this bit will reset the whole chip, including Cortex-M0 core and all peripherals like power-on reset and this bit will automatically return to "0" after the 2 clock cycles.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The chip setting from flash will be also reloaded when chip one shot reset.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Normal.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Reset chip.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: In the following conditions, chip setting from flash will be reloaded.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Power-on Reset    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Brown-out-Detected Reset    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Low level on the nRESET pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set IPRST_CTL1[CHIP_RST]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">CPU_RST   </td><td class="markdownTableBodyLeft">Cortex-M0 Core One-Shot Reset    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a protected register. Please refer to open lock sequence to program it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Setting this bit will only reset the Cortex-M0 core and Flash Memory Controller (FMC), and this bit will automatically return to "0" after the 2 clock cycles    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Normal.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Reset Cortex-M0 core.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">DMA_RST   </td><td class="markdownTableBodyLeft">DMA Controller Reset    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a protected register. Please refer to open lock sequence to program it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set this bit "1" will generate a reset signal to the DMA.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SW needs to set this bit to low to release reset signal.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Normal operation.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = DMA IP reset.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l02758">2758</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga505c932d819154975b9b438b7556bbe9" name="ga505c932d819154975b9b438b7556bbe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga505c932d819154975b9b438b7556bbe9">&#9670;&nbsp;</a></span>IPRST_CTL2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SYS_T::IPRST_CTL2</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md132"></a>
IPRST_CTL2</h1>
<h2><a class="anchor" id="autotoc_md133"></a>
Offset: 0x0C  Peripheral Reset Control Resister2</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">GPIO_RST   </td><td class="markdownTableBodyLeft">GPIO Controller Reset    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = GPIO module normal operation.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = GPIO module reset.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">TMR0_RST   </td><td class="markdownTableBodyLeft">Timer0 Controller Reset    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Timer0 module normal operation.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Timer0 module reset.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">TMR1_RST   </td><td class="markdownTableBodyLeft">Timer1 Controller Reset    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Timer1 module normal operation.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Timer1 module reset.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">TMR2_RST   </td><td class="markdownTableBodyLeft">Timer2 Controller Reset    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Timer2 module normal operation.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Timer2 module reset.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">TMR3_RST   </td><td class="markdownTableBodyLeft">Timer3 Controller Reset    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Timer3 module normal operation.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Timer3 module reset.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">I2C0_RST   </td><td class="markdownTableBodyLeft">I2C0 Controller Reset    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = I2C0 module normal operation.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = I2C0 module reset.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">I2C1_RST   </td><td class="markdownTableBodyLeft">I2C1 Controller Reset    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = I2C1 module normal operation.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = I2C1 module reset.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[12]   </td><td class="markdownTableBodyCenter">SPI0_RST   </td><td class="markdownTableBodyLeft">SPI0 Controller Reset    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = SPI0 module normal operation.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = SPI0 module reset.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[13]   </td><td class="markdownTableBodyCenter">SPI1_RST   </td><td class="markdownTableBodyLeft">SPI1 Controller Reset    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = SPI1 module normal operation.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = SPI1 module reset.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">UART0_RST   </td><td class="markdownTableBodyLeft">UART0 Controller Reset    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = UART0 module normal operation.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = UART0 module reset.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[17]   </td><td class="markdownTableBodyCenter">UART1_RST   </td><td class="markdownTableBodyLeft">UART1 Controller Reset    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = UART1 module normal operation.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = UART1 module reset.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[20]   </td><td class="markdownTableBodyCenter">PWM0_RST   </td><td class="markdownTableBodyLeft">PWM0 Controller Reset    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0 module normal operation.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0 module reset.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[22]   </td><td class="markdownTableBodyCenter">ACMP01_RST   </td><td class="markdownTableBodyLeft">Comparator Controller Reset    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Comparator module normal operation.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Comparator module reset.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[26]   </td><td class="markdownTableBodyCenter">LCD_RST   </td><td class="markdownTableBodyLeft">LCD Controller Reset    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = LCD module normal operation.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = LCD module reset.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[28]   </td><td class="markdownTableBodyCenter">ADC_RST   </td><td class="markdownTableBodyLeft">ADC Controller Reset    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = ADC module normal operation.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = ADC module reset.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[30]   </td><td class="markdownTableBodyCenter">SC0_RST   </td><td class="markdownTableBodyLeft">SmartCard 0 Controller Reset    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = SmartCard module normal operation.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = SmartCard module reset.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31]   </td><td class="markdownTableBodyCenter">SC1_RST   </td><td class="markdownTableBodyLeft">SmartCard1 Controller Reset    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = SmartCard module normal operation.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = SmartCard module reset.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l02819">2819</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gabdfc111e8ea7c7fe2aed82d163596da7" name="gabdfc111e8ea7c7fe2aed82d163596da7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdfc111e8ea7c7fe2aed82d163596da7">&#9670;&nbsp;</a></span>IRCR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t UART_T::IRCR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md426"></a>
IRCR</h1>
<h2><a class="anchor" id="autotoc_md427"></a>
Offset: 0x30  UART IrDA Control Register.</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">TX_SELECT   </td><td class="markdownTableBodyLeft">TX_SELECT    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = IrDA receiver Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = IrDA transmitter Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: In IrDA mode, the DIV_16_EN (UART_BAUD[31]) register must be set (the baud equation must be Clock / 16 * (BRD)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">INV_TX   </td><td class="markdownTableBodyLeft">INV_TX    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No inversion.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Inverse TX output signal.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">INV_RX   </td><td class="markdownTableBodyLeft">INV_RX    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No inversion.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Inverse RX input signal.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l09947">9947</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gac13d1171be23e2595c900b0f36713b7c" name="gac13d1171be23e2595c900b0f36713b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac13d1171be23e2595c900b0f36713b7c">&#9670;&nbsp;</a></span>IRCTRIMCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SYS_T::IRCTRIMCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md168"></a>
IRCTRIMCTL</h1>
<h2><a class="anchor" id="autotoc_md169"></a>
Offset: 0x80  HIRC Trim Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1:0]   </td><td class="markdownTableBodyCenter">TRIM_SEL   </td><td class="markdownTableBodyLeft">Trim Frequency Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field indicates the target frequency of HIRC auto trim.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If no any target frequency is selected (TRIM_SEL is 00), the HIRC auto trim function is disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">During auto trim operation, if 32.768 kHz clock error detected or trim retry limitation count reached, this field will be cleared to 00 automatically.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Disable HIRC auto trim function    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Enable HIRC auto trim function and trim HIRC to 11.0592 MHz    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Enable HIRC auto trim function and trim HIRC to 12 MHz    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Enable HIRC auto trim function and trim HIRC to 16 MHz    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:4]   </td><td class="markdownTableBodyCenter">TRIM_LOOP   </td><td class="markdownTableBodyLeft">Trim Calculation Loop    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field defines that trim value calculation is based on how many 32.768 kHz clock.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = 4 x 32.768 kHz clock    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = 8 x 32.768 kHz clock    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = 16 x 32.768 kHz clock    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = 32 x 32.768 kHz clock    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:6]   </td><td class="markdownTableBodyCenter">TRIM_RETRY_CNT   </td><td class="markdownTableBodyLeft">Trim Value Update Limitation Count    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field defines that how many times the auto trim circuit will try to update the HIRC trim value before the frequency of HIRC locked.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Once the HIRC locked, the internal trim value update counter will be reset.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the trim value update counter reached this limitation value and frequency of HIRC still doesn't lock, the auto trim operation will be disabled and TRIM_SEL will be cleared to 00.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Trim retry count limitation is 64    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Trim retry count limitation is 128    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Trim retry count limitation is 256    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Trim retry count limitation is 512    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">ERR_STOP   </td><td class="markdownTableBodyLeft">Trim Stop When 32.768 KHz Error Detected    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is used to control if stop the HIRC trim operation when 32.768 kHz clock error is detected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If set this bit high and 32.768 kHz clock error detected, the status 32K_ERR_INT would be set high and HIRC trim operation was stopped.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If this bit is low and 32.768 kHz clock error detected, the status 23K_ERR_INT would be set high and HIRC trim operation is continuously.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Continue the HIRC trim operation even if 32.768 kHz clock error detected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Stop the HIRC trim operation if 32.768 kHz clock error detected.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l03549">3549</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gadd3ebb0f8f212d70eeef59ae7077ed55" name="gadd3ebb0f8f212d70eeef59ae7077ed55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd3ebb0f8f212d70eeef59ae7077ed55">&#9670;&nbsp;</a></span>IRCTRIMIEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SYS_T::IRCTRIMIEN</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md170"></a>
IRCTRIMIEN</h1>
<h2><a class="anchor" id="autotoc_md171"></a>
Offset: 0x84  HIRC Trim Interrupt Enable Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">TRIM_FAIL_IEN   </td><td class="markdownTableBodyLeft">Trim Failure Interrupt Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit controls if an interrupt will be triggered while HIRC trim value update limitation count reached and HIRC frequency still not locked on target frequency set by TRIM_SEL.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If this bit is high and TRIM_FAIL_INT is set during auto trim operation, an interrupt will be triggered to notify that HIRC trim value update limitation count was reached.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = TRIM_FAIL_INT status Disabled to trigger an interrupt to CPU.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = TRIM_FAIL_INT status Enabled to trigger an interrupt to CPU.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">32K_ERR_IEN   </td><td class="markdownTableBodyLeft">32.768 KHz Clock Error Interrupt Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit controls if CPU would get an interrupt while 32.768 kHz clock is inaccuracy during auto trim operation.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If this bit is high, and 32K_ERR_INT is set during auto trim operation, an interrupt will be triggered to notify the 32.768 kHz clock frequency is inaccuracy.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = 32K_ERR_INT status Disabled to trigger an interrupt to CPU.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = 32K_ERR_INT status Enabled to trigger an interrupt to CPU.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l03569">3569</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaafa54adb500584bd9b19ec01bb0c0caf" name="gaafa54adb500584bd9b19ec01bb0c0caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafa54adb500584bd9b19ec01bb0c0caf">&#9670;&nbsp;</a></span>IRCTRIMINT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SYS_T::IRCTRIMINT</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md172"></a>
IRCTRIMINT</h1>
<h2><a class="anchor" id="autotoc_md173"></a>
Offset: 0x88  HIRC Trim Interrupt Status Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">FREQ_LOCK   </td><td class="markdownTableBodyLeft">HIRC Frequency Lock Status    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates the HIRC frequency lock.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a status bit and doesn't trigger any interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">TRIM_FAIL_INT   </td><td class="markdownTableBodyLeft">Trim Failure Interrupt Status    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates that HIRC trim value update limitation count reached and HIRC clock frequency still doesn't lock.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Once this bit is set, the auto trim operation stopped and TRIM_SEL will be cleared to 00 by hardware automatically.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If this bit is set and TRIM_FAIL_IEN is high, an interrupt will be triggered to notify that HIRC trim value update limitation count was reached.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Write 1 to clear this to zero.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Trim value update limitation count doesn't reach.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Trim value update limitation count reached and HIRC frequency still doesn't lock.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">32K_ERR_INT   </td><td class="markdownTableBodyLeft">32.768 KHz Clock Error Interrupt Status    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates that 32.768 kHz clock frequency is inaccuracy.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Once this bit is set, the auto trim operation stopped and TRIM_SEL will be cleared to 00 by hardware automatically.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If this bit is set and 32K_ERR_IEN is high, an interrupt will be triggered to notify the 32.768 kHz clock frequency is inaccuracy.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Write 1 to clear this to zero.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = 32.768 kHz clock frequency is accuracy.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = 32.768 kHz clock frequency is inaccuracy.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l03596">3596</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga02da88864194e77c672763a1389d5839" name="ga02da88864194e77c672763a1389d5839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02da88864194e77c672763a1389d5839">&#9670;&nbsp;</a></span>ISPADR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t FMC_T::ISPADR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md114"></a>
ISPADR</h1>
<h2><a class="anchor" id="autotoc_md115"></a>
Offset: 0x04  ISP Address Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]   </td><td class="markdownTableBodyCenter">ISPADR   </td><td class="markdownTableBodyLeft">ISP Address    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This chip supports word program only.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">ISPADR[1:0] must be kept 00b for ISP operation, and ISPADR[8:0] must be kept all 0 for Vector Page Re-map Command.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l02519">2519</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga535eb6e9457c338ac7515a5d2ff06802" name="ga535eb6e9457c338ac7515a5d2ff06802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga535eb6e9457c338ac7515a5d2ff06802">&#9670;&nbsp;</a></span>ISPCMD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t FMC_T::ISPCMD</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md118"></a>
ISPCMD</h1>
<h2><a class="anchor" id="autotoc_md119"></a>
Offset: 0x0C  ISP Command Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3:0]   </td><td class="markdownTableBodyCenter">FCTRL   </td><td class="markdownTableBodyLeft">ISP Command    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The ISP command table is shown as follows    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Read (FOEN = 0, FCEN = 0, FCRTL = 0000)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Program (FOEN = 1, FCEN = 0, FCRTL = 0001)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Page Erase (FOEN = 1, FCEN = 0, FCRTL = 0010)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Read CID (FOEN = 0, FCEN = 0, FCRTL = 1011)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Read DID (FOEN = 0, FCEN = 0, FCRTL = 1100)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">FCEN   </td><td class="markdownTableBodyLeft">ISP Command    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The ISP command table is shown as above.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">FOEN   </td><td class="markdownTableBodyLeft">ISP Command    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The ISP command table is shown as above.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l02553">2553</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gad658f15872614d8af77a748cf2f18d67" name="gad658f15872614d8af77a748cf2f18d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad658f15872614d8af77a748cf2f18d67">&#9670;&nbsp;</a></span>ISPCON</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t FMC_T::ISPCON</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md112"></a>
ISPCON</h1>
<h2><a class="anchor" id="autotoc_md113"></a>
Offset: 0x00  ISP Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">ISPEN   </td><td class="markdownTableBodyLeft">ISP Enable Control (Write Protect)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">ISP function enable bit. Set this bit to enable ISP function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = ISP function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = ISP function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">BS   </td><td class="markdownTableBodyLeft">Boot Select (Write Protect)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set/clear this bit to select next booting from LDROM/APROM, respectively.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit also functions as chip booting status flag, which can be used to check where chip booted from.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is initiated with the inversed value of CBS in Config0 after power-on reset; It keeps the same value at other reset.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Boot from APROM.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Boot from LDROM.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">APUEN   </td><td class="markdownTableBodyLeft">APROM Update Enable Control (Write Protect)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = APROM cannot be updated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = APROM can be updated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">CFGUEN   </td><td class="markdownTableBodyLeft">Enable Config-Bits Update By ISP (Write Protect)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = ISP update User Configuration Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = ISP update User Configuration Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">LDUEN   </td><td class="markdownTableBodyLeft">LDROM Update Enable Control (Write Protect)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = LDROM cannot be updated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = LDROM can be updated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">ISPFF   </td><td class="markdownTableBodyLeft">ISP Fail Flag (Write Protect)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set by hardware when a triggered ISP meets any of the following conditions:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1) APROM writes to itself if APUEN is set to 0 or CBS[0]=1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(2) LDROM writes to itself if LDUEN is set to 0 or CBS[0]=1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(3) User Configuration is erased/programmed when CFGUEN is 0.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(4) Destination address is illegal, such as over an available range.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Write 1 to clear this bit to 0.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l02506">2506</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga93a594f096446ee933113f6c57c200c3" name="ga93a594f096446ee933113f6c57c200c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93a594f096446ee933113f6c57c200c3">&#9670;&nbsp;</a></span>ISPDAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t FMC_T::ISPDAT</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md116"></a>
ISPDAT</h1>
<h2><a class="anchor" id="autotoc_md117"></a>
Offset: 0x08  ISP Data Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]   </td><td class="markdownTableBodyCenter">ISPDAT   </td><td class="markdownTableBodyLeft">ISP Data    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Write data to this register before ISP program operation    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Read data from this register after ISP read operation   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l02532">2532</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga2dc78a1205af2308d25719d882f78764" name="ga2dc78a1205af2308d25719d882f78764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2dc78a1205af2308d25719d882f78764">&#9670;&nbsp;</a></span>ISPSTA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t FMC_T::ISPSTA</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md124"></a>
ISPSTA</h1>
<h2><a class="anchor" id="autotoc_md125"></a>
Offset: 0x40  ISP Status Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">ISPBUSY   </td><td class="markdownTableBodyLeft">ISP Busy (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = ISP operation is finished.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = ISP operation is busy.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2:1]   </td><td class="markdownTableBodyCenter">CBS   </td><td class="markdownTableBodyLeft">Config Boot Selection Status (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This filed is a mirror of CBS in CONFIG0.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">PGFF   </td><td class="markdownTableBodyLeft">Auto Flash Program Verified Fail Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This chip will perform flash verification automatically at the end of ISP PROGRAM operation, and set 1 to this bit when flash data is not matched with programming.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is clear to 0 by "ERASE" command.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">ISPFF   </td><td class="markdownTableBodyLeft">ISP Fail Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1) APROM writes to itself if APUEN is set to 0 or CBS[0]=1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(2) LDROM writes to itself if LDUEN is set to 0 or CBS[0]=1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(3) User Configuration is erased/programmed when CFGUEN is 0.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(4) Destination address is illegal, such as over an available range.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Write 1 to clear this bit to 0.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l02607">2607</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaef7c67979c87346e1de844a30b649269" name="gaef7c67979c87346e1de844a30b649269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef7c67979c87346e1de844a30b649269">&#9670;&nbsp;</a></span>ISPTRG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t FMC_T::ISPTRG</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md120"></a>
ISPTRG</h1>
<h2><a class="anchor" id="autotoc_md121"></a>
Offset: 0x10  ISP Trigger Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">ISPGO   </td><td class="markdownTableBodyLeft">ISP Start Trigger    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Write 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP operation is finished.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = ISP operation is finished.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = ISP is progressing.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l02567">2567</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga9722e42994cbccb70a65ae76675a8ee6" name="ga9722e42994cbccb70a65ae76675a8ee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9722e42994cbccb70a65ae76675a8ee6">&#9670;&nbsp;</a></span>ISR <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PDMA_T::ISR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md108"></a>
ISR</h1>
<h2><a class="anchor" id="autotoc_md109"></a>
Offset: 0x24  PDMA Interrupt Status Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">TABORT_IS   </td><td class="markdownTableBodyLeft">PDMA Read/Write Target Abort Interrupt Status Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No bus ERROR response received.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Bus ERROR response received.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This bit is cleared by writing "1" to itself.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: The PDMA_ISR [TABORT_IF] indicate bus master received ERROR response or not, if bus master received occur it means that target abort is happened.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PDMA controller will stop transfer and respond this event to software then go to IDLE state.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When target abort occurred, software must reset PDMA controller, and then transfer those data again.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">TD_IS   </td><td class="markdownTableBodyLeft">Transfer Done Interrupt Status Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates that PDMA has finished all transfer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Not finished yet.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Done.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is cleared by writing "1" to itself.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:2]   </td><td class="markdownTableBodyCenter">WRA_BCR_IS   </td><td class="markdownTableBodyLeft">Wrap Around Transfer Byte Count Interrupt Status Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">WRA_BCR_IS [0] (xxx1) = PDMA_CBCR equal 0 flag.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">WRA_BCR_IS [2] (x1xx) = PDMA_CBCR equal 1/2 PDMA_BCR flag.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Each bit is cleared by writing "1" to itself.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field is only valid in wrap around mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(PDMA_CSR[DAD_SEL] =11 or PDMA_CSR[SAD_SEL] =11).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">TO_IS   </td><td class="markdownTableBodyLeft">Time-Out Interrupt Status Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This flag indicated that PDMA has waited peripheral request for a period defined by PDMA_TCR.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No time-out flag.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Time-out flag.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is cleared by writing "1" to itself.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l02247">2247</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga3a6b2fb485cffbfa199e53e7c9565044" name="ga3a6b2fb485cffbfa199e53e7c9565044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a6b2fb485cffbfa199e53e7c9565044">&#9670;&nbsp;</a></span>ISR <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SC_T::ISR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md348"></a>
ISR</h1>
<h2><a class="anchor" id="autotoc_md349"></a>
Offset: 0x1C  SC Interrupt Status Register.</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">RDA_IS   </td><td class="markdownTableBodyLeft">Receive Data Reach Interrupt Status Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field is used for received data reaching trigger level (SC_CTL [RX_FTRI_LEV]) interrupt status flag.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This field is the status flag of received data reaching SC_CTL [RX_FTRI_LEV].    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If software reads data from SC_RBR and receiver pointer is less than SC_CTL [RX_FTRI_LEV], this bit will be cleared automatically.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">TBE_IS   </td><td class="markdownTableBodyLeft">Transmit Buffer Empty Interrupt Status Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field is used for transmit buffer empty interrupt status flag.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is different with SC_TRSR [TX_EMPTY_F] flag and SC_TRSR [TX_ATV] flag; The TX_EMPTY_F will be set when the last byte data be read to shift register and TX_ATV flag indicates the transmitter is in active or not (the last data has been transmitted or not), but the TBE_IS may be set when the last byte data be read to shift register or the last data has been transmitted.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When this bit assert, software can write 1~4 byte data to SC_THR register.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: If software wants to clear this bit, software must write data to SC_THR register and then this bit will be cleared automatically.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">TERR_IS   </td><td class="markdownTableBodyLeft">Transfer Error Interrupt Status Flag (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field is used for transfer error interrupt status flag.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The transfer error states is at SC_TRSR register which includes receiver break error (RX_EBR_F), frame error (RX_EFR_F), parity error (RX_EPA_F) and receiver buffer overflow error (RX_OVER_F), transmit buffer overflow error (TX_OVER_F), receiver retry over limit error (RX_OVER_ERETRY) and transmitter retry over limit error (TX_OVER_ERETRY).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This field is the status flag of SC_TRSR [RX_EBR_F], SC_TRSR [RX_EFR_F], SC_TRSR [RX_EPA_F], SC_TRSR [RX_OVER_F], SC_TRSR [TX_OVER_F], SC_TRSR [RX_OVER_ERETRY] or SC_TRSR [TX_OVER_ERETRY].    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">So if software wants to clear this bit, software must write "1" to each field.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">TMR0_IS   </td><td class="markdownTableBodyLeft">Timer0 Interrupt Status Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field is used for TMR0 interrupt status flag.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only, but it can be cleared by writing "1" to it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">TMR1_IS   </td><td class="markdownTableBodyLeft">Timer1 Interrupt Status Flag (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field is used for TMR1 interrupt status flag.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only, but it can be cleared by writing "1" to it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">TMR2_IS   </td><td class="markdownTableBodyLeft">Timer2 Interrupt Status Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field is used for TMR2 interrupt status flag.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only, but it can be cleared by writing "1" to it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">BGT_IS   </td><td class="markdownTableBodyLeft">Block Guard Time Interrupt Status Flag (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field is used for block guard time interrupt status flag.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only, but it can be cleared by writing "1" to it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">CD_IS   </td><td class="markdownTableBodyLeft">Card Detect Interrupt Status Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field is used for card detect interrupt status flag.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The card detect status register is SC_PINCSR [CD_INS_F] and SC_PINCSR [CD_REM_F].    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This field is the status flag of SC_PINCSR [CD_INS_F] or SC_PINCSR [CD_REM_F].    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">So if software wants to clear this bit, software must write "1" to this field.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">INIT_IS   </td><td class="markdownTableBodyLeft">Initial End Interrupt Status Flag (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field is used for activation (SC_ALTCTL [ACT_EN]), deactivation (SC_ALTCTL [DACT_EN]) and warm reset (SC_ALTCTL [WARST_EN]) sequence interrupt status flag.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only, but it can be cleared by writing "1" to it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">RTMR_IS   </td><td class="markdownTableBodyLeft">Receiver Buffer Time-Out Interrupt Status Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field is used for receiver buffer time-out interrupt status flag.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This field is the status flag of receiver buffer time-out state.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If software wants to clear this bit, software must read the receiver buffer remaining data by reading SC_RBR register,.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[10]   </td><td class="markdownTableBodyCenter">ACON_ERR_IS   </td><td class="markdownTableBodyLeft">Auto Convention Error Interrupt Status Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field indicates auto convention sequence error.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the received TS at ATR state is not 0x3B or 0x3F, this bit will be set.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only, but can be cleared by writing "1" to it.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l07904">7904</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaa7679f758ebbdcf746f8b03195364b47" name="gaa7679f758ebbdcf746f8b03195364b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7679f758ebbdcf746f8b03195364b47">&#9670;&nbsp;</a></span>ISR <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t TIMER_T::ISR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md400"></a>
ISR</h1>
<h2><a class="anchor" id="autotoc_md401"></a>
Offset: 0x10  Timer x Interrupt Status Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">TMR_IS   </td><td class="markdownTableBodyLeft">Timer Interrupt Status    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates the interrupt status of Timer.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set by hardware when the up counting value of internal 24-bit counter matches the timer compared value (TMR_CMPR).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Write 1 to clear this bit to 0.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If this bit is active and TMR_IE (TMRx_IER[0]) is enabled, Timer will trigger an interrupt to CPU.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">TCAP_IS   </td><td class="markdownTableBodyLeft">Timer Capture Function Interrupt Status    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates the external pin function interrupt status of Timer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set by hardware when TCAP_EN (TMRx_CTL[16]) is set high, and the transition of external pin matches the TCAP_EDGE (TMRx_CTL[19:18]) setting.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Write 1 to clear this bit to 0.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If this bit is active and TCAP_IE (TMRx_IER[1]) is enabled, Timer will trigger an interrupt to CPU.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">TMR_WAKE_STS   </td><td class="markdownTableBodyLeft">Timer Wake-Up Status    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If timer causes CPU wakes up from power-down mode, this bit will be set to high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It must be cleared by software with a write 1 to this bit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Timer does not cause system wake-up.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Wakes system up from power-down mode by Timer timeout.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">NCAP_DET_STS   </td><td class="markdownTableBodyLeft">New Capture Detected Status    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This status is to indicate there is a new incoming capture event detected before CPU clearing the TCAP_IS (TMRx_ISR[1]) status.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the above condition occurred, the Timer will keep register TMRx_TCAP unchanged and drop the new capture value.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Write 1 to clear this bit to 0.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = New incoming capture event didn't detect before CPU clearing TCAP_IS (TMRx_ISR[1]) status.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = New incoming capture event detected before CPU clearing TCAP_IS (TMRx_ISR[1]) status.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">TCAP_IS_FEDGE   </td><td class="markdownTableBodyLeft">TC Pin Edge Detect Is Falling    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This flag indicates the edge detected in TC pin is rising edge or falling edge.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Timer only updates this flag when it updates the Timer Capture Data (TMR_TCAP[23:0]) value.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When a new incoming capture event detected before CPU clearing the TCAP_IS (TMRx_ISR[1]) status, Timer will keep this bit unchanged.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = TC pin edge detected is rising edge.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = TC pin edge detected is falling edge.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l09263">9263</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga1edf12aec26a4dccd41814cfb02dd949" name="ga1edf12aec26a4dccd41814cfb02dd949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1edf12aec26a4dccd41814cfb02dd949">&#9670;&nbsp;</a></span>ISR <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t UART_T::ISR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md414"></a>
ISR</h1>
<h2><a class="anchor" id="autotoc_md415"></a>
Offset: 0x10  UART Interrupt Status Register.</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">RDA_IS   </td><td class="markdownTableBodyLeft">Receive Data Available Interrupt Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the number of bytes in the RX-FIFO equals the RFITL then the RDA_IF will be set.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If RDA_IEN (UART_IER[0]) is set then the RDA interrupt will be generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No Receive Data available interrupt is generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Receive Data available interrupt is generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only and it will be cleared when the number of unread bytes of RX-FIFO drops below the threshold level (RFITL).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">THRE_IS   </td><td class="markdownTableBodyLeft">Transmit Holding Register Empty Interrupt Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set when the last data of TX-FIFO is transferred to Transmitter Shift Register.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If THRE_IEN (UART_IER[1]) is set that the THRE interrupt will be generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No Transmit Holding register empty interrupt is generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Transmit Holding register empty interrupt generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only and it will be cleared when writing data into THR (TX-FIFO not empty).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">RLS_IS   </td><td class="markdownTableBodyLeft">Receive Line Interrupt Status Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set when the RX received data has parity error (PE_F (UART_FSR[4])), framing error (FE_F (UART_FSR[5])), break error (BI_F (UART_FSR[6])) or RS-485 detect address byte (RS-485_ADDET_F (UART_TRSR[0])).If RLS_IE (UART_IER[2]) is set then the RLS interrupt will be generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No Receive Line interrupt is generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Receive Line interrupt is generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This bit is read only, but can be cleared by it by writing "1" to BI_F (UART_FSR[6]), FE_F (UART_FSR[5]), PE_F (UART_FSR[4]) or RS-485_ADDET_F (UART_TRSR[0]).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: This bit is cleared when the BI_F, FE_F, PE_F and RS-485_ADDET_F are cleared.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">MODEM_IS   </td><td class="markdownTableBodyLeft">MODEM Interrupt Status Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set when the CTSn pin has state change (DCTSF = "1").    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If MODEM_IEN (UART_IER[3]) is set then the modem interrupt will be generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No MODEM interrupt is generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = MODEM interrupt is generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only, but can be cleared by it by writing "1" to DCT_F (UART_MCSR[18]).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">RTO_IS   </td><td class="markdownTableBodyLeft">RX Time-Out Interrupt Status Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set when the RX-FIFO is not empty and no activities occur in the RX-FIFO and the time-out counter equal to TOIC.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If RTO_IE (UART_IER[4]) is set then the tout interrupt will be generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No RX Time-Out interrupt is generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RX Time-Out interrupt is generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only and user can read UART_RBR (RX is in active) to clear it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">BUF_ERR_IS   </td><td class="markdownTableBodyLeft">Buffer Error Interrupt Status Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set when the TX or RX-FIFO overflowed.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When BUF_ERR_IS is set, the transfer maybe not correct.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If BUF_ERR_IE (UART_IER[5]) is set then the buffer error interrupt will be generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No Buffer error interrupt is generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Buffer error interrupt is generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This bit is read only, but can be cleared by it by writing "1" to TX_OVER_F (UART_FSR[8]) or RX_OVER_F (UART_FSR[0]).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: This bit is cleared when both the TX_OVER_F and RX_OVER_F are cleared.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">WAKE_IS   </td><td class="markdownTableBodyLeft">Wake-Up Interrupt Status Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set in Power-down mode, the receiver received data or CTSn signal.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If WAKE_IE (UART_IER[6]) is set then the wake-up interrupt will be generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No Wake-Up interrupt is generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Wake-Up interrupt is generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only, but can be cleared by it by writing "1" to it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">ABAUD_IS   </td><td class="markdownTableBodyLeft">Auto-Baud Rate Interrupt Status Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set when auto-baud rate detection function finished or the auto-baud rate counter was overflow and if ABAUD_IE (UART_IER[7]) is set then the auto-baud rate interrupt will be generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No Auto-Baud Rate interrupt is generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Auto-Baud Rate interrupt is generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This bit is read only, but can be cleared by it by writing "1" to ABAUD_TOUT_F (UART_TRSR[2]) or ABAUD_F (UART_TRSR[1]).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: This bit is cleared when both the ABAUD_TOUT_F and ABAUD_F are cleared.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">LIN_IS   </td><td class="markdownTableBodyLeft">LIN Interrupt Status Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set when the LIN TX header transmitted, RX header received or the SIN does not equal SOUT and if LIN_IE(UART_IER[8]) is set then the LIN interrupt will be generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No LIN interrupt is generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = LIN interrupt is generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This bit is read only, but can be cleared by it by writing "1" to BIT_ERR_F (UART_TRSR[5]), LIN_TX_F (UART_TRSR[3]) or LIN_RX_F (UART_TRSR[4]).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: This bit is cleared when both the BIT_ERR_F, LIN_TX_F and LIN_RX_F are cleared.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l09732">9732</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gae3524d4eaae77066e138492763163bf9" name="gae3524d4eaae77066e138492763163bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3524d4eaae77066e138492763163bf9">&#9670;&nbsp;</a></span>ISR <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t WDT_T::ISR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md442"></a>
ISR</h1>
<h2><a class="anchor" id="autotoc_md443"></a>
Offset: 0x08  Watchdog Timer Interrupt Status Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">IS   </td><td class="markdownTableBodyLeft">Watchdog Timer Interrupt Status    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the Watchdog timer interrupt is enabled, then the hardware will set this bit to indicate that the Watchdog timer interrupt has occurred.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the Watchdog timer interrupt is not enabled, then this bit indicates that a time-out period has elapsed.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Watchdog timer interrupt did not occur.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Watchdog timer interrupt occurs.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only, but can be cleared by writing "1" to it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">RST_IS   </td><td class="markdownTableBodyLeft">Watchdog Timer Reset Status    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the Watchdog timer initiates a reset, the hardware will set this bit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This flag can be read by software to determine the source of reset.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Software is responsible to clear it manually by writing "1" to it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If WTRE is disabled, then the Watchdog timer has no effect on this bit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Watchdog timer reset did not occur.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Watchdog timer reset occurs.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only, but can be cleared by writing "1" to it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">WAKE_IS   </td><td class="markdownTableBodyLeft">Watchdog Timer Wake-Up Status    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If Watchdog timer causes system to wake up from power-down mode, this bit will be set to high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It must be cleared by software with a write "1" to this bit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Watchdog timer does not cause system wake-up.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Wake system up from power-down mode by Watchdog time-out.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: When system in power-down mode and watchdog time-out, hardware will set WDT_WAKE_IS and WDT_IS.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: After one engine clock, this bit can be cleared by writing "1" to it   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10392">10392</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga91b435e9c7adfdb9b41621709ba118c4" name="ga91b435e9c7adfdb9b41621709ba118c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91b435e9c7adfdb9b41621709ba118c4">&#9670;&nbsp;</a></span>ISRC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t GPIO_T::ISRC</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md192"></a>
ISRC</h1>
<h2><a class="anchor" id="autotoc_md193"></a>
Offset: 0x20  GPIO Port Interrupt Trigger Source Status Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">ISRC   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Interrupt Trigger Source Indicator    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Read :    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Port x[n] generate an interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No interrupt at Port x[n].    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Write:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Clear the correspond pending interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No action.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_ISRC, bits [15:6] are reserved.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l04631">4631</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga5bf08ac5aac385ff2ecd010d9178e3b5" name="ga5bf08ac5aac385ff2ecd010d9178e3b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5bf08ac5aac385ff2ecd010d9178e3b5">&#9670;&nbsp;</a></span>LDO_CTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SYS_T::LDO_CTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md166"></a>
LDO_CTL</h1>
<h2><a class="anchor" id="autotoc_md167"></a>
Offset: 0x70  LDO Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">LDO_PD   </td><td class="markdownTableBodyLeft">LDO Power Off    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a protected register. Please refer to open lock sequence to program it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set this bit high will off LDO and cause Chip in unexpected state. User must keep this bit low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = LDO Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = LDO Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3:2]   </td><td class="markdownTableBodyCenter">LDO_LEVEL   </td><td class="markdownTableBodyLeft">LDO Output Voltage Select    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a protected register. Please refer to open lock sequence to program it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = 1.6V.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = 1.8V.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = 1.8V.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l03509">3509</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga64ab49e4601427afac7133470a40e971" name="ga64ab49e4601427afac7133470a40e971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64ab49e4601427afac7133470a40e971">&#9670;&nbsp;</a></span>LIR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t RTC_T::LIR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md324"></a>
LIR</h1>
<h2><a class="anchor" id="autotoc_md325"></a>
Offset: 0x24  Leap Year Indicator Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">LIR   </td><td class="markdownTableBodyLeft">Leap Year Indication REGISTER (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = This year is not a leap year.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = This year is leap year.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l07229">7229</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga0c448c3fbb4d954410aaef7402d7ca7e" name="ga0c448c3fbb4d954410aaef7402d7ca7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c448c3fbb4d954410aaef7402d7ca7e">&#9670;&nbsp;</a></span>MCSR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t UART_T::MCSR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md420"></a>
MCSR</h1>
<h2><a class="anchor" id="autotoc_md421"></a>
Offset: 0x1C  UART Modem State Status Register.</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">LEV_RTS   </td><td class="markdownTableBodyLeft">RTSn Trigger Level    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit can change the RTSn trigger level.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = low level triggered.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = high level triggered.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: In RS-485 AUD mode and RTS Auto-flow control mode, hardware will control the output RTS pin automatically, so the table indicates the default value.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: The default setting in UART mode is LEV_RTS = "0" and RTS_ST = "1".    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">RTS_ST   </td><td class="markdownTableBodyLeft">RTSn Pin State (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is the pin status of RTSn.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RTS pin input is low level voltage logic state.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RTS pin input is high level voltage logic state.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">LEV_CTS   </td><td class="markdownTableBodyLeft">CTSn Trigger Level    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit can change the CTSn trigger level.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Low level triggered.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = High level triggered.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[17]   </td><td class="markdownTableBodyCenter">CTS_ST   </td><td class="markdownTableBodyLeft">CTSn Pin Status (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is the pin status of CTSn.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = CTS pin input is low level voltage logic state.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = CTS pin input is high level voltage logic state.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[18]   </td><td class="markdownTableBodyCenter">DCT_F   </td><td class="markdownTableBodyLeft">Detect CTSn State Change Status Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set whenever CTSn input has change state, and it will generate Modem interrupt to CPU when MODEM_IE (UART_IER[3]).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = CTS input has not change state.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = CTS input has change state.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only, but it can be cleared by writing "1" to it.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l09888">9888</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gab6cd1ed5436fe8fcb3548f5532c296f4" name="gab6cd1ed5436fe8fcb3548f5532c296f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6cd1ed5436fe8fcb3548f5532c296f4">&#9670;&nbsp;</a></span>MEM_0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t LCD_T::MEM_0</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md226"></a>
MEM_0</h1>
<h2><a class="anchor" id="autotoc_md227"></a>
Offset: 0x08  LCD SEG3 ~ SEG0 data</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">SEG_0_4x   </td><td class="markdownTableBodyLeft">SEG_0_4x DATA for COM0 ~ COM5 (x= 0 ~ 8)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LCD display data    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[14:8]   </td><td class="markdownTableBodyCenter">SEG_1_4x   </td><td class="markdownTableBodyLeft">SEG_1_4x DATA for COM0 ~ COM5 (x= 0 ~ 8)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LCD display data    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[21:16]   </td><td class="markdownTableBodyCenter">SEG_2_4x   </td><td class="markdownTableBodyLeft">SEG_2_4x DATA for COM0 ~ COM5 (x= 0 ~ 8)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LCD display data    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[29:24]   </td><td class="markdownTableBodyCenter">SEG_3_4x   </td><td class="markdownTableBodyLeft">SEG_3_4x DATA for COM0 ~ COM5 (x= 0 ~ 8)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LCD display data   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l05361">5361</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gab1e43837b252b800886b9cf0b88ab446" name="gab1e43837b252b800886b9cf0b88ab446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1e43837b252b800886b9cf0b88ab446">&#9670;&nbsp;</a></span>MEM_1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t LCD_T::MEM_1</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md228"></a>
MEM_1</h1>
<h2><a class="anchor" id="autotoc_md229"></a>
Offset: 0x0C  LCD SEG7 ~ SEG4 data</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">SEG_0_4x   </td><td class="markdownTableBodyLeft">SEG_0_4x DATA for COM0 ~ COM5 (x= 0 ~ 8)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LCD display data    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[14:8]   </td><td class="markdownTableBodyCenter">SEG_1_4x   </td><td class="markdownTableBodyLeft">SEG_1_4x DATA for COM0 ~ COM5 (x= 0 ~ 8)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LCD display data    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[21:16]   </td><td class="markdownTableBodyCenter">SEG_2_4x   </td><td class="markdownTableBodyLeft">SEG_2_4x DATA for COM0 ~ COM5 (x= 0 ~ 8)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LCD display data    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[29:24]   </td><td class="markdownTableBodyCenter">SEG_3_4x   </td><td class="markdownTableBodyLeft">SEG_3_4x DATA for COM0 ~ COM5 (x= 0 ~ 8)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LCD display data   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l05379">5379</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga9db343a2fe1219578e34ea71222ff9b3" name="ga9db343a2fe1219578e34ea71222ff9b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9db343a2fe1219578e34ea71222ff9b3">&#9670;&nbsp;</a></span>MEM_2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t LCD_T::MEM_2</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md230"></a>
MEM_2</h1>
<h2><a class="anchor" id="autotoc_md231"></a>
Offset: 0x10  LCD SEG11 ~ SEG8 data</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">SEG_0_4x   </td><td class="markdownTableBodyLeft">SEG_0_4x DATA for COM0 ~ COM5 (x= 0 ~ 8)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LCD display data    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[14:8]   </td><td class="markdownTableBodyCenter">SEG_1_4x   </td><td class="markdownTableBodyLeft">SEG_1_4x DATA for COM0 ~ COM5 (x= 0 ~ 8)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LCD display data    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[21:16]   </td><td class="markdownTableBodyCenter">SEG_2_4x   </td><td class="markdownTableBodyLeft">SEG_2_4x DATA for COM0 ~ COM5 (x= 0 ~ 8)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LCD display data    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[29:24]   </td><td class="markdownTableBodyCenter">SEG_3_4x   </td><td class="markdownTableBodyLeft">SEG_3_4x DATA for COM0 ~ COM5 (x= 0 ~ 8)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LCD display data   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l05397">5397</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga7793dcf6f3123c7912c19b5bfc8d02b2" name="ga7793dcf6f3123c7912c19b5bfc8d02b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7793dcf6f3123c7912c19b5bfc8d02b2">&#9670;&nbsp;</a></span>MEM_3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t LCD_T::MEM_3</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md232"></a>
MEM_3</h1>
<h2><a class="anchor" id="autotoc_md233"></a>
Offset: 0x14  LCD SEG15 ~ SEG12 data</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">SEG_0_4x   </td><td class="markdownTableBodyLeft">SEG_0_4x DATA for COM0 ~ COM5 (x= 0 ~ 8)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LCD display data    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[14:8]   </td><td class="markdownTableBodyCenter">SEG_1_4x   </td><td class="markdownTableBodyLeft">SEG_1_4x DATA for COM0 ~ COM5 (x= 0 ~ 8)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LCD display data    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[21:16]   </td><td class="markdownTableBodyCenter">SEG_2_4x   </td><td class="markdownTableBodyLeft">SEG_2_4x DATA for COM0 ~ COM5 (x= 0 ~ 8)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LCD display data    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[29:24]   </td><td class="markdownTableBodyCenter">SEG_3_4x   </td><td class="markdownTableBodyLeft">SEG_3_4x DATA for COM0 ~ COM5 (x= 0 ~ 8)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LCD display data   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l05415">5415</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga96d137308b430ea8cedaa9f61c989fee" name="ga96d137308b430ea8cedaa9f61c989fee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96d137308b430ea8cedaa9f61c989fee">&#9670;&nbsp;</a></span>MEM_4</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t LCD_T::MEM_4</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md234"></a>
MEM_4</h1>
<h2><a class="anchor" id="autotoc_md235"></a>
Offset: 0x18  LCD SEG19 ~ SEG16 data</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">SEG_0_4x   </td><td class="markdownTableBodyLeft">SEG_0_4x DATA for COM0 ~ COM5 (x= 0 ~ 8)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LCD display data    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[14:8]   </td><td class="markdownTableBodyCenter">SEG_1_4x   </td><td class="markdownTableBodyLeft">SEG_1_4x DATA for COM0 ~ COM5 (x= 0 ~ 8)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LCD display data    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[21:16]   </td><td class="markdownTableBodyCenter">SEG_2_4x   </td><td class="markdownTableBodyLeft">SEG_2_4x DATA for COM0 ~ COM5 (x= 0 ~ 8)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LCD display data    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[29:24]   </td><td class="markdownTableBodyCenter">SEG_3_4x   </td><td class="markdownTableBodyLeft">SEG_3_4x DATA for COM0 ~ COM5 (x= 0 ~ 8)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LCD display data   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l05433">5433</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga6122c7c7d934773037c46d82fba6f478" name="ga6122c7c7d934773037c46d82fba6f478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6122c7c7d934773037c46d82fba6f478">&#9670;&nbsp;</a></span>MEM_5</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t LCD_T::MEM_5</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md236"></a>
MEM_5</h1>
<h2><a class="anchor" id="autotoc_md237"></a>
Offset: 0x1C  LCD SEG23 ~ SEG20 data</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">SEG_0_4x   </td><td class="markdownTableBodyLeft">SEG_0_4x DATA for COM0 ~ COM5 (x= 0 ~ 8)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LCD display data    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[14:8]   </td><td class="markdownTableBodyCenter">SEG_1_4x   </td><td class="markdownTableBodyLeft">SEG_1_4x DATA for COM0 ~ COM5 (x= 0 ~ 8)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LCD display data    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[21:16]   </td><td class="markdownTableBodyCenter">SEG_2_4x   </td><td class="markdownTableBodyLeft">SEG_2_4x DATA for COM0 ~ COM5 (x= 0 ~ 8)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LCD display data    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[29:24]   </td><td class="markdownTableBodyCenter">SEG_3_4x   </td><td class="markdownTableBodyLeft">SEG_3_4x DATA for COM0 ~ COM5 (x= 0 ~ 8)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LCD display data   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l05451">5451</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga860a61f5f5ec937b5eea163d8fe101c1" name="ga860a61f5f5ec937b5eea163d8fe101c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga860a61f5f5ec937b5eea163d8fe101c1">&#9670;&nbsp;</a></span>MEM_6</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t LCD_T::MEM_6</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md238"></a>
MEM_6</h1>
<h2><a class="anchor" id="autotoc_md239"></a>
Offset: 0x20  LCD SEG27 ~ SEG24 data</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">SEG_0_4x   </td><td class="markdownTableBodyLeft">SEG_0_4x DATA for COM0 ~ COM5 (x= 0 ~ 8)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LCD display data    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[14:8]   </td><td class="markdownTableBodyCenter">SEG_1_4x   </td><td class="markdownTableBodyLeft">SEG_1_4x DATA for COM0 ~ COM5 (x= 0 ~ 8)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LCD display data    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[21:16]   </td><td class="markdownTableBodyCenter">SEG_2_4x   </td><td class="markdownTableBodyLeft">SEG_2_4x DATA for COM0 ~ COM5 (x= 0 ~ 8)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LCD display data    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[29:24]   </td><td class="markdownTableBodyCenter">SEG_3_4x   </td><td class="markdownTableBodyLeft">SEG_3_4x DATA for COM0 ~ COM5 (x= 0 ~ 8)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LCD display data   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l05469">5469</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga104d8922b3f16e323b034efca7d01d7e" name="ga104d8922b3f16e323b034efca7d01d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga104d8922b3f16e323b034efca7d01d7e">&#9670;&nbsp;</a></span>MEM_7</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t LCD_T::MEM_7</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md240"></a>
MEM_7</h1>
<h2><a class="anchor" id="autotoc_md241"></a>
Offset: 0x24  LCD SEG31 ~ SEG28 data</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">SEG_0_4x   </td><td class="markdownTableBodyLeft">SEG_0_4x DATA for COM0 ~ COM5 (x= 0 ~ 8)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LCD display data    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[14:8]   </td><td class="markdownTableBodyCenter">SEG_1_4x   </td><td class="markdownTableBodyLeft">SEG_1_4x DATA for COM0 ~ COM5 (x= 0 ~ 8)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LCD display data    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[21:16]   </td><td class="markdownTableBodyCenter">SEG_2_4x   </td><td class="markdownTableBodyLeft">SEG_2_4x DATA for COM0 ~ COM5 (x= 0 ~ 8)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LCD display data    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[29:24]   </td><td class="markdownTableBodyCenter">SEG_3_4x   </td><td class="markdownTableBodyLeft">SEG_3_4x DATA for COM0 ~ COM5 (x= 0 ~ 8)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LCD display data   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l05487">5487</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga14cd3a29e195b15b5e8c9acef7ba7115" name="ga14cd3a29e195b15b5e8c9acef7ba7115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14cd3a29e195b15b5e8c9acef7ba7115">&#9670;&nbsp;</a></span>MEM_8</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t LCD_T::MEM_8</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md242"></a>
MEM_8</h1>
<h2><a class="anchor" id="autotoc_md243"></a>
Offset: 0x28  LCD SEG35 ~ SEG32 data</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">SEG_0_4x   </td><td class="markdownTableBodyLeft">SEG_0_4x DATA for COM0 ~ COM5 (x= 0 ~ 8)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LCD display data    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[14:8]   </td><td class="markdownTableBodyCenter">SEG_1_4x   </td><td class="markdownTableBodyLeft">SEG_1_4x DATA for COM0 ~ COM5 (x= 0 ~ 8)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LCD display data    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[21:16]   </td><td class="markdownTableBodyCenter">SEG_2_4x   </td><td class="markdownTableBodyLeft">SEG_2_4x DATA for COM0 ~ COM5 (x= 0 ~ 8)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LCD display data    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[29:24]   </td><td class="markdownTableBodyCenter">SEG_3_4x   </td><td class="markdownTableBodyLeft">SEG_3_4x DATA for COM0 ~ COM5 (x= 0 ~ 8)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LCD display data   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l05505">5505</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga9b446461dd6a5701eda33387d5cdb016" name="ga9b446461dd6a5701eda33387d5cdb016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b446461dd6a5701eda33387d5cdb016">&#9670;&nbsp;</a></span>MODCR0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t ACMP_T::MODCR0</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md6"></a>
MODCR0</h1>
<h2><a class="anchor" id="autotoc_md7"></a>
Offset: 0x10  Analog Comparator 0 Mode Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1:0]   </td><td class="markdownTableBodyCenter">MOD_SEL   </td><td class="markdownTableBodyLeft">Comparator Mode Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Normal Comparator Mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Sigma-Delta ADC Mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Single Slope ADC Mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">TMR_SEL   </td><td class="markdownTableBodyLeft">Analog Comparator 0 Co-Operation Timer Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Select TIMER0 as co-operation Timer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Select TIMER2 as co-operation Timer.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">TMR_TRI_LV   </td><td class="markdownTableBodyLeft">Timer Trigger Level    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is for Sigma-Delta ADC Mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Comparator Output Low to High to Enable Timer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Comparator Output High to Low to Enable Timer.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6:4]   </td><td class="markdownTableBodyCenter">CH_DIS_PIN_SEL   </td><td class="markdownTableBodyLeft">Charge Or Discharge Pin Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">000 = PA.1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">001 = PA.2.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">010 = PA.3.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">011 = PA.4.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">100 = PA.5.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">101 = PA.6.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">110 = PA.14.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">111 = PF.5.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">CH_DIS_FUN_SEL   </td><td class="markdownTableBodyLeft">Charge Or Discharge Pin Function Option    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is for Single Slope ADC Mode only.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Drive low on charge pin to dis-charge capacitor and drive high on charge pin to charge capacitor.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Drive high on charge pin to dis-charge capacitor and drive low on charge pin to charge capacitor.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">START   </td><td class="markdownTableBodyLeft">Start ADC Mode    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Stop Sigma-Delta ADC Mode or Single Slope ADC Mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Start Sigma-Delta ADC Mode or Single Slope ADC Mode.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l00287">287</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga6615e3d0c9a7c79f9586507567ca43c8" name="ga6615e3d0c9a7c79f9586507567ca43c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6615e3d0c9a7c79f9586507567ca43c8">&#9670;&nbsp;</a></span>OE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::OE</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md258"></a>
OE</h1>
<h2><a class="anchor" id="autotoc_md259"></a>
Offset: 0x14  PWM Output Enable for PWM0~PWM3</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">CH0_OE   </td><td class="markdownTableBodyLeft">PWM CH0 Output Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM CH0 output to pin Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM CH0 output to pin Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">CH1_OE   </td><td class="markdownTableBodyLeft">PWM CH1 Output Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM CH1 output to pin Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM CH1 output to pin Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">CH2_OE   </td><td class="markdownTableBodyLeft">PWM CH2 Output Enable Control R    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM CH2 output to pin Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM CH2 output to pin Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">CH3_OE   </td><td class="markdownTableBodyLeft">PWM CH3 Output Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM CH3 output to pin Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM CH3 output to pin Enabled.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l05930">5930</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaef33c98df44df03b96cd70ca24c62fc4" name="gaef33c98df44df03b96cd70ca24c62fc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef33c98df44df03b96cd70ca24c62fc4">&#9670;&nbsp;</a></span>OFFD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t GPIO_T::OFFD</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md178"></a>
OFFD</h1>
<h2><a class="anchor" id="autotoc_md179"></a>
Offset: 0x04  GPIO Port Pin OFF Digital Enable Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">OFFD   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Digital Input Path Disable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Determine if the digital input path of GPIO port [x] pin [n] is disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Digital input path of GPIO port [x] pin [n] Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Digital input path of GPIO port [x] pin [n] Disabled (tied digital input to low).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_OFFD, bits [31:22] are reserved.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l04228">4228</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga92edc95845e792155315a0147ae3d408" name="ga92edc95845e792155315a0147ae3d408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92edc95845e792155315a0147ae3d408">&#9670;&nbsp;</a></span>PA_H_MFP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SYS_T::PA_H_MFP</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md138"></a>
PA_H_MFP</h1>
<h2><a class="anchor" id="autotoc_md139"></a>
Offset: 0x34  Port A High Byte Multiple Function Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3:0]   </td><td class="markdownTableBodyCenter">PA8_MFP   </td><td class="markdownTableBodyLeft">PA.8 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOA[8]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0100 = SmartCard0 Power pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[7:4]   </td><td class="markdownTableBodyCenter">PA9_MFP   </td><td class="markdownTableBodyLeft">PA.9 Pin Function Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOA[9]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0100 = SmartCard0 RST pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[11:8]   </td><td class="markdownTableBodyCenter">PA10_MFP   </td><td class="markdownTableBodyLeft">PA.10 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOA[10]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0100 = SmartCard0 CLK pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[15:12]   </td><td class="markdownTableBodyCenter">PA11_MFP   </td><td class="markdownTableBodyLeft">PA.11 Pin Function Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOA[11]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0010 = ADC external trigger input.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0100 = SmartCard0 DATA pin(SC0_UART_RXD)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[18:16]   </td><td class="markdownTableBodyCenter">PA12_MFP   </td><td class="markdownTableBodyLeft">PA.12 Pin Function Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOA[12]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0011 = Comparator1 P-end input    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0101 = I2C 0 clock pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0110 = SPI1 1st MOSI (Master Out, Slave In) pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0111 = UART0 Data transmitter output pin(This pin could modulate with PWM0 output. Please refer PWM_SEL(UARTx_CTL[26:24])).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 19 at 48-pin package    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[22:20]   </td><td class="markdownTableBodyCenter">PA13_MFP   </td><td class="markdownTableBodyLeft">PA.13 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOA[13]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0011 = Comparator1 N-end input    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0101 = I2C0 data I/O pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0110 = SPI1 1st MISO (Master In, Slave Out) pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0111 = UART0 Data receiver input pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 18 at 48-pin package    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[26:24]   </td><td class="markdownTableBodyCenter">PA14_MFP   </td><td class="markdownTableBodyLeft">PA.14 Pin Function Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOA[14]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0101 = I2C1 clock pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0110 = SPI1 serial clock pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 17 at 48-pin package, LCD segment output 31 at 64-pin package    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1001 = Comparator0 charge/discharge path    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[31:28]   </td><td class="markdownTableBodyCenter">PA15_MFP   </td><td class="markdownTableBodyLeft">PA.15 Pin Function Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOA[15]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0010 = Timer3 capture input    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0011 = Comparator1 output    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0101 = I2C1 data I/O pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0110 = SPI1 1st slave select pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 16 at 48-pin package, LCD segment output 30 at 64-pin package   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l02941">2941</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaea4dc4bb849dc1fb9f683dd91695221c" name="gaea4dc4bb849dc1fb9f683dd91695221c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea4dc4bb849dc1fb9f683dd91695221c">&#9670;&nbsp;</a></span>PA_L_MFP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SYS_T::PA_L_MFP</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md136"></a>
PA_L_MFP</h1>
<h2><a class="anchor" id="autotoc_md137"></a>
Offset: 0x30  Port A Low Byte Multiple Function Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3:0]   </td><td class="markdownTableBodyCenter">PA0_MFP   </td><td class="markdownTableBodyLeft">PA.0 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOA[0]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0010 = ADC input channel 0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[6:4]   </td><td class="markdownTableBodyCenter">PA1_MFP   </td><td class="markdownTableBodyLeft">PA.1 Pin Function Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOA[1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0010 = ADC analog input1    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0011 = Comparator0 P-end input3    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1001 = Comparator0 charge/discharge path    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[11:8]   </td><td class="markdownTableBodyCenter">PA2_MFP   </td><td class="markdownTableBodyLeft">PA.2 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOA[2]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0001 = External interrupt0 input pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0010 = ADC analog input2    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0011 = Comparator0 P-end input2    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0100 = SmartCard0 clock pin(SC0_UART_TXD)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1001 = Comparator0 charge/discharge path    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[14:12]   </td><td class="markdownTableBodyCenter">PA3_MFP   </td><td class="markdownTableBodyLeft">PA.3 Pin Function Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOA[3]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0001 = External interrupt 1    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0010 = ADC analog input3    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0011 = Comparator0 P-end input1    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0100 = SmartCard0 DATA pin(SC0_UART_RXD)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1001 = Comparator0 charge/discharge path    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[19:16]   </td><td class="markdownTableBodyCenter">PA4_MFP   </td><td class="markdownTableBodyLeft">PA.4 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOA[4]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0010 = ADC analog input4    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0011 = Comparator0 P-end input0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0100 = SmartCard0 card detect pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1001 = Comparator0 charge/discharge path    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23:20]   </td><td class="markdownTableBodyCenter">PA5_MFP   </td><td class="markdownTableBodyLeft">PA.5 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOA[5]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0010 = ADC analog input5    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0011 = Comparator0 N-end input0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0100 = SmartCard0 Power pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0101 = I2C1 data I/O pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0110 = SPI1 1st slave select pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1001 = Comparator0 charge/discharge path    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[27:24]   </td><td class="markdownTableBodyCenter">PA6_MFP   </td><td class="markdownTableBodyLeft">PA.6 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOA[6]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0010 = ADC analog input6    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0011 = Comparator0 output    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0100 = SmartCard0 RST pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1001 = Comparator0 charge/discharge path    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:28]   </td><td class="markdownTableBodyCenter">PA7_MFP   </td><td class="markdownTableBodyLeft">PA.7 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOA[7]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0010 = ADC input channel 7    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0100 = SmartCard1 card detect   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l02891">2891</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga6a0729014977cbc03210e17bc3eb0f67" name="ga6a0729014977cbc03210e17bc3eb0f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a0729014977cbc03210e17bc3eb0f67">&#9670;&nbsp;</a></span>PB_H_MFP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SYS_T::PB_H_MFP</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md142"></a>
PB_H_MFP</h1>
<h2><a class="anchor" id="autotoc_md143"></a>
Offset: 0x3C  Port B High Byte Multiple Function Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3:0]   </td><td class="markdownTableBodyCenter">PB8_MFP   </td><td class="markdownTableBodyLeft">PB.8 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOB[8]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0001 = External interrupt1 input pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0010 = Timer0 external counter input or Timer0 toggle out.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0011 = PWM0 Channel0 output    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0100 = Snooper pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 32 at 100-pin package    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[7:4]   </td><td class="markdownTableBodyCenter">PB9_MFP   </td><td class="markdownTableBodyLeft">PB.9 Pin Function Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOB[9]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0011 = PWM0 Channel1 output    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 31 at 100-pin package    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[11:8]   </td><td class="markdownTableBodyCenter">PB10_MFP   </td><td class="markdownTableBodyLeft">PB.10 Pin Function Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOB[10]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0110 = SPI0 2nd MOSI (Master Out, Slave In) pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0111 = UART1 Data receiver input pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 24 at 64-pin package, LCD segment output 28 at 100-pin package    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:12]   </td><td class="markdownTableBodyCenter">PB11_MFP   </td><td class="markdownTableBodyLeft">PB.11 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOB[11]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0010 = Timer1 external counter input or Timer1 toggle out    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0110 = SPI0 2nd MISO (Master In, Slave Out) pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0111 = UART1 Request to Send output pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 23 at 64-pin package, LCD segment output 27 at 100-pin package    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[19:16]   </td><td class="markdownTableBodyCenter">PB12_MFP   </td><td class="markdownTableBodyLeft">PB.12 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOB[12]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0001 = Frequency Divider0 output pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0010 = Timer0 external counter input or Timer0 toggle out.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0110 = SPI0 1st MOSI (Master Out, Slave In) pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0111 = UART0 Request to Send output pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 15 at 48-pin package, LCD segment output 22 at 64-pin package, LCD segment output 26 at 100-pin package    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[23:20]   </td><td class="markdownTableBodyCenter">PB13_MFP   </td><td class="markdownTableBodyLeft">PB.13 Pin Function Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOB[13]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0110 = SPI0 1st MISO (Master In, Slave Out) pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0111 = UART0 Data receiver input pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 14 at 48-pin package, LCD segment output 21 at 64-pin package, LCD segment output 25 at 100-pin package    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[27:24]   </td><td class="markdownTableBodyCenter">PB14_MFP   </td><td class="markdownTableBodyLeft">PB.14 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOB[14]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0110 = SPI0 serial clock pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0111 = UART0 Data transmitter output pin(This pin could modulate with PWM0 output)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 13 at 48-pin package, LCD segment output 20 at 64-pin package, LCD segment output 24 at 100-pin package    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[31:28]   </td><td class="markdownTableBodyCenter">PB15_MFP   </td><td class="markdownTableBodyLeft">PB.15 Pin Function Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOB[15]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0110 = SPI0 1st slave select pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0111 = UART0 Clear to Send input pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 12 at 48-pin package, LCD segment output 19 at 64-pin package, LCD segment output 23 at 100-pin package   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l03050">3050</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaa34e4f826e465a1b5316d5d8286d77d3" name="gaa34e4f826e465a1b5316d5d8286d77d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa34e4f826e465a1b5316d5d8286d77d3">&#9670;&nbsp;</a></span>PB_L_MFP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SYS_T::PB_L_MFP</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md140"></a>
PB_L_MFP</h1>
<h2><a class="anchor" id="autotoc_md141"></a>
Offset: 0x38  Port B Low Byte Multiple Function Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3:0]   </td><td class="markdownTableBodyCenter">PB0_MFP   </td><td class="markdownTableBodyLeft">PB.0 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOB[0]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0001 = Frequency Divider1 output pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0111 = UART0 Data transmitter output pin(This pin could modulate with PWM0 output. Please refer PWM_SEL(UARTx_CTL[26:24])).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 29 at 64-pin package    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[7:4]   </td><td class="markdownTableBodyCenter">PB1_MFP   </td><td class="markdownTableBodyLeft">PB.1 Pin Function Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOB[1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0001 = External interrupt1 input pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0010 = Timer 2 capture input    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0111 = UART0 Data receiver input pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 28 at 64-pin package    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[11:8]   </td><td class="markdownTableBodyCenter">PB2_MFP   </td><td class="markdownTableBodyLeft">PB.2 Pin Function Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOB[2]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0010 = Timer3 external counter input    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0101 = I2C0 clock pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0110 = SPI1 2nd MOSI (Master Out, Slave In) pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0111 = UART0 Request to Send output pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 27 at 64-pin package    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:12]   </td><td class="markdownTableBodyCenter">PB3_MFP   </td><td class="markdownTableBodyLeft">PB.3 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOB[3]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0010 = Timer2 external counter input    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0101 = I2C0 data I/O pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0110 = SPI1 2nd MISO (Master In, Slave Out) pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0111 = UART0 Clear to Send input pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 26 at 64-pin package    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[19:16]   </td><td class="markdownTableBodyCenter">PB4_MFP   </td><td class="markdownTableBodyLeft">PB.4 Pin Function Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOB[4]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0110 = SPI1 2nd MISO (Master In, Slave Out) pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0111 = UART1 Request to Send output pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[23:20]   </td><td class="markdownTableBodyCenter">PB5_MFP   </td><td class="markdownTableBodyLeft">PB.5 Pin Function Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOB[5]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0110 = SPI1 2nd MOSI (Master Out, Slave In) pin SmartCard0 RST    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0111 = UART1 Data receiver input pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 35 at 100-pin package    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[27:24]   </td><td class="markdownTableBodyCenter">PB6_MFP   </td><td class="markdownTableBodyLeft">PB.6 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOB[6]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0001 = Frequency Divider0 output pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0110 = SPI1 2nd slave select pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0111 = UART1 Data transmitter output pin(This pin could modulate with PWM0 output. Please refer PWM_SEL(UARTx_CTL[26:24])).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 25 at 64-pin package, LCD segment output 34 at 100-pin package    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:28]   </td><td class="markdownTableBodyCenter">PB7_MFP   </td><td class="markdownTableBodyLeft">PB.7 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOB[7]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0100 = SmartCard0 card detect    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0111 = UART1 Clear to Send input pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 33 at 100-pin package   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l02996">2996</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga6ee16e76c17384504294d4fec1d85264" name="ga6ee16e76c17384504294d4fec1d85264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ee16e76c17384504294d4fec1d85264">&#9670;&nbsp;</a></span>PC_H_MFP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SYS_T::PC_H_MFP</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md146"></a>
PC_H_MFP</h1>
<h2><a class="anchor" id="autotoc_md147"></a>
Offset: 0x44  Port C High Byte Multiple Function Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3:0]   </td><td class="markdownTableBodyCenter">PC8_MFP   </td><td class="markdownTableBodyLeft">PC.8 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOC[8]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0100 = SmartCard0 RST pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0111 = UART1 Data transmitter output pin(This pin could modulate with PWM0 output. Please refer PWM_SEL(UARTx_CTL[26:24])).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 3 at 48-pin package, LCD segment output 10 at 64-pin package, LCD segment output 14 at 100-pin package    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[7:4]   </td><td class="markdownTableBodyCenter">PC9_MFP   </td><td class="markdownTableBodyLeft">PC.9 Pin Function Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 2 at 48-pin package, LCD segment output 9 at 64-pin package, LCD segment output 13 at 100-pin package    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOC[9]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[11:8]   </td><td class="markdownTableBodyCenter">PC10_MFP   </td><td class="markdownTableBodyLeft">PC.10 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOC[10]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0100 = SmartCard1 card detect    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0101 = I2C1 clock pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 12 at 100-pin package    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[15:12]   </td><td class="markdownTableBodyCenter">PC11_MFP   </td><td class="markdownTableBodyLeft">PC.11 Pin Function Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOC[11]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0100 = SmartCard1 PWR pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0101 = I2C 1 data I/O pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 11 at 100-pin package    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[19:16]   </td><td class="markdownTableBodyCenter">PC12_MFP   </td><td class="markdownTableBodyLeft">PC.12 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOC[12]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0100 = SmartCard1 clock pin(SC1_UART_TXD)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 10 at 100-pin package    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23:20]   </td><td class="markdownTableBodyCenter">PC13_MFP   </td><td class="markdownTableBodyLeft">PC.13 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOC[13]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0100 = SmartCard1 DATA pin(SC1_UART_RXD)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 9 at 100-pin package    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[27:24]   </td><td class="markdownTableBodyCenter">PC14_MFP   </td><td class="markdownTableBodyLeft">PC.14 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOC[14]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0100 = SmartCard1 card detect    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 1 at 48-pin package, LCD segment output 8 at 64-pin package, LCD segment output 8 at 100-pin package    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:28]   </td><td class="markdownTableBodyCenter">PC15_MFP   </td><td class="markdownTableBodyLeft">PC.15 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOC[15]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0100 = SmartCard1 PWR pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 0 at 48-pin package, LCD segment output 7 at 64-pin package, LCD segment output 7 at 100-pin package   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l03145">3145</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga4dff3844e17550fa00b70ce8c4269acf" name="ga4dff3844e17550fa00b70ce8c4269acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4dff3844e17550fa00b70ce8c4269acf">&#9670;&nbsp;</a></span>PC_L_MFP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SYS_T::PC_L_MFP</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md144"></a>
PC_L_MFP</h1>
<h2><a class="anchor" id="autotoc_md145"></a>
Offset: 0x40  Port C Low Byte Multiple Function Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3:0]   </td><td class="markdownTableBodyCenter">PC0_MFP   </td><td class="markdownTableBodyLeft">PC.0 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOC[0]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0011 = PWM0 Channel0 output    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0101 = I2C0 clock pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0110 = SPI0 2nd slave select pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 11 at 48-pin package, LCD segment output 18 at 64-pin package, LCD segment output 22 at 100-pin package    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:4]   </td><td class="markdownTableBodyCenter">PC1_MFP   </td><td class="markdownTableBodyLeft">PC.1 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOC[1]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0011 = PWM0 Channel1 output    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0101 = I2C0 data I/O pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 10 at 48-pin package, LCD segment output 17 at 64-pin package, LCD segment output 21 at 100-pin package    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[11:8]   </td><td class="markdownTableBodyCenter">PC2_MFP   </td><td class="markdownTableBodyLeft">PC.2 Pin Function Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOC[2]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0011 = PWM0 Channel2 output    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0101 = I2C1 clock pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 9 at 48-pin package, LCD segment output 16 at 64-pin package, LCD segment output 20 at 100-pin package    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:12]   </td><td class="markdownTableBodyCenter">PC3_MFP   </td><td class="markdownTableBodyLeft">PC.3 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOC[3]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0011 = PWM0 Channel3 output    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0101 = I2C1 data I/O pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 8 at 48-pin package, LCD segment output 15 at 64-pin package, LCD segment output 19 at 100-pin package    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[19:16]   </td><td class="markdownTableBodyCenter">PC4_MFP   </td><td class="markdownTableBodyLeft">PC.4 Pin Function Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOC[4]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0001 = External interrupt0 input pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0100 = SmartCard0 clock pin(SC0_UART_TXD)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0111 = UART1 Clear to Send input pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 7 at 48-pin package, LCD segment output 14 at 64-pin package, LCD segment output 18 at 100-pin package    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[23:20]   </td><td class="markdownTableBodyCenter">PC5_MFP   </td><td class="markdownTableBodyLeft">PC.5 Pin Function Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOC[5]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0100 = SmartCard0 card detect pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 6 at 48-pin package, LCD segment output 13 at 64-pin package, LCD segment output 17 at 100-pin package    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[27:24]   </td><td class="markdownTableBodyCenter">PC6_MFP   </td><td class="markdownTableBodyLeft">PC.6 Pin Function Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOC[6]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0100 = SmartCard0 DATA pin(SC0_UART_RXD)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0111 = UART1 Request to Send output pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 5 at 48-pin package, LCD segment output 12 at 64-pin package, LCD segment output 16 at 100-pin package    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:28]   </td><td class="markdownTableBodyCenter">PC7_MFP   </td><td class="markdownTableBodyLeft">PC.7 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOC[7]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0100 = SmartCard0 Power pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0111 = UART1 Data receiver input pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 4 at 48-pin package, LCD segment output 11 at 64-pin package, LCD segment output 15 at 100-pin package   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l03101">3101</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga90efc4877dec8729f297074457da943a" name="ga90efc4877dec8729f297074457da943a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90efc4877dec8729f297074457da943a">&#9670;&nbsp;</a></span>PD_H_MFP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SYS_T::PD_H_MFP</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md150"></a>
PD_H_MFP</h1>
<h2><a class="anchor" id="autotoc_md151"></a>
Offset: 0x4C  Port D High Byte Multiple Function Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2:0]   </td><td class="markdownTableBodyCenter">PD8_MFP   </td><td class="markdownTableBodyLeft">PD.8 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOD[8]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0100 = SmartCard1 DATA pin(SC1_UART_RXD)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD common output 2 at 48-pin, LCD common output 2 at 64-pin package, LCD common output 2 at 100-pin package    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6:4]   </td><td class="markdownTableBodyCenter">PD9_MFP   </td><td class="markdownTableBodyLeft">PD.9 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOD[9]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0011 = PWM0 Channel3 output    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0100 = SmartCard1 RST pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD common output 1 at 48-pin, LCD common output 1 at 64-pin package, LCD common output 1 at 100-pin package    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[10:8]   </td><td class="markdownTableBodyCenter">PD10_MFP   </td><td class="markdownTableBodyLeft">PD.10 Pin Function Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOD[10]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0010 = Timer1 capture input    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0011 = PWM0 Channel2 output    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD common output 0 at 48-pin, LCD common output 0 at 64-pin package, LCD common output 0 at 100-pin package    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[14:12]   </td><td class="markdownTableBodyCenter">PD11_MFP   </td><td class="markdownTableBodyLeft">PD.11 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOD[11]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0010 = Timer0 capture input    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0011 = PWM0 Channel1 output    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD external capacitor pin of charge pump circuit at 64-pin package, LCD external capacitor pin of charge pump circuit at 100-pin package    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[18:16]   </td><td class="markdownTableBodyCenter">PD12_MFP   </td><td class="markdownTableBodyLeft">PD.12 Pin Function Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOD[12]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0001 = Frequency Divider0 output pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0010 = Timer1 external counter input or Timer1 toggle out    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0011 = PWM0 Channel0 output    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD external capacitor pin of charge pump circuit at 64-pin package, LCD external capacitor pin of charge pump circuit at 100-pin package    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1001 = 1, 1/2, 1/4, 1/16 Hz clock output    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[22:20]   </td><td class="markdownTableBodyCenter">PD13_MFP   </td><td class="markdownTableBodyLeft">PD.13 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOD[13]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0001 = External interrupt 1 input pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD Unit voltage for LCD charge pump circuit at 48-pin package, LCD Unit voltage for LCD charge pump circuit at 64-pin package, LCD Unit voltage for LCD charge pump circuit at 100-pin package    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[27:24]   </td><td class="markdownTableBodyCenter">PD14_MFP   </td><td class="markdownTableBodyLeft">PD.14 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOD[14]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD Unit voltage for LCD charge pump circuit at 48-pin package, LCD Unit voltage for LCD charge pump circuit at 64-pin package, LCD Unit voltage for LCD charge pump circuit at 100-pin package    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[30:28]   </td><td class="markdownTableBodyCenter">PD15_MFP   </td><td class="markdownTableBodyLeft">PD.15 Pin Function Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOD[15]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD Unit voltage for LCD charge pump circuit at 48-pin package, LCD Unit voltage for LCD charge pump circuit at 64-pin package, LCD Unit voltage for LCD charge pump circuit at 100-pin package   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l03227">3227</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga8eeac00dfcf4487bff6bba055f2fbe2e" name="ga8eeac00dfcf4487bff6bba055f2fbe2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8eeac00dfcf4487bff6bba055f2fbe2e">&#9670;&nbsp;</a></span>PD_L_MFP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SYS_T::PD_L_MFP</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md148"></a>
PD_L_MFP</h1>
<h2><a class="anchor" id="autotoc_md149"></a>
Offset: 0x48  Port D Low Byte Multiple Function Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3:0]   </td><td class="markdownTableBodyCenter">PD0_MFP   </td><td class="markdownTableBodyLeft">PD.0 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOD[0]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 6 at 64-pin package, LCD segment output 6 at 100-pin package    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[7:4]   </td><td class="markdownTableBodyCenter">PD1_MFP   </td><td class="markdownTableBodyLeft">PD.1 Pin Function Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOD[1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 5 at 64-pin package, LCD segment output 5 at 100-pin package    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[11:8]   </td><td class="markdownTableBodyCenter">PD2_MFP   </td><td class="markdownTableBodyLeft">PD.2 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOD[2]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 4 at 64-pin package, LCD segment output 4 at 100-pin package    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[15:12]   </td><td class="markdownTableBodyCenter">PD3_MFP   </td><td class="markdownTableBodyLeft">PD.3 Pin Function Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOD[3]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 3 at 64-pin package, LCD segment output 3 at 100-pin package    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[19:16]   </td><td class="markdownTableBodyCenter">PD4_MFP   </td><td class="markdownTableBodyLeft">PD.4 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOD[4]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0100 = SmartCard1 RST pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 2 at 64-pin package, LCD segment output 2 at 100-pin package    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23:20]   </td><td class="markdownTableBodyCenter">PD5_MFP   </td><td class="markdownTableBodyLeft">PD.5 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOD[5]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 1 at 64-pin package(or as LD_COM5), LCD segment output 1 at 100-pin package(or as LD_COM5)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[27:24]   </td><td class="markdownTableBodyCenter">PD6_MFP   </td><td class="markdownTableBodyLeft">PD.6 Pin Function Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOD[6]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 0 at 64-pin package(or as LD_COM4), LCD segment output 0 at 100-pin package(or as LD_COM4)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:28]   </td><td class="markdownTableBodyCenter">PD7_MFP   </td><td class="markdownTableBodyLeft">PD.7 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOD[7]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0100 = SmartCard1 clock pin(SC1_UART_TXD)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD common output 3 at 48-pin package, LCD common output 3 at 64-pin, LCD common output 3 at 100-pin package   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l03181">3181</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga6246fa552c418eb242d8bb15ebb045ba" name="ga6246fa552c418eb242d8bb15ebb045ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6246fa552c418eb242d8bb15ebb045ba">&#9670;&nbsp;</a></span>PDID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t SYS_T::PDID</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md126"></a>
PDID</h1>
<h2><a class="anchor" id="autotoc_md127"></a>
Offset: 0x00  Part Device Identification Number Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]   </td><td class="markdownTableBodyCenter">PDID   </td><td class="markdownTableBodyLeft">Part Device ID    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This register reflects device part number code.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Software can read this register to identify which device is used.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l02692">2692</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaf77721058d20e5b5a0a4e5db7f1e7193" name="gaf77721058d20e5b5a0a4e5db7f1e7193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf77721058d20e5b5a0a4e5db7f1e7193">&#9670;&nbsp;</a></span>PDMA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t ADC_T::PDMA</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md20"></a>
PDMA</h1>
<h2><a class="anchor" id="autotoc_md21"></a>
Offset: 0x60  A/D PDMA current transfer data Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[11:0]   </td><td class="markdownTableBodyCenter">AD_PDMA   </td><td class="markdownTableBodyLeft">ADC PDMA Current Transfer Data Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When PDMA transferring, read this register can monitor current PDMA transfer data.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a read only register.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l00648">648</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga00d3ed7d7a00052d7152ad8acb35a5d3" name="ga00d3ed7d7a00052d7152ad8acb35a5d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00d3ed7d7a00052d7152ad8acb35a5d3">&#9670;&nbsp;</a></span>PDMACH0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t PWM_T::PDMACH0</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md298"></a>
PDMACH0</h1>
<h2><a class="anchor" id="autotoc_md299"></a>
Offset: 0x80  PDMA Channel 0 Captured Data</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]   </td><td class="markdownTableBodyCenter">PDMACH01   </td><td class="markdownTableBodyLeft">Captured Data Of Channel 0 When CH01CASK Is Disabled, It Is The Capturing Value(CFL0/CRL0) For Channel 0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When CH01CASK is enabled, It is the for the first byte of 32 bit capturing data for channel 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:8]   </td><td class="markdownTableBodyCenter">PDMACH02   </td><td class="markdownTableBodyLeft">Captured Data Of Channel 0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When CH01CASK is disabled, it is the capturing value(CFL0/CRL0) for channel 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When CH01CASK is enabled, It is the second byte of 32 bit capturing data for channel 0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[23:16]   </td><td class="markdownTableBodyCenter">PDMACH03   </td><td class="markdownTableBodyLeft">Captured Data Of Channel 0 When CH01CASK Is Disabled, This Byte Is 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When CH01CASK is enabled, It is the third byte of 32 bit capturing data for channel 0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[31:24]   </td><td class="markdownTableBodyCenter">PDMACH04   </td><td class="markdownTableBodyLeft">Captured Data Of Channel 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When CH01CASK is disabled, this byte is 0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When CH01CASK is enabled, It is the 4th byte of 32 bit capturing data for channel 0   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l06532">6532</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gad03bb7e0395fd46d24e13d608dfb3518" name="gad03bb7e0395fd46d24e13d608dfb3518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad03bb7e0395fd46d24e13d608dfb3518">&#9670;&nbsp;</a></span>PDMACH2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t PWM_T::PDMACH2</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md300"></a>
PDMACH2</h1>
<h2><a class="anchor" id="autotoc_md301"></a>
Offset: 0x84  PDMA Channel 2 Captured Data</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]   </td><td class="markdownTableBodyCenter">PDMACH21   </td><td class="markdownTableBodyLeft">Captured Data Of Channel 2 When CH23CASK Is Disabled, It Is The Capturing Value(CFL2/CRL2) For Channel 2    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When CH23CASK is enabled, It is the for the first byte of 32 bit capturing data for channel 2    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:8]   </td><td class="markdownTableBodyCenter">PDMACH22   </td><td class="markdownTableBodyLeft">Captured Data Of Channel 2    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When CH23CASK is disabled, it is the capturing value(CFL2/CRL2) for channel 2    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When CH23CASK is enabled, It is the second byte of 32 bit capturing data for channel 2    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[23:16]   </td><td class="markdownTableBodyCenter">PDMACH23   </td><td class="markdownTableBodyLeft">Captured Data Of Channel 2    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When CH23CASK is disabled, this byte is 0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When CH23CASK is enabled, It is the third byte of 32 bit capturing data for channel 2    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:24]   </td><td class="markdownTableBodyCenter">PDMACH24   </td><td class="markdownTableBodyLeft">Captured Data Of Channel 2    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When CH23CASK is disabled, this byte is 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When CH23CASK is enabled, It is the 4th byte of 32 bit capturing data for channel 2   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l06553">6553</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga15ea5302dbb03ab88bb2fd1430da9f90" name="ga15ea5302dbb03ab88bb2fd1430da9f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15ea5302dbb03ab88bb2fd1430da9f90">&#9670;&nbsp;</a></span>PE_H_MFP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SYS_T::PE_H_MFP</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md154"></a>
PE_H_MFP</h1>
<h2><a class="anchor" id="autotoc_md155"></a>
Offset: 0x54  Port E High Byte Multiple Function Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3:0]   </td><td class="markdownTableBodyCenter">PE8_MFP   </td><td class="markdownTableBodyLeft">PE.8 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOE[8]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0011 = PWM0 Channel2 output    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 30 at 100-pin package    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:4]   </td><td class="markdownTableBodyCenter">PE9_MFP   </td><td class="markdownTableBodyLeft">PE.9 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOE[9]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0011 = PWM0 Channel3 output    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = LCD segment output 29 at 100-pin package   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l03279">3279</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gabe16fa3d0d6cd8b5a6a5c5016c81bab6" name="gabe16fa3d0d6cd8b5a6a5c5016c81bab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe16fa3d0d6cd8b5a6a5c5016c81bab6">&#9670;&nbsp;</a></span>PE_L_MFP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SYS_T::PE_L_MFP</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md152"></a>
PE_L_MFP</h1>
<h2><a class="anchor" id="autotoc_md153"></a>
Offset: 0x50  Port E Low Byte Multiple Function Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2:0]   </td><td class="markdownTableBodyCenter">PE0_MFP   </td><td class="markdownTableBodyLeft">PE.0 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOE[0]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0110 = SPI0 1st MOSI (Master Out, Slave In) pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[6:4]   </td><td class="markdownTableBodyCenter">PE1_MFP   </td><td class="markdownTableBodyLeft">PE.1 Pin Function Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOE[1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0110 = SPI0 1st MISO (Master In, Slave Out) pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[10:8]   </td><td class="markdownTableBodyCenter">PE2_MFP   </td><td class="markdownTableBodyLeft">PE.2 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOE[2]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0110 = SPI0 serial clock pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[15]   </td><td class="markdownTableBodyCenter">PE3_MFP   </td><td class="markdownTableBodyLeft">PE.3 Pin Function Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOE[4]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0110 = SPI0 1st slave select pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[18:16]   </td><td class="markdownTableBodyCenter">PE4_MFP   </td><td class="markdownTableBodyLeft">PE.4 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOE[4]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0100 = SmartCard1 RST pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[23:20]   </td><td class="markdownTableBodyCenter">PE5_MFP   </td><td class="markdownTableBodyLeft">PE.5 Pin Function Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOE[5]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0100 = SmartCard1 PWR pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[27:24]   </td><td class="markdownTableBodyCenter">PE6_MFP   </td><td class="markdownTableBodyLeft">PE.6 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOE[6]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0100 = SmartCard1 clock pin(SC1_UART_TXD)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[31:28]   </td><td class="markdownTableBodyCenter">PE7_MFP   </td><td class="markdownTableBodyLeft">PE.7 Pin Function Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOE[7]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0100 = SmartCard1 DATA pin(SC1_UART_RXD)   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l03261">3261</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga07add08f9430d94b83bdb92d0d310df0" name="ga07add08f9430d94b83bdb92d0d310df0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07add08f9430d94b83bdb92d0d310df0">&#9670;&nbsp;</a></span>PF_L_MFP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SYS_T::PF_L_MFP</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md156"></a>
PF_L_MFP</h1>
<h2><a class="anchor" id="autotoc_md157"></a>
Offset: 0x58  Port F Low Byte Multiple Function Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3:0]   </td><td class="markdownTableBodyCenter">PF0_MFP   </td><td class="markdownTableBodyLeft">PF.0 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOF[1]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0010 = Timer3 external counter input or Timer3 toggle out.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1111 = External 32.768 kHz crystal input pin(default)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:4]   </td><td class="markdownTableBodyCenter">PF1_MFP   </td><td class="markdownTableBodyLeft">PF.1 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOF[1]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0010 = Timer2 external counter input or Timer2 toggle out.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1111 = External 32.768 kHz crystal output pin(default)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[11:8]   </td><td class="markdownTableBodyCenter">PF2_MFP   </td><td class="markdownTableBodyLeft">PF.2 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOF[2]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0001 = External interrupt1 input pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0010 = Timer3 capture input    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0111 = UART1 Data receiver input pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1111 = External 4~24 MHz crystal input pin(default)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:12]   </td><td class="markdownTableBodyCenter">PF3_MFP   </td><td class="markdownTableBodyLeft">PF.3 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOF[3]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0001 = External interrupt0 input pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0010 = Timer 2 capture input    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0111 = UART1 Data transmitter output pin(This pin could modulate with PWM0 output. Please refer PWM_SEL(UARTx_CTL[26:24])).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1111 = External 4~24 MHz crystal output pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[19:16]   </td><td class="markdownTableBodyCenter">PF4_MFP   </td><td class="markdownTableBodyLeft">PF.4 Pin Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOF[4]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0001 = Frequency Divider1 output pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0010 = Timer1 capture input    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0011 = PWM0 Channel2 output    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1001 = 1, 1/2, 1/4, 1/8, 1/16 Hz clock output    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1111 = Serial Wired Debugger Clock pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[23:20]   </td><td class="markdownTableBodyCenter">PF5_MFP   </td><td class="markdownTableBodyLeft">PF.5 Pin Function Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = GPIOF[5]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0010 = Timer0 capture input    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0011 = PWM0 Channel3 output    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1001 = Comparator0 charge/discharge path    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1111 = Serial Wired Debugger Data pin   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l03322">3322</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gacd64ba4db747a13e65ee2ff1eaa0fe47" name="gacd64ba4db747a13e65ee2ff1eaa0fe47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd64ba4db747a13e65ee2ff1eaa0fe47">&#9670;&nbsp;</a></span>PIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t GPIO_T::PIN</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md184"></a>
PIN</h1>
<h2><a class="anchor" id="autotoc_md185"></a>
Offset: 0x10  GPIO Port Pin Value Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PIN   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The value read from each of these bit reflects the actual status of the respective GPI/O pin    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_PIN, bits [15:6] are reserved.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l04275">4275</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gafa725963be021c377b5ce3450109ee26" name="gafa725963be021c377b5ce3450109ee26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa725963be021c377b5ce3450109ee26">&#9670;&nbsp;</a></span>PINCSR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SC_T::PINCSR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md352"></a>
PINCSR</h1>
<h2><a class="anchor" id="autotoc_md353"></a>
Offset: 0x24  SC Pin Control State Register.</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">POW_EN   </td><td class="markdownTableBodyLeft">SC_POW_EN Pin Signal    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is the pin status of SC_POW_EN but user can drive SC_POW_EN pin to high or low by setting this bit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Drive SC_POW_EN pin to low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Drive SC_POW_EN pin to high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When operation at activation, warm reset or deactivation mode, this bit will be changed automatically.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">So don't fill this field When operating in these modes.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">SC_RST   </td><td class="markdownTableBodyLeft">SC_RST Pin Signal    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is the pin status of SC_RST but user can drive SC_RST pin to high or low by setting this bit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Drive SC_RST pin to low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Drive SC_RST pin to high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When operation at activation, warm reset or deactivation mode, this bit will be changed automatically.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">So don't fill this field When operating in these modes.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">CD_REM_F   </td><td class="markdownTableBodyLeft">Card Detect Removal Status Of SC_CD Pin (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set whenever card has been removal.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No effect.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Card Removal.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This bit is read only, but it can be cleared by writing "1" to it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: Card detect engine will start after SC_CTL [SC_CEN] set.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">CD_INS_F   </td><td class="markdownTableBodyLeft">Card Detect Insert Status Of SC_CD Pin (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set whenever card has been inserted.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No effect.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Card insert.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This bit is read only, but it can be cleared by writing "1" to it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: Card detect engine will start after SC_CTL [SC_CEN] set.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">CD_PIN_ST   </td><td class="markdownTableBodyLeft">Card Detect Status Of SC_CD Pin Status (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is the pin status flag of SC_CD    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = SC_CD pin state at low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = SC_CD pin state at high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">CLK_KEEP   </td><td class="markdownTableBodyLeft">SC Clock Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = SC clock generation Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = SC clock always keeps free running.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When operation at activation, warm reset or deactivation mode, this bit will be changed automatically.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">So don't fill this field when operation in these modes.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">ADAC_CD_EN   </td><td class="markdownTableBodyLeft">Auto Deactivation When Card Removal    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Auto deactivation Disabled when hardware detected the card is removal.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Auto deactivation Enabled when hardware detected the card is removal.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: When the card is removal, hardware will stop any process and then do deactivation sequence (if this bit be setting).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If this process completes.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Hardware will generate an interrupt INT_INIT to CPU.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">SC_OEN_ST   </td><td class="markdownTableBodyLeft">SC Data Pin Output Enable Status (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = SC data output enable pin status is at low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = SC data output enable pin status is at high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">SC_DATA_O   </td><td class="markdownTableBodyLeft">Output Of SC Data Pin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is the pin status of SC data output but user can drive this pin to high or low by setting this bit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Drive SC data output pin to low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Drive SC data output pin to high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When SC is at activation, warm re set or deactivation mode, this bit will be changed automatically.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">So don't fill this field when SC is in these modes.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[10]   </td><td class="markdownTableBodyCenter">CD_LEV   </td><td class="markdownTableBodyLeft">Card Detect Level    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = When hardware detects the card detect pin from high to low, it indicates a card is detected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = When hardware detects the card detect pin from low to high, it indicates a card is detected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Software must select card detect level before Smart Card engine enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[11]   </td><td class="markdownTableBodyCenter">POW_INV   </td><td class="markdownTableBodyLeft">SC_POW Pin Inverse    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is used for inverse the SC_POW pin.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">There are four kinds of combination for SC_POW pin setting by POW_INV and    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">POW_EN(SC_PINCSR[0]). POW_INV is bit 1 and POW_EN is bit 0 for SC_POW_Pin as    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">high or low voltage selection.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">POW_INV is 0 and POW_EN is 0, than SC_POW Pin output 0.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">POW_INV is 0 and POW_EN is 1, than SC_POW Pin output 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">POW_INV is 1 and POW_EN is 0, than SC_POW Pin output 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">POW_INV is 1 and POW_EN is 1, than SC_POW Pin output 0.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Software must select POW_INV before Smart Card is enabled by SC_CEN (SC_CTL[0])    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">SC_DATA_I_ST   </td><td class="markdownTableBodyLeft">SC Data Input Pin Status (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is the pin status of SC_DATA_I    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The SC_DATA_I pin is low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The SC_DATA_I pin is high.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l08055">8055</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga0059b5b729980b9dfe3a9cb3e75ea99a" name="ga0059b5b729980b9dfe3a9cb3e75ea99a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0059b5b729980b9dfe3a9cb3e75ea99a">&#9670;&nbsp;</a></span>PLLCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t CLK_T::PLLCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md50"></a>
PLLCTL</h1>
<h2><a class="anchor" id="autotoc_md51"></a>
Offset: 0x24  PLL Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">PLL_MLP   </td><td class="markdownTableBodyLeft">PLL Multiple    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">000000: Reserved    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">000001: X1    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">000010: X2    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">000011: X3    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">000100: X4    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">...    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">010000:X16    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">...    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">100000: X32    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0thers: Reserved    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PLL output frequency: PLL input frequency * PLL_MLP.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PLL output frequency range: 16MHz ~ 32MHz    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[11:8]   </td><td class="markdownTableBodyCenter">PLL_SRC_N   </td><td class="markdownTableBodyLeft">PLL Input Source Divider    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The PLL input clock frequency = (PLL Clock Source frequency ) / (PLL_SRC_N + 1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PLL input clock frequency range: 0.8MHz ~ 2MHz    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">PD   </td><td class="markdownTableBodyLeft">Power-Down Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If set the PD_EN bit "1" in PWR_CTL register, the PLL will enter Power-down mode too    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PLL is in normal mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PLL is in power-down mode (default).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[17]   </td><td class="markdownTableBodyCenter">PLL_SRC   </td><td class="markdownTableBodyLeft">PLL Source Clock Select    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PLL source clock from HXT.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PLL source clock from HIRC.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l01300">1300</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga1d09c59b4451ee8cc8736c8078891386" name="ga1d09c59b4451ee8cc8736c8078891386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d09c59b4451ee8cc8736c8078891386">&#9670;&nbsp;</a></span>PMD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t GPIO_T::PMD</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md176"></a>
PMD</h1>
<h2><a class="anchor" id="autotoc_md177"></a>
Offset: 0x00  GPIO Port Pin I/O Mode Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1:0]   </td><td class="markdownTableBodyCenter">PMD0   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Mode Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Determine the I/O type of GPIO port [x] pin [n]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = GPIO port [x] pin [n] is in INPUT mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = GPIO port [x] pin [n] is in OUTPUT mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = GPIO port [x] pin [n] is in Open-Drain mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOE_PMD, PMD10 ~ PMD15 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For GPIOF_PMD, PMD6 ~ PMD15 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3:2]   </td><td class="markdownTableBodyCenter">PMD1   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Mode Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Determine the I/O type of GPIO port [x] pin [n]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = GPIO port [x] pin [n] is in INPUT mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = GPIO port [x] pin [n] is in OUTPUT mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = GPIO port [x] pin [n] is in Open-Drain mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOE_PMD, PMD10 ~ PMD15 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For GPIOF_PMD, PMD6 ~ PMD15 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:4]   </td><td class="markdownTableBodyCenter">PMD2   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Mode Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Determine the I/O type of GPIO port [x] pin [n]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = GPIO port [x] pin [n] is in INPUT mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = GPIO port [x] pin [n] is in OUTPUT mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = GPIO port [x] pin [n] is in Open-Drain mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOE_PMD, PMD10 ~ PMD15 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For GPIOF_PMD, PMD6 ~ PMD15 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:6]   </td><td class="markdownTableBodyCenter">PMD3   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Mode Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Determine the I/O type of GPIO port [x] pin [n]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = GPIO port [x] pin [n] is in INPUT mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = GPIO port [x] pin [n] is in OUTPUT mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = GPIO port [x] pin [n] is in Open-Drain mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOE_PMD, PMD10 ~ PMD15 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For GPIOF_PMD, PMD6 ~ PMD15 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[9:8]   </td><td class="markdownTableBodyCenter">PMD4   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Mode Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Determine the I/O type of GPIO port [x] pin [n]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = GPIO port [x] pin [n] is in INPUT mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = GPIO port [x] pin [n] is in OUTPUT mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = GPIO port [x] pin [n] is in Open-Drain mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOE_PMD, PMD10 ~ PMD15 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For GPIOF_PMD, PMD6 ~ PMD15 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[11:10]   </td><td class="markdownTableBodyCenter">PMD5   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Mode Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Determine the I/O type of GPIO port [x] pin [n]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = GPIO port [x] pin [n] is in INPUT mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = GPIO port [x] pin [n] is in OUTPUT mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = GPIO port [x] pin [n] is in Open-Drain mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOE_PMD, PMD10 ~ PMD15 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For GPIOF_PMD, PMD6 ~ PMD15 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[13:12]   </td><td class="markdownTableBodyCenter">PMD6   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Mode Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Determine the I/O type of GPIO port [x] pin [n]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = GPIO port [x] pin [n] is in INPUT mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = GPIO port [x] pin [n] is in OUTPUT mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = GPIO port [x] pin [n] is in Open-Drain mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOE_PMD, PMD10 ~ PMD15 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For GPIOF_PMD, PMD6 ~ PMD15 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:14]   </td><td class="markdownTableBodyCenter">PMD7   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Mode Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Determine the I/O type of GPIO port [x] pin [n]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = GPIO port [x] pin [n] is in INPUT mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = GPIO port [x] pin [n] is in OUTPUT mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = GPIO port [x] pin [n] is in Open-Drain mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOE_PMD, PMD10 ~ PMD15 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For GPIOF_PMD, PMD6 ~ PMD15 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[17:16]   </td><td class="markdownTableBodyCenter">PMD8   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Mode Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Determine the I/O type of GPIO port [x] pin [n]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = GPIO port [x] pin [n] is in INPUT mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = GPIO port [x] pin [n] is in OUTPUT mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = GPIO port [x] pin [n] is in Open-Drain mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOE_PMD, PMD10 ~ PMD15 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For GPIOF_PMD, PMD6 ~ PMD15 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[19:18]   </td><td class="markdownTableBodyCenter">PMD9   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Mode Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Determine the I/O type of GPIO port [x] pin [n]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = GPIO port [x] pin [n] is in INPUT mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = GPIO port [x] pin [n] is in OUTPUT mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = GPIO port [x] pin [n] is in Open-Drain mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOE_PMD, PMD10 ~ PMD15 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For GPIOF_PMD, PMD6 ~ PMD15 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[21:20]   </td><td class="markdownTableBodyCenter">PMD10   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Mode Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Determine the I/O type of GPIO port [x] pin [n]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = GPIO port [x] pin [n] is in INPUT mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = GPIO port [x] pin [n] is in OUTPUT mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = GPIO port [x] pin [n] is in Open-Drain mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOE_PMD, PMD10 ~ PMD15 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For GPIOF_PMD, PMD6 ~ PMD15 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23:22]   </td><td class="markdownTableBodyCenter">PMD11   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Mode Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Determine the I/O type of GPIO port [x] pin [n]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = GPIO port [x] pin [n] is in INPUT mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = GPIO port [x] pin [n] is in OUTPUT mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = GPIO port [x] pin [n] is in Open-Drain mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOE_PMD, PMD10 ~ PMD15 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For GPIOF_PMD, PMD6 ~ PMD15 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[25:24]   </td><td class="markdownTableBodyCenter">PMD12   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Mode Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Determine the I/O type of GPIO port [x] pin [n]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = GPIO port [x] pin [n] is in INPUT mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = GPIO port [x] pin [n] is in OUTPUT mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = GPIO port [x] pin [n] is in Open-Drain mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOE_PMD, PMD10 ~ PMD15 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For GPIOF_PMD, PMD6 ~ PMD15 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[27:26]   </td><td class="markdownTableBodyCenter">PMD13   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Mode Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Determine the I/O type of GPIO port [x] pin [n]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = GPIO port [x] pin [n] is in INPUT mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = GPIO port [x] pin [n] is in OUTPUT mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = GPIO port [x] pin [n] is in Open-Drain mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOE_PMD, PMD10 ~ PMD15 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For GPIOF_PMD, PMD6 ~ PMD15 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[29:28]   </td><td class="markdownTableBodyCenter">PMD14   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Mode Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Determine the I/O type of GPIO port [x] pin [n]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = GPIO port [x] pin [n] is in INPUT mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = GPIO port [x] pin [n] is in OUTPUT mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = GPIO port [x] pin [n] is in Open-Drain mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOE_PMD, PMD10 ~ PMD15 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For GPIOF_PMD, PMD6 ~ PMD15 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:30]   </td><td class="markdownTableBodyCenter">PMD15   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Mode Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Determine the I/O type of GPIO port [x] pin [n]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = GPIO port [x] pin [n] is in INPUT mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = GPIO port [x] pin [n] is in OUTPUT mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = GPIO port [x] pin [n] is in Open-Drain mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOE_PMD, PMD10 ~ PMD15 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For GPIOF_PMD, PMD6 ~ PMD15 are reserved.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l04213">4213</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga2f7460c376f0ea3779d9446cb12cb923" name="ga2f7460c376f0ea3779d9446cb12cb923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f7460c376f0ea3779d9446cb12cb923">&#9670;&nbsp;</a></span>PORCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SYS_T::PORCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md158"></a>
PORCTL</h1>
<h2><a class="anchor" id="autotoc_md159"></a>
Offset: 0x60  Power-On-Reset Controller Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">POR_DIS_CODE   </td><td class="markdownTableBodyLeft">Power-On Reset Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a protected register. Please refer to open lock sequence to program it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When powered on, the POR circuit generates a reset signal to reset the whole chip function, but noise on the power may cause the POR active again.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If setting the POR_DIS_CODE to 0x5AA5, the POR reset function will be disabled and the POR function will be active again when POR_DIS_CODE is set to another value or POR_DIS_CODE is reset by chip other reset functions, including: /RESET, Watchdog Timer reset, BOD reset, ICE reset command and the software-chip reset function.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l03338">3338</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga6a66d55fb7d20c3e12402aa320661d8f" name="ga6a66d55fb7d20c3e12402aa320661d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a66d55fb7d20c3e12402aa320661d8f">&#9670;&nbsp;</a></span>PRECNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t TIMER_T::PRECNT</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md394"></a>
PRECNT</h1>
<h2><a class="anchor" id="autotoc_md395"></a>
Offset: 0x04  Timer x Pre-Scale Counter Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]   </td><td class="markdownTableBodyCenter">PRESCALE_CNT   </td><td class="markdownTableBodyLeft">Pre-Scale Counter    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Clock input is divided by PRESCALE_CNT + 1 before it is fed to the counter.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If PRESCALE_CNT =0, then there is no scaling.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l09191">9191</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga7bf7d727d4a434b4ee8157a2e7f9ec81" name="ga7bf7d727d4a434b4ee8157a2e7f9ec81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bf7d727d4a434b4ee8157a2e7f9ec81">&#9670;&nbsp;</a></span>PRES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::PRES</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md248"></a>
PRES</h1>
<h2><a class="anchor" id="autotoc_md249"></a>
Offset: 0x00  PWM Prescaler Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]   </td><td class="markdownTableBodyCenter">CP01   </td><td class="markdownTableBodyLeft">Clock Prescaler 0 For PWM Timer 0 &amp; 1    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Clock input is divided by (CP01 + 1) before it is fed to the PWM counter 0 &amp; 1    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If CP01 =0, the prescaler 0 output clock will be stopped. So PWM counter 0 and 1 will be stopped also.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[15:8]   </td><td class="markdownTableBodyCenter">CP23   </td><td class="markdownTableBodyLeft">Clock Prescaler 2 For PWM Timer 2 &amp; 3    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Clock input is divided by (CP23 + 1) before it is fed to the PWM counter 2 &amp; 3    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If CP23=0, the prescaler 2 output clock will be stopped. So PWM counter 2 and 3 will be stopped also.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23:16]   </td><td class="markdownTableBodyCenter">DZ01   </td><td class="markdownTableBodyLeft">Dead Zone Interval Register For CH0 And CH1 Pair    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">These 8 bits determine dead zone length.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The unit time of dead zone length is received from clock selector 0.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[31:24]   </td><td class="markdownTableBodyCenter">DZ23   </td><td class="markdownTableBodyLeft">Dead Zone Interval Register For CH2 And CH3 Pair    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">These 8 bits determine dead zone length.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The unit time of dead zone length is received from clock selector 2.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l05758">5758</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga4363701c030af4adb16f6329a7d59833" name="ga4363701c030af4adb16f6329a7d59833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4363701c030af4adb16f6329a7d59833">&#9670;&nbsp;</a></span>PUEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t GPIO_T::PUEN</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md194"></a>
PUEN</h1>
<h2><a class="anchor" id="autotoc_md195"></a>
Offset: 0x24  GPIO Port Pull-Up Enable Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PUEN   </td><td class="markdownTableBodyLeft">GPIO Port [X] Pin [N] Pull-Up Enable Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Read :    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = GPIO port [A/B/C/D/E/F] bit [n] pull-up resistor Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = GPIO port [A/B/C/D/E/F] bit [n] pull-up resistor Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: For GPIOF_PUEN, bits [15:6] are reserved.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l04646">4646</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga7b33e02385e50126dbe173470193bdf8" name="ga7b33e02385e50126dbe173470193bdf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b33e02385e50126dbe173470193bdf8">&#9670;&nbsp;</a></span>PWRCTL <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t ADC_T::PWRCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md22"></a>
PWRCTL</h1>
<h2><a class="anchor" id="autotoc_md23"></a>
Offset: 0x64  ADC Power Management Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">PWUPRDY   </td><td class="markdownTableBodyLeft">ADC Power-Up Sequence Completed And Ready For Conversion    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = ADC is not ready for conversion; may be in power down state or in the progress of power up.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = ADC is ready for conversion.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">PWDCALEN   </td><td class="markdownTableBodyLeft">Power Up Calibration Function Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Power up with calibration.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Power up without calibration.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit work together with CALFBKSEL set 1    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3:2]   </td><td class="markdownTableBodyCenter">PWDMOD   </td><td class="markdownTableBodyLeft">Power-Down Mode    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Power down    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Reserved    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Standby mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Reserved    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Different PWDMOD has different power down/up sequence, in order to avoid ADC powering up with wrong sequence; user must keep PWMOD consistent each time in powe down and power up   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l00671">671</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga8dc40f2a57b0b379fd97dd6eecdba230" name="ga8dc40f2a57b0b379fd97dd6eecdba230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8dc40f2a57b0b379fd97dd6eecdba230">&#9670;&nbsp;</a></span>PWRCTL <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t CLK_T::PWRCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md32"></a>
PWRCTL</h1>
<h2><a class="anchor" id="autotoc_md33"></a>
Offset: 0x00  System Power-down Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">HXT_EN   </td><td class="markdownTableBodyLeft">HXT Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a protected register. Please refer to open lock sequence to program it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The bit default value is set by flash controller user configuration register config0 [26].    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">HXT is disabled by default.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">LXT_EN   </td><td class="markdownTableBodyLeft">LXT Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a protected register. Please refer to open lock sequence to program it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LXT is disabled by default.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">HIRC_EN   </td><td class="markdownTableBodyLeft">HIRC Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a protected register. Please refer to open lock sequence to program it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">HIRC is enabled by default.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">LIRC_EN   </td><td class="markdownTableBodyLeft">LIRC Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a protected register. Please refer to open lock sequence to program it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LIRC is enabled by default.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">WK_DLY   </td><td class="markdownTableBodyLeft">Wake-Up Delay Counter Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a protected register. Please refer to open lock sequence to program it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When chip wakes up from Power-down mode, the clock control will delay 4096 clock cycles to wait HXT stable or 16 clock cycles to wait HIRC stable.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Delay clock cycle Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Delay clock cycle Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">PD_WK_IE   </td><td class="markdownTableBodyLeft">Power-Down Mode Wake-Up Interrupt Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a protected register. Please refer to open lock sequence to program it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PD_WK_INT will be set if both PD_WK_IS and PD_WK_IE are high.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">PD_EN   </td><td class="markdownTableBodyLeft">Chip Power-Down Mode Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a protected register. Please refer to open lock sequence to program it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When CPU sets this bit, the chip power down is enabled and chip will not enter Power-down mode until CPU sleep mode is also active.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When chip wakes up from Power-down mode, this bit will be auto cleared.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When chip is in Power-down mode, the LDO, HXT and HIRC will be disabled, but LXT and LIRC are not controlled by Power-down mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When power down, the PLL and system clock (CPU, HCLKx and PCLKx) are also disabled no matter the Clock Source selection.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Peripheral clocks are not controlled by this bit, if peripheral Clock Source is from LXT or LIRC.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In Power-down mode, flash macro power is ON.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Chip operated in Normal mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Chip power down Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">HXT_SELXT   </td><td class="markdownTableBodyLeft">HXT SELXT    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a protected register. Please refer to open lock sequence to program it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = High frequency crystal loop back path Disabled. It is used for external oscillator.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = High frequency crystal loop back path Enabled. It is used for external crystal.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">HXT_CUR_SEL   </td><td class="markdownTableBodyLeft">HXT Internal Current Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">HXT has some internal current path to help crystal start-up.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">However when these current path existence, HXT will consume more power.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">User can use this bit to balance the start-up and power consumption.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = HXT current path always exists. HXT will consume more power.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For 16MHz to 24 MHz crystal.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = HXT current path will exist 2ms then cut down. HXT will consume less power.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For 4 MHz to 16 MHz crystal.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[11:10]   </td><td class="markdownTableBodyCenter">HXT_GAIN   </td><td class="markdownTableBodyLeft">HXT Gain Control Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a protected register. Please refer to open lock sequence to program it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Gain control is used to enlarge the gain of crystal to make sure crystal wok normally.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If gain control is enabled, crystal will consume more power than gain control off.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = HXT frequency is lower than from 8 MHz.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = HXT frequency is from 8 MHz to 12 MHz.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = HXT frequency is from 12 MHz to 16 MHz.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = HXT frequency is higher than 16 MHz.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[12]   </td><td class="markdownTableBodyCenter">HIRC_FSEL   </td><td class="markdownTableBodyLeft">HIRC Output Frequency Select    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = HIRC will output 12MHz clock.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = HIRC will output 16MHz Clock.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[13]   </td><td class="markdownTableBodyCenter">HIRC_F_STOP   </td><td class="markdownTableBodyLeft">HIRC Stop Output When Frequency Changes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a protected register. Please refer to open lock sequence to program it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = HIRC will continue to output when HIRC frequency changes.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = HIRC will suppress to output during first 16 clocks when HIRC frequency change.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l00983">983</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gafec014ee84168de58491161eff42e1f7" name="gafec014ee84168de58491161eff42e1f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafec014ee84168de58491161eff42e1f7">&#9670;&nbsp;</a></span> <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t  { ... } ::RBR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md366"></a>
RBR</h1>
<h2><a class="anchor" id="autotoc_md367"></a>
Offset: 0x00  SC Receive Buffer Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]   </td><td class="markdownTableBodyCenter">RBR   </td><td class="markdownTableBodyLeft">Receiving Buffer    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">By reading this register, the SC Controller will return an 8-bit data received from RX pin (LSB first).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l07559">7559</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga071fcc6d567d3ac4e54345160abf87a9" name="ga071fcc6d567d3ac4e54345160abf87a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga071fcc6d567d3ac4e54345160abf87a9">&#9670;&nbsp;</a></span>RBR <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t SC_T::RBR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md366"></a>
RBR</h1>
<h2><a class="anchor" id="autotoc_md367"></a>
Offset: 0x00  SC Receive Buffer Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]   </td><td class="markdownTableBodyCenter">RBR   </td><td class="markdownTableBodyLeft">Receiving Buffer    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">By reading this register, the SC Controller will return an 8-bit data received from RX pin (LSB first).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l07559">7559</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaa197bb74cef0a08558d1baab9a0db933" name="gaa197bb74cef0a08558d1baab9a0db933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa197bb74cef0a08558d1baab9a0db933">&#9670;&nbsp;</a></span> <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t  { ... } ::RBR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md434"></a>
RBR</h1>
<h2><a class="anchor" id="autotoc_md435"></a>
Offset: 0x00  UART Receive Buffer Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]   </td><td class="markdownTableBodyCenter">RBR   </td><td class="markdownTableBodyLeft">Receiving Buffer    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">By reading this register, the UART Controller will return an 8-bit data received from RX pin (LSB first).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l09496">9496</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gae89a1c157c8f32081e88d5e41147b885" name="gae89a1c157c8f32081e88d5e41147b885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae89a1c157c8f32081e88d5e41147b885">&#9670;&nbsp;</a></span>RBR <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t UART_T::RBR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md434"></a>
RBR</h1>
<h2><a class="anchor" id="autotoc_md435"></a>
Offset: 0x00  UART Receive Buffer Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]   </td><td class="markdownTableBodyCenter">RBR   </td><td class="markdownTableBodyLeft">Receiving Buffer    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">By reading this register, the UART Controller will return an 8-bit data received from RX pin (LSB first).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l09496">9496</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gad919a9ee2c00afca7cbd30f4a0da78f6" name="gad919a9ee2c00afca7cbd30f4a0da78f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad919a9ee2c00afca7cbd30f4a0da78f6">&#9670;&nbsp;</a></span>RegLockAddr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SYS_T::RegLockAddr</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md174"></a>
RegLockAddr</h1>
<h2><a class="anchor" id="autotoc_md175"></a>
Offset: 0x100  Register Lock Key address</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">RegUnLock   </td><td class="markdownTableBodyLeft">Protected Register Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Protected register are Locked. Any write to the target register is ignored.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Protected registers are Unlocked.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l03611">3611</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga84b8652eeb9b92b1eaf40b204d7d405b" name="ga84b8652eeb9b92b1eaf40b204d7d405b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84b8652eeb9b92b1eaf40b204d7d405b">&#9670;&nbsp;</a></span>RESERVE0 <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t FMC_T::RESERVE0[10]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l02582">2582</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gac5c543e82031d3cb0ba48c5f9a916031" name="gac5c543e82031d3cb0ba48c5f9a916031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5c543e82031d3cb0ba48c5f9a916031">&#9670;&nbsp;</a></span>RESERVE0 <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CLK_T::RESERVE0[1]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l01321">1321</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga411f3d9964120e7bf442d4fe46644353" name="ga411f3d9964120e7bf442d4fe46644353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga411f3d9964120e7bf442d4fe46644353">&#9670;&nbsp;</a></span>RESERVE0 <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t DMA_CRC_T::RESERVE0[1]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l01790">1790</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaaee053849c4f8a1b259a095cc09ee22e" name="gaaee053849c4f8a1b259a095cc09ee22e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaee053849c4f8a1b259a095cc09ee22e">&#9670;&nbsp;</a></span>RESERVE0 <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PDMA_T::RESERVE0[1]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l02154">2154</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga6b98f0117b692926f875fc732366f792" name="ga6b98f0117b692926f875fc732366f792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b98f0117b692926f875fc732366f792">&#9670;&nbsp;</a></span>RESERVE0 <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LCD_T::RESERVE0[1]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l05506">5506</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga880146e1f82cd56ac83fea85f285e086" name="ga880146e1f82cd56ac83fea85f285e086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga880146e1f82cd56ac83fea85f285e086">&#9670;&nbsp;</a></span>RESERVE0 <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PWM_T::RESERVE0[1]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l05931">5931</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga9ecc606ca7cfd8c6693ec2d396b9e3d8" name="ga9ecc606ca7cfd8c6693ec2d396b9e3d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ecc606ca7cfd8c6693ec2d396b9e3d8">&#9670;&nbsp;</a></span>RESERVE0 <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t TIMER_T::RESERVE0[1]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l09303">9303</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gab53f85444601fedf71ba84ed308a5ca4" name="gab53f85444601fedf71ba84ed308a5ca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab53f85444601fedf71ba84ed308a5ca4">&#9670;&nbsp;</a></span>RESERVE0 <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2C_T::RESERVE0[2]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l05039">5039</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gae0ebb36ccc1d9c7dc94d3275cfdcbed5" name="gae0ebb36ccc1d9c7dc94d3275cfdcbed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0ebb36ccc1d9c7dc94d3275cfdcbed5">&#9670;&nbsp;</a></span>RESERVE0 <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t RTC_T::RESERVE0[2]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l07303">7303</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga9bf28b6d289035f03cbe294af78b345b" name="ga9bf28b6d289035f03cbe294af78b345b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bf28b6d289035f03cbe294af78b345b">&#9670;&nbsp;</a></span>RESERVE0 <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SPI_T::RESERVE0[2]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l08722">8722</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga7f27fb255eef2d5ad9a1d18496232119" name="ga7f27fb255eef2d5ad9a1d18496232119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f27fb255eef2d5ad9a1d18496232119">&#9670;&nbsp;</a></span>RESERVE0 <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UART_T::RESERVE0[2]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l09926">9926</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gafe13d0bb8565a6db2f4608278d1fb5f9" name="gafe13d0bb8565a6db2f4608278d1fb5f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe13d0bb8565a6db2f4608278d1fb5f9">&#9670;&nbsp;</a></span>RESERVE0 <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SYS_T::RESERVE0[4]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l02821">2821</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gab35b677a2dc28f2733fb7769c99786a7" name="gab35b677a2dc28f2733fb7769c99786a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab35b677a2dc28f2733fb7769c99786a7">&#9670;&nbsp;</a></span>RESERVE1 <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ADC_T::RESERVE1[1]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l00635">635</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaeb37485b9fd770784d56d6e9ebd57b2e" name="gaeb37485b9fd770784d56d6e9ebd57b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb37485b9fd770784d56d6e9ebd57b2e">&#9670;&nbsp;</a></span>RESERVE1 <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t DMA_CRC_T::RESERVE1[1]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l01804">1804</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga32f14231d09f9f6b951ac21635f5d01e" name="ga32f14231d09f9f6b951ac21635f5d01e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32f14231d09f9f6b951ac21635f5d01e">&#9670;&nbsp;</a></span>RESERVE1 <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PWM_T::RESERVE1[1]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l05996">5996</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaf73711431d617ffdca77288c88244328" name="gaf73711431d617ffdca77288c88244328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf73711431d617ffdca77288c88244328">&#9670;&nbsp;</a></span>RESERVE1 <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SYS_T::RESERVE1[3]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l02834">2834</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga0ff3af89b804bed7e4c2d7805fec32e4" name="ga0ff3af89b804bed7e4c2d7805fec32e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ff3af89b804bed7e4c2d7805fec32e4">&#9670;&nbsp;</a></span>RESERVE1 <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SPI_T::RESERVE1[3]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l08764">8764</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gae69ae433f5ac470a10bf5f971fb71642" name="gae69ae433f5ac470a10bf5f971fb71642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae69ae433f5ac470a10bf5f971fb71642">&#9670;&nbsp;</a></span>RESERVE1 <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2C_T::RESERVE1[4]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l05067">5067</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga0a6f3fb798fb0a132a2ccf7f6b424233" name="ga0a6f3fb798fb0a132a2ccf7f6b424233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a6f3fb798fb0a132a2ccf7f6b424233">&#9670;&nbsp;</a></span>RESERVE2 <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t DMA_CRC_T::RESERVE2[1]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l01818">1818</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga06196df18a6325dad3253828ee6df730" name="ga06196df18a6325dad3253828ee6df730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06196df18a6325dad3253828ee6df730">&#9670;&nbsp;</a></span>RESERVE2 <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SYS_T::RESERVE2[1]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l03323">3323</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gabd8ea3e41c0de5046768e097edad6074" name="gabd8ea3e41c0de5046768e097edad6074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd8ea3e41c0de5046768e097edad6074">&#9670;&nbsp;</a></span>RESERVE2 <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PWM_T::RESERVE2[1]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l06061">6061</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga267f2a01680881b9bb723e72a022af70" name="ga267f2a01680881b9bb723e72a022af70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga267f2a01680881b9bb723e72a022af70">&#9670;&nbsp;</a></span>RESERVE2 <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SPI_T::RESERVE2[4]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l08843">8843</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga0539e3b4a1138b2f6fefbef4bab09d1e" name="ga0539e3b4a1138b2f6fefbef4bab09d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0539e3b4a1138b2f6fefbef4bab09d1e">&#9670;&nbsp;</a></span>RESERVE3 <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PWM_T::RESERVE3[1]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l06126">6126</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga318f84a6afb4e661302a1d21d361ba29" name="ga318f84a6afb4e661302a1d21d361ba29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga318f84a6afb4e661302a1d21d361ba29">&#9670;&nbsp;</a></span>RESERVE3 <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t DMA_CRC_T::RESERVE3[22]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l01872">1872</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gac9724dc13b92d809434d8c849615b213" name="gac9724dc13b92d809434d8c849615b213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9724dc13b92d809434d8c849615b213">&#9670;&nbsp;</a></span>RESERVE3 <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SYS_T::RESERVE3[3]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l03510">3510</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga6a873dceecf467cf62bb6d1fc7a87940" name="ga6a873dceecf467cf62bb6d1fc7a87940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a873dceecf467cf62bb6d1fc7a87940">&#9670;&nbsp;</a></span>RESERVE4 <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SYS_T::RESERVE4[29]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l03597">3597</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga22b0ee7cf9f53c86810622215189a9f5" name="ga22b0ee7cf9f53c86810622215189a9f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22b0ee7cf9f53c86810622215189a9f5">&#9670;&nbsp;</a></span>RESERVE4 <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PWM_T::RESERVE4[3]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l06191">6191</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga9e69d68623f50b230184c4466a44b700" name="ga9e69d68623f50b230184c4466a44b700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e69d68623f50b230184c4466a44b700">&#9670;&nbsp;</a></span>RESULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t ADC_T::RESULT[18]</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md8"></a>
RESULT</h1>
<h2><a class="anchor" id="autotoc_md9"></a>
Offset: 0x00 ~ 0x44 A/D Data Register 0 ~ 7 and 14 ~ 17</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[11:0]   </td><td class="markdownTableBodyCenter">RSLT   </td><td class="markdownTableBodyLeft">A/D Conversion Result    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field contains 12 bits conversion results.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">VALID   </td><td class="markdownTableBodyLeft">Data Valid Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">After ADC converts finish, this field will set to high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field will clear when this register be read.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[17]   </td><td class="markdownTableBodyCenter">OVERRUN   </td><td class="markdownTableBodyLeft">Over Run Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When VALID is high and ADC converts finish, this field will set to high.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l00397">397</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga90acfb650851f2b72a3dca73041b5df4" name="ga90acfb650851f2b72a3dca73041b5df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90acfb650851f2b72a3dca73041b5df4">&#9670;&nbsp;</a></span>RFTMR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SC_T::RFTMR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md342"></a>
RFTMR</h1>
<h2><a class="anchor" id="autotoc_md343"></a>
Offset: 0x10  SC Receive Buffer Time-Out Register.</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[8:0]   </td><td class="markdownTableBodyCenter">RFTM   </td><td class="markdownTableBodyLeft">SC Receiver Buffer Time-Out Register (ETU Based)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The time-out counter resets and starts counting whenever the RX buffer received a new data word.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Once the counter decrease to "1" and no new data is received or CPU does not read data by reading SC_RBR register, a receiver time-out interrupt INT_RTMR will be generated(if SC_IER[RTMR_IE] is high).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: The counter is ETU based and the real count value is RFTM + 1    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: Fill all "0" to this field to disable this function.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l07776">7776</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga4e3f50478c302bafe3a0ad71abdeabc8" name="ga4e3f50478c302bafe3a0ad71abdeabc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e3f50478c302bafe3a0ad71abdeabc8">&#9670;&nbsp;</a></span>RIER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t RTC_T::RIER</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md326"></a>
RIER</h1>
<h2><a class="anchor" id="autotoc_md327"></a>
Offset: 0x28  RTC Interrupt Enable Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">AIER   </td><td class="markdownTableBodyLeft">Alarm Interrupt Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RTC Alarm Interrupt is disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RTC Alarm Interrupt is enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">TIER   </td><td class="markdownTableBodyLeft">Time Tick Interrupt And Wake-Up By Tick Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RTC Time Tick Interrupt is disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RTC Time Tick Interrupt is enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">SNOOPIER   </td><td class="markdownTableBodyLeft">Snooper Pin Event Detection Interrupt Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Snooper Pin Event Detection Interrupt is disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Snooper Pin Event Detection Interrupt is enabled.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l07248">7248</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga6e271103aa712f44406bf7aaa6d1c4d8" name="ga6e271103aa712f44406bf7aaa6d1c4d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e271103aa712f44406bf7aaa6d1c4d8">&#9670;&nbsp;</a></span>RIIR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t RTC_T::RIIR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md328"></a>
RIIR</h1>
<h2><a class="anchor" id="autotoc_md329"></a>
Offset: 0x2C  RTC Interrupt Indication Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">AIS   </td><td class="markdownTableBodyLeft">RTC Alarm Interrupt Status    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">RTC unit will set AIS to high once the RTC real time counters TLR and CLR reach the alarm setting time registers TAR and CAR.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When this bit is set and AIER is also high, RTC will generate an interrupt to CPU.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is cleared by writing "1" to it through software.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RCT Alarm Interrupt condition never occurred.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RTC Alarm Interrupt is requested if AIER (RTC_RIER[0])=1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">TIS   </td><td class="markdownTableBodyLeft">RTC Time Tick Interrupt Status    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">RTC unit will set this bit to high periodically in the period selected by TTR (RTC_TTR[2:0]).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When this bit is set and TIER (RTC_RIER[1]) is also high, RTC will generate an interrupt to CPU.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is cleared by writing "1" to it through software.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RCT Time Tick Interrupt condition never occurred.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RTC Time Tick Interrupt is requested.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">SNOOPIF   </td><td class="markdownTableBodyLeft">Snooper Pin Event Detection Interrupt Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When SNOOPEN is high and an event defined by SNOOPEDGE detected in snooper pin, this flag will be set.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">While this bit is set and SNOOPIER (RTC_RIER[2]) is also high, RTC will generate an interrupt to CPU.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Write "1" to clear this bit to "0".    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Snooper pin event defined by SNOOPEDGE (RTC_SPRCTL[1]) never detected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Snooper pin event defined by SNOOPEDGE (RTC_SPRCTL[1]) detected.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l07276">7276</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga8a6969d28148afcd58ecbad152d56c73" name="ga8a6969d28148afcd58ecbad152d56c73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a6969d28148afcd58ecbad152d56c73">&#9670;&nbsp;</a></span>RLD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__O uint32_t WWDT_T::RLD</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md444"></a>
RLD</h1>
<h2><a class="anchor" id="autotoc_md445"></a>
Offset: 0x00  Window Watchdog Timer Reload Counter Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]   </td><td class="markdownTableBodyCenter">RLD   </td><td class="markdownTableBodyLeft">Window Watchdog Timer Reload Counter Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Writing 0x00005AA5 to this register will reload the Window Watchdog Timer counter value to 0x3F.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: SW only can write WWDTRLD when WWDT counter value between 0 and WINCMP.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If SW writes WWDTRLD when WWDT counter value larger than WINCMP, WWDT will generate RESET signal.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10457">10457</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga4c3fa8471628dc184c272b5fcd913c0a" name="ga4c3fa8471628dc184c272b5fcd913c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c3fa8471628dc184c272b5fcd913c0a">&#9670;&nbsp;</a></span>RST_SRC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SYS_T::RST_SRC</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md128"></a>
RST_SRC</h1>
<h2><a class="anchor" id="autotoc_md129"></a>
Offset: 0x04  System Reset Source Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">RSTS_POR   </td><td class="markdownTableBodyLeft">The RSTS_POR Flag Is Set By The "Reset Signal" From The Power-On Reset (POR) Module Or Bit CHIP_RST (IPRSTC1[0]) To Indicate The Previous Reset Source    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No reset from POR or CHIP_RST.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Power-on Reset (POR) or CHIP_RST had issued the reset signal to reset the system.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is cleared by writing 1 to it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">RSTS_PAD   </td><td class="markdownTableBodyLeft">The RSTS_PAD Flag Is Set By The "Reset Signal" From The /RESET Pin Or Power Related Reset Sources To Indicate The Previous Reset Source    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No reset from nRESET pin.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The /RESET pin had issued the reset signal to reset the system.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is cleared by writing 1 to it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">RSTS_WDT   </td><td class="markdownTableBodyLeft">The RSTS_WDT Flag Is Set By The "Reset Signal" From The Watchdog Timer Module To Indicate The Previous Reset Source    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No reset from Watchdog Timer.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The Watchdog Timer module had issued the reset signal to reset the system.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is cleared by writing 1 to it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">RSTS_BOD   </td><td class="markdownTableBodyLeft">The RSTS_BOD Flag Is Set By The "Reset Signal" From The Brown-Out-Detected Module To Indicate The Previous Reset Source    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No reset from BOD.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Brown-out-Detected module had issued the reset signal to reset the system.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is cleared by writing 1 to it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">RSTS_SYS   </td><td class="markdownTableBodyLeft">The RSTS_SYS Flag Is Set By The "Reset Signal" From The Cortex_M0 Kernel To Indicate The Previous Reset Source    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No reset from Cortex_M0.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Cortex_M0 had issued the reset signal to reset the system by writing 1 to the bit SYSRESTREQ(AIRCR[2], Application Interrupt and Reset Control Register) in system control registers of Cortex_M0 kernel.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is cleared by writing 1 to it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">RSTS_CPU   </td><td class="markdownTableBodyLeft">The RSTS_CPU Flag Is Set By Hardware If Software Writes CPU_RST (IPRST_CTL1[1]) "1" To Rest Cortex-M0 Core And Flash Memory Controller (FMC)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No reset from CPU.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Cortex-M0 core and FMC are reset by software setting CPU_RST to 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is cleared by writing 1 to it.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l02726">2726</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gac76855ed7d26898428b9eb077c0c92d9" name="gac76855ed7d26898428b9eb077c0c92d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac76855ed7d26898428b9eb077c0c92d9">&#9670;&nbsp;</a></span>RVCR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t ACMP_T::RVCR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md4"></a>
RVCR</h1>
<h2><a class="anchor" id="autotoc_md5"></a>
Offset: 0x0C  Analog Comparator Reference Voltage Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3:0]   </td><td class="markdownTableBodyCenter">CRVS   </td><td class="markdownTableBodyLeft">Comparator Reference Voltage Setting    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Comparator reference voltage = VIN * (1/6+CRVS[3:0]/24). VIN = AVDD or Int_VREF.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">CRV_EN   </td><td class="markdownTableBodyLeft">CRV Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = CRV Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = CRV Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">CRVSRC_SEL   </td><td class="markdownTableBodyLeft">CRV Source Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = From AVDD.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = From Int_VREF.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l00249">249</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga7c47737acb74f2f2d9349a981d095b57" name="ga7c47737acb74f2f2d9349a981d095b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c47737acb74f2f2d9349a981d095b57">&#9670;&nbsp;</a></span>RX0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t SPI_T::RX0</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md378"></a>
RX0</h1>
<h2><a class="anchor" id="autotoc_md379"></a>
Offset: 0x10  SPI Receive Data FIFO Register 0</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]   </td><td class="markdownTableBodyCenter">RDATA   </td><td class="markdownTableBodyLeft">Receive Data FIFO Bits(Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The received data can be read on it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the FIFO bit is set as 1, the user also checks the RX_EMPTY, SPI_STATUS[0], to check if there is any more received data or not.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: The SPI_RX1 is used only in TWOB bit (SPI_CTL[22]) is set 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The first channel's received data shall be read from SPI_RX0 and the second channel's received data shall be read from SPI_RX1 in two-bit mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SPI_RX0 shall be read first in TWOB mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In FIFO and two-bit mode, the first read back data in SPI_RX0 is the first channel data and the second read back data in SPI_RX0 is the second channel data.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: These registers are read only.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l08703">8703</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga62ec07fe66de05dbcb70bcce2a1f3272" name="ga62ec07fe66de05dbcb70bcce2a1f3272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62ec07fe66de05dbcb70bcce2a1f3272">&#9670;&nbsp;</a></span>RX1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t SPI_T::RX1</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md380"></a>
RX1</h1>
<h2><a class="anchor" id="autotoc_md381"></a>
Offset: 0x14  SPI Receive Data FIFO Register 1</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]   </td><td class="markdownTableBodyCenter">RDATA   </td><td class="markdownTableBodyLeft">Receive Data FIFO Bits(Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The received data can be read on it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the FIFO bit is set as 1, the user also checks the RX_EMPTY, SPI_STATUS[0], to check if there is any more received data or not.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: The SPI_RX1 is used only in TWOB bit (SPI_CTL[22]) is set 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The first channel's received data shall be read from SPI_RX0 and the second channel's received data shall be read from SPI_RX1 in two-bit mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SPI_RX0 shall be read first in TWOB mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In FIFO and two-bit mode, the first read back data in SPI_RX0 is the first channel data and the second read back data in SPI_RX0 is the second channel data.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: These registers are read only.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l08721">8721</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga7563fb74bf39715685191219c1917615" name="ga7563fb74bf39715685191219c1917615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7563fb74bf39715685191219c1917615">&#9670;&nbsp;</a></span>SADDR0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t I2C_T::SADDR0</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md210"></a>
SADDR0</h1>
<h2><a class="anchor" id="autotoc_md211"></a>
Offset: 0x18  I2C Slave address Register0</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">GCALL   </td><td class="markdownTableBodyLeft">General Call Function    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = General Call Function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = General Call Function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[7:1]   </td><td class="markdownTableBodyCenter">SADDR   </td><td class="markdownTableBodyLeft">I2C Salve Address Bits    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The content of this register is irrelevant when the device is in Master mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In the Slave mode, the seven most significant bits must be loaded with the device's own address.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The device will react if either of the address is matched.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l05021">5021</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga5aaa84688133cbe054ad75fa00130648" name="ga5aaa84688133cbe054ad75fa00130648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5aaa84688133cbe054ad75fa00130648">&#9670;&nbsp;</a></span>SADDR1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t I2C_T::SADDR1</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md212"></a>
SADDR1</h1>
<h2><a class="anchor" id="autotoc_md213"></a>
Offset: 0x1C  I2C Slave address Register1</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">GCALL   </td><td class="markdownTableBodyLeft">General Call Function    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = General Call Function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = General Call Function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[7:1]   </td><td class="markdownTableBodyCenter">SADDR   </td><td class="markdownTableBodyLeft">I2C Salve Address Bits    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The content of this register is irrelevant when the device is in Master mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In the Slave mode, the seven most significant bits must be loaded with the device's own address.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The device will react if either of the address is matched.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l05038">5038</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaf53d28d3d8ac5a0ab9a92a127a557b2d" name="gaf53d28d3d8ac5a0ab9a92a127a557b2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf53d28d3d8ac5a0ab9a92a127a557b2d">&#9670;&nbsp;</a></span>SAMASK0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t I2C_T::SAMASK0</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md214"></a>
SAMASK0</h1>
<h2><a class="anchor" id="autotoc_md215"></a>
Offset: 0x28  I2C Slave address Mask Register0</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:1]   </td><td class="markdownTableBodyCenter">SAMASK   </td><td class="markdownTableBodyLeft">I2C Slave Address Mask Bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Mask disable (the received corresponding register bit should be exact the same as address register).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Mask enable (the received corresponding address bit is don't care).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l05053">5053</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga1a530f5050894501e7bc05d48cdf0dc9" name="ga1a530f5050894501e7bc05d48cdf0dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a530f5050894501e7bc05d48cdf0dc9">&#9670;&nbsp;</a></span>SAMASK1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t I2C_T::SAMASK1</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md216"></a>
SAMASK1</h1>
<h2><a class="anchor" id="autotoc_md217"></a>
Offset: 0x2C  I2C Slave address Mask Register1</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:1]   </td><td class="markdownTableBodyCenter">SAMASK   </td><td class="markdownTableBodyLeft">I2C Slave Address Mask Bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Mask disable (the received corresponding register bit should be exact the same as address register).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Mask enable (the received corresponding address bit is don't care).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l05066">5066</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gac03cbcb60bd8f61f401bc492a5082aa5" name="gac03cbcb60bd8f61f401bc492a5082aa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac03cbcb60bd8f61f401bc492a5082aa5">&#9670;&nbsp;</a></span>SAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PDMA_T::SAR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md94"></a>
SAR</h1>
<h2><a class="anchor" id="autotoc_md95"></a>
Offset: 0x04  PDMA Source Address Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]   </td><td class="markdownTableBodyCenter">PDMA_SAR   </td><td class="markdownTableBodyLeft">PDMA Transfer Source Address Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field indicates a 32-bit source address of PDMA.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: The source address must be word alignment.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l02127">2127</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga3bb69708797f658b773cd864e48e4c0b" name="ga3bb69708797f658b773cd864e48e4c0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bb69708797f658b773cd864e48e4c0b">&#9670;&nbsp;</a></span>SEED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t DMA_CRC_T::SEED</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md80"></a>
SEED</h1>
<h2><a class="anchor" id="autotoc_md81"></a>
Offset: 0x84  DMA CRC Seed Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]   </td><td class="markdownTableBodyCenter">CRC_SEED   </td><td class="markdownTableBodyLeft">CRC Seed Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field indicates the CRC seed value.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l01900">1900</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaacf17b4088c0c6fa8bb82f567bfebf32" name="gaacf17b4088c0c6fa8bb82f567bfebf32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacf17b4088c0c6fa8bb82f567bfebf32">&#9670;&nbsp;</a></span>SMPLCNT0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t ADC_T::SMPLCNT0</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md28"></a>
SMPLCNT0</h1>
<h2><a class="anchor" id="autotoc_md29"></a>
Offset: 0x70  ADC Channel Sampling Time  Counter Register Group 0</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3:0]   </td><td class="markdownTableBodyCenter">CH0SAMPCNT   </td><td class="markdownTableBodyLeft">Channel 0 Sampling Counter    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = 0 ADC clock    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0001 = 1 ADC clock    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0010 = 2 ADC clocks    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0011 = 4 ADC clocks    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0100 = 8 ADC clocks    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0101 = 16 ADC clocks    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0110 = 32 ADC clocks    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0111 = 64 ADC clocks    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = 128 ADC clocks    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1001 = 256 ADC clocks    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1010 = 512 ADC clocks    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others = 1024 ADC clocks    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[7:4]   </td><td class="markdownTableBodyCenter">CH1SAMPCNT   </td><td class="markdownTableBodyLeft">Channel 1 Sampling Counter    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The same as Channel 0 sampling counter table.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[11:8]   </td><td class="markdownTableBodyCenter">CH2SAMPCNT   </td><td class="markdownTableBodyLeft">Channel 2 Sampling Counter    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The same as Channel 0 sampling counter table.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[15:12]   </td><td class="markdownTableBodyCenter">CH3SAMPCNT   </td><td class="markdownTableBodyLeft">Channel 3 Sampling Counter    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The same as Channel 0 sampling counter table.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[19:16]   </td><td class="markdownTableBodyCenter">CH4SAMPCNT   </td><td class="markdownTableBodyLeft">Channel 4 Sampling Counter    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The same as Channel 0 sampling counter table.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[23:20]   </td><td class="markdownTableBodyCenter">CH5SAMPCNT   </td><td class="markdownTableBodyLeft">Channel 5 Sampling Counter    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The same as Channel 0 sampling counter table.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[27:24]   </td><td class="markdownTableBodyCenter">CH6SAMPCNT   </td><td class="markdownTableBodyLeft">Channel 6 Sampling Counter    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The same as Channel 0 sampling counter table.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[31:28]   </td><td class="markdownTableBodyCenter">CH7SAMPCNT   </td><td class="markdownTableBodyLeft">Channel 7 Sampling Counter    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The same as Channel 0 sampling counter table.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l00746">746</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gad48be5bda281d3f56570e57f2583de37" name="gad48be5bda281d3f56570e57f2583de37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad48be5bda281d3f56570e57f2583de37">&#9670;&nbsp;</a></span>SMPLCNT1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t ADC_T::SMPLCNT1</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md30"></a>
SMPLCNT1</h1>
<h2><a class="anchor" id="autotoc_md31"></a>
Offset: 0x74  ADC Channel Sampling Time  Counter Register Group 1</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[19:16]   </td><td class="markdownTableBodyCenter">INTCHSAMPCNT   </td><td class="markdownTableBodyLeft">Internal Channel (VTEMP, AVDD, AVSS, Int_VREF) Sampling Counter    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The same as Channel 0 sampling counter table.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l00758">758</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gac9b4363cbc9fa5e227122d0d9852830b" name="gac9b4363cbc9fa5e227122d0d9852830b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9b4363cbc9fa5e227122d0d9852830b">&#9670;&nbsp;</a></span>SP_DET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t CLK_T::SP_DET</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md60"></a>
SP_DET</h1>
<h2><a class="anchor" id="autotoc_md61"></a>
Offset: 0x3C  Clock Stop Detect Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">HCLK_DET   </td><td class="markdownTableBodyLeft">HCLK Stop Detect Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = HCLK stop detect Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = HCLK stop detect Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Once HCLK stop detected, hardware will force HCLK from LIRC.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">HCLK_STOP_IE   </td><td class="markdownTableBodyLeft">HCLK Stop Detect Interrupt Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = HCLK stop detect interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = HCLK stop detect interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">HXT_DET   </td><td class="markdownTableBodyLeft">HXT Stop Detect Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = HXT stop detect Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = HXT stop detect Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">HXT_STOP_IE   </td><td class="markdownTableBodyLeft">HXT Stop Detect Interrupt Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = HXT stop detect interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = HXT stop detect interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">HIRC_DET   </td><td class="markdownTableBodyLeft">HIRC Stop Detect Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = HIRC stop detect Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = HIRC stop detect Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">HIRC_STOP_IE   </td><td class="markdownTableBodyLeft">HIRC Stop Detect Interrupt Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = HIRC stop detect interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = HIRC stop detect interrupt Enabled.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l01403">1403</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga9f3cf7cd93cbac6e644e7ba6192f0c6c" name="ga9f3cf7cd93cbac6e644e7ba6192f0c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f3cf7cd93cbac6e644e7ba6192f0c6c">&#9670;&nbsp;</a></span>SP_STS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t CLK_T::SP_STS</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md62"></a>
SP_STS</h1>
<h2><a class="anchor" id="autotoc_md63"></a>
Offset: 0x40  Clock Stop Detect Status Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">HCLK_SP_IS   </td><td class="markdownTableBodyLeft">HCLK Clock Stop Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = HCLK normal.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = HCLK abnormal.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">HXT_SP_IS   </td><td class="markdownTableBodyLeft">HXT Stop Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = HXT normal.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = HXT abnormal.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">HIRC_SP_IS   </td><td class="markdownTableBodyLeft">HIRC Stop Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = HIRC normal.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = HIRC abnormal.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[10:8]   </td><td class="markdownTableBodyCenter">HCLK_SEL   </td><td class="markdownTableBodyLeft">HCLK Target Clock Select    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">000 = HXT    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">001 = LXT    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">010 = PLL Clock    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">011 = LIRC    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">111 = HIRC    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others = Reserved   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l01429">1429</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga8c5f556996172ac3fe01a48548ce8f83" name="ga8c5f556996172ac3fe01a48548ce8f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c5f556996172ac3fe01a48548ce8f83">&#9670;&nbsp;</a></span>SPR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t RTC_T::SPR[20]</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md334"></a>
SPR0</h1>
<h2><a class="anchor" id="autotoc_md335"></a>
Offset: 0x40 ~ 0x8C  RTC Spare Register 0 ~ 19</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]   </td><td class="markdownTableBodyCenter">SPARE   </td><td class="markdownTableBodyLeft">SPARE    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field is used to store back-up information defined by software.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field will be cleared by hardware automatically once a snooper pin event is detected.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l07338">7338</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gac35296c5363050bac2547534960088a9" name="gac35296c5363050bac2547534960088a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac35296c5363050bac2547534960088a9">&#9670;&nbsp;</a></span>SPRCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t RTC_T::SPRCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md332"></a>
SPRCTL</h1>
<h2><a class="anchor" id="autotoc_md333"></a>
Offset: 0x3C  RTC Spare Functional Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">SNOOPEN   </td><td class="markdownTableBodyLeft">Snooper Pin Event Detection Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit enables the snooper pin event detection.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When this bit is set high and an event defined by SNOOPEDGE detected, the 20 spare registers will be cleared to "0" by hardware automatically.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">And, the SNOOPIF will also be set.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In addition, RTC will also generate wake-up event to wake system up.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Snooper pin event detection function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Snooper pin event detection function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">SNOOPEDGE   </td><td class="markdownTableBodyLeft">Snooper Active Edge Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit defines which edge of snooper pin will generate a snooper pin detected event to clear the 20 spare registers.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Rising edge of snooper pin generates snooper pin detected event.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Falling edge of snooper pin generates snooper pin detected event.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l07325">7325</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga852606aa3333cffd3dc4c9ed4ff32a61" name="ga852606aa3333cffd3dc4c9ed4ff32a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga852606aa3333cffd3dc4c9ed4ff32a61">&#9670;&nbsp;</a></span>SR <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t ACMP_T::SR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md2"></a>
SR</h1>
<h2><a class="anchor" id="autotoc_md3"></a>
Offset: 0x08  Analog Comparator Status Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">ACMPF0   </td><td class="markdownTableBodyLeft">Comparator ACMP0 Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set by hardware whenever the comparator 0 output changes state.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This will generate an interrupt if ACMP0IE set.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Write "1" to clear this bit to 0.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">ACMPF1   </td><td class="markdownTableBodyLeft">Comparator ACMP1 Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set by hardware whenever the comparator 1 output changes state.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This will generate an interrupt if ACMP1IE set.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Write "1" to clear this bit to 0.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">CO0   </td><td class="markdownTableBodyLeft">Comparator ACMP0 Output    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Synchronized to the PCLK to allow reading by software.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Cleared when the comparator is disabled (ACMP0EN = 0).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">CO1   </td><td class="markdownTableBodyLeft">Comparator ACMP1 Output    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Synchronized to the PCLK to allow reading by software.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Cleared when the comparator is disabled (ACMP1EN = 0).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l00231">231</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaabf9e91cd1c93268d5030303b872eecf" name="gaabf9e91cd1c93268d5030303b872eecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabf9e91cd1c93268d5030303b872eecf">&#9670;&nbsp;</a></span>SR <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t ADC_T::SR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md18"></a>
SR</h1>
<h2><a class="anchor" id="autotoc_md19"></a>
Offset: 0x58  A/D Status Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">ADF   </td><td class="markdownTableBodyLeft">A/D Conversion End Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">A status flag that indicates the end of A/D conversion.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">ADF is set to 1 at these two conditions:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When A/D conversion ends in single mode    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When A/D conversion ends on all specified channels in scan mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This flag can be cleared by writing 1 to it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">CMPF0   </td><td class="markdownTableBodyLeft">Compare Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the selected channel A/D conversion result meets setting condition in ADCMPR0 then this bit is set to 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">And it is cleared by writing 1 to self.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Conversion result in ADC_RESULTx does not meet ADCMPR0setting.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Conversion result in ADC_RESULTx meets ADCMPR0setting.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This flag can be cleared by writing 1 to it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When this flag is set, the matching counter will be reset to 0,and continue to count when user write 1 to clear CMPF0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">CMPF1   </td><td class="markdownTableBodyLeft">Compare Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the selected channel A/D conversion result meets setting condition in ADCMPR1 then this bit is set to 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">And it is cleared by writing 1 to self.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Conversion result in ADC_RESULTx does not meet ADCMPR1 setting.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Conversion result in ADC_RESULTx meets ADCMPR1 setting.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This flag can be cleared by writing 1 to it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: when this flag is set, the matching counter will be reset to 0,and continue to count when user write 1 to clear CMPF1    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">BUSY   </td><td class="markdownTableBodyLeft">BUSY/IDLE    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = A/D converter is in idle state.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = A/D converter is busy at conversion.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is a mirror of ADST bit in ADCR. That is to say if ADST = 1,then BUSY is 1 and vice versa.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It is read only.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[8:4]   </td><td class="markdownTableBodyCenter">CHANNEL   </td><td class="markdownTableBodyLeft">Current Conversion Channel    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This filed reflects current conversion channel when BUSY=1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When BUSY=0, it shows the next channel to be converted.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It is read only.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">INITRDY   </td><td class="markdownTableBodyLeft">ADC Power-Up Sequence Completed    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = ADC not powered up after system reset.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = ADC has been powered up since the last system reset.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit will be set after system reset occurred and automatically cleared by power-up event.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l00634">634</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gacd5d65619694a5df1436bb9bc1f548d4" name="gacd5d65619694a5df1436bb9bc1f548d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd5d65619694a5df1436bb9bc1f548d4">&#9670;&nbsp;</a></span>SSR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SPI_T::SSR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md376"></a>
SSR</h1>
<h2><a class="anchor" id="autotoc_md377"></a>
Offset: 0x0C  SPI Slave Select Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1:0]   </td><td class="markdownTableBodyCenter">SSR   </td><td class="markdownTableBodyLeft">Slave Select Active Register (Master Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If AUTOSS bit (SPI_SSR[3]) is cleared, writing "1" to SSR[0] bit sets the SPISS[0] line to an active state and writing "0" sets the line back to inactive state.(the same as SSR[1] for SPISS[1])    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">AUTOSS = 0.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Both SPISS[1] and SPISS[0] are inactive.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = SPISS[1] is inactive, SPISS[0] is active.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = SPISS[1] is active, SPISS[0] is inactive.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Both SPISS[1] and SPISS[0] are active.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If AUTOSS bit is set, writing "1" to any bit location of this field will select appropriate SPISS[1:0] line to be automatically driven to active state for the duration of the transaction, and will be driven to inactive state for the rest of the time.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(The active level of SPISS[1:0] is specified in SS_LVL).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">AUTOSS =1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Both SPISS[1] and SPISS[0] are inactive.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = SPISS[1] is inactive, SPISS[0] is active on the duration of transaction.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = SPISS[1] is active on the duration of transaction, SPISS[0] is inactive.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Both SPISS[1] and SPISS[0] are active on the duration of transaction.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This interface can only drive one device/slave at a given time.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Therefore, the slaves select of the selected device must be set to its active level before starting any read or write transfer.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: SPISS[0] is also defined as device/slave select input in Slave mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">And that the slave select input must be driven by edge active trigger which level depend on the SS_LVL setting, otherwise the SPI slave core will go into dead path until the edge active triggers again or reset the SPI core by software.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">SS_LVL   </td><td class="markdownTableBodyLeft">Slave Select Active Level    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It defines the active level of device/slave select signal (SPISS[1:0]).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The SPI_SS slave select signal is active Low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The SPI_SS slave select signal is active High.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">AUTOSS   </td><td class="markdownTableBodyLeft">Automatic Slave Selection (Master Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = If this bit is set as "0", slave select signals are asserted and de-asserted by setting and clearing related bits in SSR[1:0] register.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = If this bit is set as "1", SPISS[1:0] signals are generated automatically.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It means that device/slave select signal, which is set in SSR[1:0] register is asserted by the SPI controller when transmit/receive is started, and is de-asserted after each transaction is done.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">SS_LTRIG   </td><td class="markdownTableBodyLeft">Slave Select Level Trigger    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The input slave select signal is edge-trigger.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The slave select signal will be level-trigger.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It depends on SS_LVL to decide the signal is active low or active high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">NOSLVSEL   </td><td class="markdownTableBodyLeft">No Slave Selected In Slave Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is used to ignore the slave select signal in Slave mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The SPI controller can work on 3 wire interface including SPICLK, SPI_MISO, and SPI_MOSI when it is set as a slave device.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The controller is 4-wire bi-direction interface.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The controller is 3-wire bi-direction interface in Slave mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When this bit is set as 1, the controller start to transmit/receive data after the GO_BUSY bit active and the serial clock input.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: In no slave select signal mode, the SS_LTRIG (SPI_SSR[4]) shall be set as "1".    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">SLV_ABORT   </td><td class="markdownTableBodyLeft">Abort In Slave Mode With No Slave Selected    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No force the slave abort.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Force the current transfer done in no slave select mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: It is auto cleared to "0" by hardware when the abort event is active.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">SSTA_INTEN   </td><td class="markdownTableBodyLeft">Slave Start Interrupt Enable Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Transfer start interrupt Disabled in no slave select mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Transaction start interrupt Enabled in no slave select mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It is cleared when the current transfer done or the SLV_START_INTSTS bit cleared (write 1 clear).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">SS_INT_OPT   </td><td class="markdownTableBodyLeft">Slave Select Interrupt Option    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It is used to enable the interrupt when the transfer has done in slave mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No any interrupt, even there is slave select inactive event.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = There is interrupt event when the slave select becomes inactive from active condition.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It is used to inform the user to know that the transaction has finished and the slave select into the inactive state.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l08685">8685</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga45e9c068d3cc966e206bd45c9b04b074" name="ga45e9c068d3cc966e206bd45c9b04b074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45e9c068d3cc966e206bd45c9b04b074">&#9670;&nbsp;</a></span>STATUS <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t I2C_T::STATUS</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md202"></a>
STATUS</h1>
<h2><a class="anchor" id="autotoc_md203"></a>
Offset: 0x08  I2C Status Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]   </td><td class="markdownTableBodyCenter">STATUS   </td><td class="markdownTableBodyLeft">I2C Status Bits (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Indicates the current status code of the bus information.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The detail information about the status is described in the sections of I2C protocol register and operation mode.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l04960">4960</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga4afe2cb0c518f0dff54c05986b987f33" name="ga4afe2cb0c518f0dff54c05986b987f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4afe2cb0c518f0dff54c05986b987f33">&#9670;&nbsp;</a></span>STATUS <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SPI_T::STATUS</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md372"></a>
STATUS</h1>
<h2><a class="anchor" id="autotoc_md373"></a>
Offset: 0x04  SPI Status Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">RX_EMPTY   </td><td class="markdownTableBodyLeft">Received FIFO_EMPTY Status    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Received data FIFO is not empty in the FIFO mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Received data FIFO is empty in the FIFO mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">RX_FULL   </td><td class="markdownTableBodyLeft">Received FIFO_FULL Status    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Received data FIFO is not full in FIFO mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Received data FIFO is full in the FIFO mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">TX_EMPTY   </td><td class="markdownTableBodyLeft">Transmitted FIFO_EMPTY Status    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Transmitted data FIFO is not empty in the FIFO mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 =Transmitted data FIFO is empty in the FIFO mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">TX_FULL   </td><td class="markdownTableBodyLeft">Transmitted FIFO_FULL Status    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Transmitted data FIFO is not full in the FIFO mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Transmitted data FIFO is full in the FIFO mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">LTRIG_FLAG   </td><td class="markdownTableBodyLeft">Level Trigger Accomplish Flag (INTERNAL ONLY)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In Slave mode, this bit indicates whether the received bit number meets the requirement or not after the current transaction done.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The transferred bit length of one transaction does not meet the specified requirement.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The transferred bit length meets the specified requirement which defined in TX_BIT_LEN.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is READ only.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">As the software sets the GO_BUSY bit to 1, the LTRIG_FLAG will be cleared to 0 after 4 SPI engine clock periods plus 1 system clock period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In FIFO mode, this bit is unmeaning.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">SLV_START_INTSTS   </td><td class="markdownTableBodyLeft">Slave Start Interrupt Status    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It is used to dedicate that the transfer has started in Slave mode with no slave select.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Slave started transfer no active.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Transfer has started in Slave mode with no slave select.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It is auto clear by transfer done or writing one clear.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">INTSTS   </td><td class="markdownTableBodyLeft">Interrupt Status    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Transfer is not finished yet.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Transfer is done. The interrupt is requested when the INTEN(SPI_CTL[17]) bit is enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only, but can be cleared by writing "1" to this bit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">RXINT_STS   </td><td class="markdownTableBodyLeft">RX FIFO Threshold Interrupt Status (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RX valid data counts small or equal than RXTHRESHOLD (SPI_FFCTL[27:24]).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RX valid data counts bigger than RXTHRESHOLD.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: If RXINT_EN(SPI_FFCTL[2]) = 1 and RX_INTSTS = 1, SPI will generate interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">RX_OVER_RUN   </td><td class="markdownTableBodyLeft">RX FIFO Over Run Status    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No FIFO is over run.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Receive FIFO over run.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: If SPI receives data when RX FIFO is full, this bit will set to 1, and the received data will dropped.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: This bit will be cleared by writing 1 to it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[10]   </td><td class="markdownTableBodyCenter">TXINT_STS   </td><td class="markdownTableBodyLeft">TX FIFO Threshold Interrupt Status (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = TX valid data counts bigger than TXTHRESHOLD (SPI_FFCTL[31:28].    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = TX valid data counts small or equal than TXTHRESHOLD.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[12]   </td><td class="markdownTableBodyCenter">TIME_OUT_STS   </td><td class="markdownTableBodyLeft">TIMEOUT Interrupt Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = There is not timeout event on the received buffer.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Time out event active in RX FIFO is not empty.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit will be cleared by writing 1 to it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[19:16]   </td><td class="markdownTableBodyCenter">RX_FIFO_CNT   </td><td class="markdownTableBodyLeft">Data counts in RX FIFO (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[23:20]   </td><td class="markdownTableBodyCenter">TX_FIFO_CNT   </td><td class="markdownTableBodyLeft">Data counts in TX FIFO (Read Only)   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l08607">8607</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga2cfcc00c975a3f704c9c006512a218fc" name="ga2cfcc00c975a3f704c9c006512a218fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cfcc00c975a3f704c9c006512a218fc">&#9670;&nbsp;</a></span>STATUS2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t I2C_T::STATUS2</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md220"></a>
STATUS2</h1>
<h2><a class="anchor" id="autotoc_md221"></a>
Offset: 0x44  I2C Status Register 2</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">WKUPIF   </td><td class="markdownTableBodyLeft">Wake-Up Interrupt Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Wake-up flag inactive.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Wake-up flag active.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Software can write 1 to clear this flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">OVERUN   </td><td class="markdownTableBodyLeft">I2C OVER RUN Status Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The received FIFO is not over run when the TWOFF_EN = 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The received FIFO is over run when the TWOFF_EN = 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">UNDERUN   </td><td class="markdownTableBodyLeft">I2C UNDER RUN Status Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The transmitted FIFO is not under run when the TWOFF_EN = 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The transmitted FIFO is under run when the TWOFF_EN = 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">WR_STATUS   </td><td class="markdownTableBodyLeft">I2C Read/Write Status Bit In Address Wakeup Frame    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Write command be record on the address match wakeup frame.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Read command be record on the address match wakeup frame.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">FULL   </td><td class="markdownTableBodyLeft">I2C TWO LEVEL FIFO FULL    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = TX FIFO no full when the TWOFF_EN = 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = TX FIFO full when the TWOFF_EN = 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">EMPTY   </td><td class="markdownTableBodyLeft">I2C TWO LEVEL FIFO EMPTY    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RX FIFO no empty when the TWOFF_EN = 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RX FIFO empty when the TWOFF_EN = 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">BUS_FREE   </td><td class="markdownTableBodyLeft">Bus Free Status    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The bus status in the controller.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = I2C's "Start" condition is detected on the bus.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Bus free and it is released by "STOP" condition or the controller is disabled.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l05126">5126</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga88df6283621250acaa2eb570db9c4d27" name="ga88df6283621250acaa2eb570db9c4d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88df6283621250acaa2eb570db9c4d27">&#9670;&nbsp;</a></span>STS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t WWDT_T::STS</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md450"></a>
STS</h1>
<h2><a class="anchor" id="autotoc_md451"></a>
Offset: 0x0C  Window Watchdog Timer Status Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">IF   </td><td class="markdownTableBodyLeft">WWDT Compare Match Interrupt Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When WWCMP match the WWDT counter, then this bit is set to 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit will be cleared by software write 1 to this bit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">RF   </td><td class="markdownTableBodyLeft">WWDT Reset Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When WWDT counter down count to 0 or write WWDTRLD during WWDT counter larger than WINCMP, chip will be reset and this bit is set to 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Software can write 1 to clear this bit to 0.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10510">10510</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga3aca5cd35bc5b6847d7c3b73b4f90248" name="ga3aca5cd35bc5b6847d7c3b73b4f90248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3aca5cd35bc5b6847d7c3b73b4f90248">&#9670;&nbsp;</a></span>TAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t RTC_T::TAR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md320"></a>
TAR</h1>
<h2><a class="anchor" id="autotoc_md321"></a>
Offset: 0x1C  Time Alarm Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3:0]   </td><td class="markdownTableBodyCenter">1SEC   </td><td class="markdownTableBodyLeft">1 Sec Time Digit of Alarm Setting (0~9)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[6:4]   </td><td class="markdownTableBodyCenter">10SEC   </td><td class="markdownTableBodyLeft">10 Sec Time Digit of Alarm Setting (0~5)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[11:8]   </td><td class="markdownTableBodyCenter">1MIN   </td><td class="markdownTableBodyLeft">1 Min Time Digit of Alarm Setting (0~9)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[14:12]   </td><td class="markdownTableBodyCenter">10MIN   </td><td class="markdownTableBodyLeft">10 Min Time Digit of Alarm Setting (0~5)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[19:16]   </td><td class="markdownTableBodyCenter">1HR   </td><td class="markdownTableBodyLeft">1 Hour Time Digit of Alarm Setting (0~9)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[21:20]   </td><td class="markdownTableBodyCenter">10HR   </td><td class="markdownTableBodyLeft">10 Hour Time Digit of Alarm Setting (0~2)   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l07200">7200</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gac4508d4ae8dda154e5e796090fcafff3" name="gac4508d4ae8dda154e5e796090fcafff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4508d4ae8dda154e5e796090fcafff3">&#9670;&nbsp;</a></span>TCAP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t TIMER_T::TCAP</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md404"></a>
TCAP</h1>
<h2><a class="anchor" id="autotoc_md405"></a>
Offset: 0x18  Timer x Capture Data Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23:0]   </td><td class="markdownTableBodyCenter">CAP   </td><td class="markdownTableBodyLeft">Timer Capture Data Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When TCAP_EN (TMRx_CTL[16]) is set, TCAP_MODE (TMRx_CTL[17]) is 0, TCAP_CNT_MOD (TMRx_CTL[20]) is 0, and the transition of external pin matches the TCAP_EDGE (TMRx_CTL[19:18]) setting, the value of 24-bit up-counting timer will be saved into register TMRx_TCAP.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When TCAP_EN (TMRx_CTL[16]) is set, TCAP_MODE (TMRx_CTL[17]) is 0, TCAP_CNT_MOD (TMRx_CTL[20]) is 1, and the transition of external pin matches the 2nd transition of TCAP_EDGE (TMRx_CTL[19:18]) setting, the value of 24-bit up-counting timer will be saved into register TMRx_TCAP.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">User can read this register to get the counter value.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When a new incoming capture event detected before CPU clearing the TCAP_IS (TMRxISR[1]) status, Timer will keep this filed value unchanged and drop the new capture value.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l09302">9302</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga2d32cd7347384fb469ccb130cebeec32" name="ga2d32cd7347384fb469ccb130cebeec32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d32cd7347384fb469ccb130cebeec32">&#9670;&nbsp;</a></span>TCR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PDMA_T::TCR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md110"></a>
TCR</h1>
<h2><a class="anchor" id="autotoc_md111"></a>
Offset: 0x28  PDMA Timer Counter Setting Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PDMA_TCR   </td><td class="markdownTableBodyLeft">PDMA Timer Count Setting Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Each PDMA channel contains an internal counter.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The internal counter loads the value of PDAM_TCR and starts counting down when setting PDMA_CSRx [TO_EN] register.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PDMA will request interrupt when this internal counter reaches zero and PDMA_IERx[TO_IE] is high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This internal counter will reload and start counting when completing each peripheral request service.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l02262">2262</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gad2860d8f09411d649fea976b3f052b96" name="gad2860d8f09411d649fea976b3f052b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2860d8f09411d649fea976b3f052b96">&#9670;&nbsp;</a></span>TDRA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t SC_T::TDRA</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md362"></a>
TDRA</h1>
<h2><a class="anchor" id="autotoc_md363"></a>
Offset: 0x38  SC Timer Current Data Register A.</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23:0]   </td><td class="markdownTableBodyCenter">TDR0   </td><td class="markdownTableBodyLeft">Timer0 Current Data Register (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field indicates the current count values of timer0.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l08139">8139</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gad3ed821af51ad76506fe3f42769fd187" name="gad3ed821af51ad76506fe3f42769fd187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3ed821af51ad76506fe3f42769fd187">&#9670;&nbsp;</a></span>TDRB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t SC_T::TDRB</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md364"></a>
TDRB</h1>
<h2><a class="anchor" id="autotoc_md365"></a>
Offset: 0x3C  SC Timer Current Data Register B.</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]   </td><td class="markdownTableBodyCenter">TDR1   </td><td class="markdownTableBodyLeft">Timer1 Current Data Register (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field indicates the current count values of timer1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:8]   </td><td class="markdownTableBodyCenter">TDR2   </td><td class="markdownTableBodyLeft">Timer2 Current Data Register (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field indicates the current count values of timer2.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l08153">8153</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaf39e47b38db7eb4fb8ac81670cdc9496" name="gaf39e47b38db7eb4fb8ac81670cdc9496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf39e47b38db7eb4fb8ac81670cdc9496">&#9670;&nbsp;</a></span>TEMPCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SYS_T::TEMPCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md134"></a>
TEMPCTL</h1>
<h2><a class="anchor" id="autotoc_md135"></a>
Offset: 0x20  Temperature Sensor Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">VTEMP_EN   </td><td class="markdownTableBodyLeft">Temperature Sensor Enable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Temperature sensor function Disabled (default).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Temperature sensor function Enabled.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l02833">2833</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga85b903bc70752bcd60f69537e38cb4be" name="ga85b903bc70752bcd60f69537e38cb4be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85b903bc70752bcd60f69537e38cb4be">&#9670;&nbsp;</a></span> <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__O uint32_t  { ... } ::THR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md368"></a>
THR</h1>
<h2><a class="anchor" id="autotoc_md369"></a>
Offset: 0x00  SC Transmit Buffer Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]   </td><td class="markdownTableBodyCenter">THR   </td><td class="markdownTableBodyLeft">Transmit Buffer    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">By writing to this register, the SC sends out an 8-bit data through the TX pin (LSB first).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l07570">7570</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gadfe33df8456b56de687076679cd493f3" name="gadfe33df8456b56de687076679cd493f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfe33df8456b56de687076679cd493f3">&#9670;&nbsp;</a></span>THR <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__O uint32_t SC_T::THR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md368"></a>
THR</h1>
<h2><a class="anchor" id="autotoc_md369"></a>
Offset: 0x00  SC Transmit Buffer Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]   </td><td class="markdownTableBodyCenter">THR   </td><td class="markdownTableBodyLeft">Transmit Buffer    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">By writing to this register, the SC sends out an 8-bit data through the TX pin (LSB first).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l07570">7570</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga001a0fe8a64ffba0713c74fd8b8d469f" name="ga001a0fe8a64ffba0713c74fd8b8d469f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga001a0fe8a64ffba0713c74fd8b8d469f">&#9670;&nbsp;</a></span> <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__O uint32_t  { ... } ::THR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md436"></a>
THR</h1>
<h2><a class="anchor" id="autotoc_md437"></a>
Offset: 0x00  UART Transmit Buffer Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]   </td><td class="markdownTableBodyCenter">THR   </td><td class="markdownTableBodyLeft">Transmit Buffer    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">By writing to this register, the UART sends out an 8-bit data through the TX pin (LSB first).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l09509">9509</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gab2c575051f74234158db4c2627172943" name="gab2c575051f74234158db4c2627172943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2c575051f74234158db4c2627172943">&#9670;&nbsp;</a></span>THR <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__O uint32_t UART_T::THR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md436"></a>
THR</h1>
<h2><a class="anchor" id="autotoc_md437"></a>
Offset: 0x00  UART Transmit Buffer Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]   </td><td class="markdownTableBodyCenter">THR   </td><td class="markdownTableBodyLeft">Transmit Buffer    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">By writing to this register, the UART sends out an 8-bit data through the TX pin (LSB first).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l09509">9509</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga52b6efc5dbbc798e6ed525e3875e3a40" name="ga52b6efc5dbbc798e6ed525e3875e3a40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52b6efc5dbbc798e6ed525e3875e3a40">&#9670;&nbsp;</a></span>TLCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t UART_T::TLCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md410"></a>
TLCTL</h1>
<h2><a class="anchor" id="autotoc_md411"></a>
Offset: 0x08  UART Transfer Line Control Register.</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1:0]   </td><td class="markdownTableBodyCenter">DATA_LEN   </td><td class="markdownTableBodyLeft">Data Length    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = 5 bits.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = 6 bits.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = 7 bits.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = 8 bits.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">NSB   </td><td class="markdownTableBodyLeft">Number Of STOP Bit Length    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = 1.5 "STOP bit" is generated in the transmitted data when 5-bit word length is selected, and 2 STOP bit" is generated when 6, 7 and 8 bits data length is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = 1 " STOP bit" is generated in the transmitted data.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">PBE   </td><td class="markdownTableBodyLeft">Parity Bit Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Parity bit is generated or checked between the "last data"word "it" and "stop bit" of the serial data.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Parity bit is not generated (transmitting data) or checked (receiving data) during transfer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">EPE   </td><td class="markdownTableBodyLeft">Even Parity Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Even number of logic 1's are transmitted or check the data word and parity bits in receiving mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Odd number of logic 1's are transmitted or check the data word and parity bits in receiving mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit has effect only when PBE bit (parity bit enable) is set.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">SPE   </td><td class="markdownTableBodyLeft">Stick Parity Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = When bits PBE, EPE and SPE are set, the parity bit is transmitted and checked as "0".    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When PBE and SPE are set and EPE is cleared, the parity bit is transmitted and checked as "1".    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In RS-485 mode, PBE, EPE and SPE can control bit 9.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Stick parity Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">BCB   </td><td class="markdownTableBodyLeft">Break Control Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When this bit is set to logic "1", the serial data output (TX) is forced to the Spacing State (logic "0").    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit acts only on TX pin and has no effect on the transmitter logic.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Break control Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Break control Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[9:8]   </td><td class="markdownTableBodyCenter">RFITL   </td><td class="markdownTableBodyLeft">RX-FIFO Interrupt (INT_RDA) Trigger Level    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the number of bytes in the receiving FIFO is equal to the RFITL then the RDA_IF will be set (if RDA_IE(IER[0]) is enabled, an interrupt will be generated)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = RX FIFO Interrupt Trigger Level is 1 byte.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = RX FIFO Interrupt Trigger Level is 4 bytes.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = RX FIFO Interrupt Trigger Level is 8 bytes.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = RX FIFO Interrupt Trigger Level is 14 bytes.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When operating in IrDA mode or RS-485 mode, the RFITL must be set to "0".    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[13:12]   </td><td class="markdownTableBodyCenter">RTS_TRI_LEV   </td><td class="markdownTableBodyLeft">RTSn Trigger Level (For Auto-Flow Control Use)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = RTS Trigger Level is 1 byte.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = RTS Trigger Level is 4 bytes.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = RTS Trigger Level is 8 bytes.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = RTS Trigger Level is 14 bytes.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This field is used for auto RTSn flow control.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l09629">9629</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaaa06624870e1a72d15e39316ba0a581c" name="gaaa06624870e1a72d15e39316ba0a581c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa06624870e1a72d15e39316ba0a581c">&#9670;&nbsp;</a></span>TLR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t RTC_T::TLR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md312"></a>
TLR</h1>
<h2><a class="anchor" id="autotoc_md313"></a>
Offset: 0x0C  Time Loading Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3:0]   </td><td class="markdownTableBodyCenter">1SEC   </td><td class="markdownTableBodyLeft">1 Sec Time Digit (0~9)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[6:4]   </td><td class="markdownTableBodyCenter">10SEC   </td><td class="markdownTableBodyLeft">10 Sec Time Digit (0~5)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[11:8]   </td><td class="markdownTableBodyCenter">1MIN   </td><td class="markdownTableBodyLeft">1 Min Time Digit (0~9)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[14:12]   </td><td class="markdownTableBodyCenter">10MIN   </td><td class="markdownTableBodyLeft">10 Min Time Digit (0~5)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[19:16]   </td><td class="markdownTableBodyCenter">1HR   </td><td class="markdownTableBodyLeft">1 Hour Time Digit (0~9)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[21:20]   </td><td class="markdownTableBodyCenter">10HR   </td><td class="markdownTableBodyLeft">10 Hour Time Digit (0~2)   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l07136">7136</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga69e6fb451dbef4b45969bac159e8ffc0" name="ga69e6fb451dbef4b45969bac159e8ffc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69e6fb451dbef4b45969bac159e8ffc0">&#9670;&nbsp;</a></span>TMCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t UART_T::TMCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md422"></a>
TMCTL</h1>
<h2><a class="anchor" id="autotoc_md423"></a>
Offset: 0x20  UART Time-Out Control State Register.</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[8:0]   </td><td class="markdownTableBodyCenter">TOIC   </td><td class="markdownTableBodyLeft">Time-Out Comparator    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The time-out counter resets and starts counting whenever the RX-FIFO receives a new data word.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: Fill all "0" to this field indicates to disable this function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: The real time-out value is TOIC + 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note3: The counting clock is baud rate clock.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note4: The UART data format is start bit + 8 data bits + parity bit + stop bit, although software can configure this field by any value but it is recommend to filled this field great than 0xA.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23:16]   </td><td class="markdownTableBodyCenter">DLY   </td><td class="markdownTableBodyLeft">TX Delay Time Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field is use to program the transfer delay time between the last stop bit and next start bit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: Fill all "0" to this field indicates to disable this function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: The real delay value is DLY.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note3: The counting clock is baud rate clock.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l09909">9909</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga01050a1b1d9d4f5d872fef305a44d5dc" name="ga01050a1b1d9d4f5d872fef305a44d5dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01050a1b1d9d4f5d872fef305a44d5dc">&#9670;&nbsp;</a></span>TMR0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SC_T::TMR0</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md354"></a>
TMR0</h1>
<h2><a class="anchor" id="autotoc_md355"></a>
Offset: 0x28  SC Internal Timer Control Register 0.</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23:0]   </td><td class="markdownTableBodyCenter">CNT   </td><td class="markdownTableBodyLeft">Timer 0 Counter Value Register (ETU Base)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field indicates the internal timer operation values.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[27:24]   </td><td class="markdownTableBodyCenter">MODE   </td><td class="markdownTableBodyLeft">Timer 0 Operation Mode Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field indicates the internal 24 bit timer operation selection.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l08069">8069</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga8dc7a095b9af5e3c4cc20484b19d5a76" name="ga8dc7a095b9af5e3c4cc20484b19d5a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8dc7a095b9af5e3c4cc20484b19d5a76">&#9670;&nbsp;</a></span>TMR1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SC_T::TMR1</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md356"></a>
TMR1</h1>
<h2><a class="anchor" id="autotoc_md357"></a>
Offset: 0x2C  SC Internal Timer Control Register 1.</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]   </td><td class="markdownTableBodyCenter">CNT   </td><td class="markdownTableBodyLeft">Timer 1 Counter Value Register (ETU Base)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field indicates the internal timer operation values.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[27:24]   </td><td class="markdownTableBodyCenter">MODE   </td><td class="markdownTableBodyLeft">Timer 1 Operation Mode Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field indicates the internal 8 bit timer operation selection.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l08083">8083</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gac5d2aa7e313712f078bc99feeb8249fc" name="gac5d2aa7e313712f078bc99feeb8249fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5d2aa7e313712f078bc99feeb8249fc">&#9670;&nbsp;</a></span>TMR2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SC_T::TMR2</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md358"></a>
TMR2</h1>
<h2><a class="anchor" id="autotoc_md359"></a>
Offset: 0x30  SC Internal Timer Control Register 2.</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]   </td><td class="markdownTableBodyCenter">CNT   </td><td class="markdownTableBodyLeft">Timer 2 Counter Value Register (ETU Base)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field indicates the internal timer operation values.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[27:24]   </td><td class="markdownTableBodyCenter">MODE   </td><td class="markdownTableBodyLeft">Timer 2 Operation Mode Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field indicates the internal 8 bit timer operation selection.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l08097">8097</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga3ea7086ff7e567448f6fa0cf63a1391b" name="ga3ea7086ff7e567448f6fa0cf63a1391b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ea7086ff7e567448f6fa0cf63a1391b">&#9670;&nbsp;</a></span>TOUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t I2C_T::TOUT</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md206"></a>
TOUT</h1>
<h2><a class="anchor" id="autotoc_md207"></a>
Offset: 0x10  I2C Time-out control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">TOUTEN   </td><td class="markdownTableBodyLeft">Time-Out Counter Enable/Disable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When set this bit to enable, the 14 bits time-out counter will start counting when INTSTS (I2CINTSTS[0]) is cleared.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Setting flag STAINTSTS to high or the falling edge of I2C clock or stop signal will reset counter and re-start up counting after INTSTS is cleared.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">DIV4   </td><td class="markdownTableBodyLeft">Time-Out Counter Input Clock Divider By 4    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When Enabled, the time-out period is extended 4 times.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l04992">4992</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaaa543328de43e1099a7641d0e4c8899f" name="gaaa543328de43e1099a7641d0e4c8899f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa543328de43e1099a7641d0e4c8899f">&#9670;&nbsp;</a></span>TRSR <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SC_T::TRSR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md350"></a>
TRSR</h1>
<h2><a class="anchor" id="autotoc_md351"></a>
Offset: 0x20  SC Transfer Status Register.</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">RX_OVER_F   </td><td class="markdownTableBodyLeft">RX Overflow Error Status Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set when RX buffer overflow.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the number of received bytes is greater than RX Buffer (SC_RBR) size, 4 bytes of SC, this bit will be set.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This bit is read only, but it can be cleared by writing "1" to it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: The overwrite data will be ignored.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">RX_EMPTY_F   </td><td class="markdownTableBodyLeft">Receiver Buffer Empty Status Flag(Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates RX buffer empty or not.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the last byte of RX buffer has been read by CPU, hardware sets this bit high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It will be cleared when SC receives any new data.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">RX_FULL_F   </td><td class="markdownTableBodyLeft">Receiver Buffer Full Status Flag (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates RX buffer full or not.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set when RX pointer is equal to 4, otherwise it is cleared by hardware.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">RX_EPA_F   </td><td class="markdownTableBodyLeft">Receiver Parity Error Status Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set to logic "1" whenever the received character does not have a valid "parity bit".    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This bit is read only, but it can be cleared by writing "1" to it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: If CPU sets receiver retries function by setting SC_CTL [RX_ERETRY_EN] register, hardware will not set this flag.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">RX_EFR_F   </td><td class="markdownTableBodyLeft">Receiver Frame Error Status Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set to logic "1" whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as a logic "0").    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This bit is read only, but can be cleared by writing "1" to it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: If CPI sets receiver retries function by setting SC_CTL [RX_ERETRY_EN] register, hardware will not set this flag.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">RX_EBR_F   </td><td class="markdownTableBodyLeft">Receiver Break Error Status Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set to a logic "1" whenever the received data input (RX) held in the "spacing state" (logic "0") is longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This bit is read only, but it can be cleared by writing "1" to it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: If CPU sets receiver retries function by setting SC_CTL [RX_ERETRY_EN] register, hardware will not set this flag.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">TX_OVER_F   </td><td class="markdownTableBodyLeft">TX Overflow Error Interrupt Status Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If TX buffer is full (TX_FULL_F = "1"), an additional write data to SC_THR will cause this bit to logic "1".    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This bit is read only, but it can be cleared by writing "1" to it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: The additional write data will be ignored.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">TX_EMPTY_F   </td><td class="markdownTableBodyLeft">Transmit Buffer Empty Status Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates TX buffer empty or not.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the last byte of TX buffer has been transferred to Transmitter Shift Register, hardware sets this bit high.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It will be cleared when writing data into SC_THR (TX buffer not empty).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[10]   </td><td class="markdownTableBodyCenter">TX_FULL_F   </td><td class="markdownTableBodyLeft">Transmit Buffer Full Status Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates TX buffer full or not.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set when TX pointer is equal to 4, otherwise is cleared by hardware.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[18:16]   </td><td class="markdownTableBodyCenter">RX_POINT_F   </td><td class="markdownTableBodyLeft">Receiver Buffer Pointer Status Flag (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field indicates the RX buffer pointer status flag.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When SC receives one byte from external device, RX_POINT_F increases one.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When one byte of RX buffer is read by CPU, RX_POINT_F decreases one.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[21]   </td><td class="markdownTableBodyCenter">RX_REERR   </td><td class="markdownTableBodyLeft">Receiver Retry Error (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set by hardware when RX has any error and retries transfer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This bit is read only, but it can be cleared by writing "1" to it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2 This bit is a flag and can not generate any interrupt to CPU.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note3: If CPU enables receiver retry function by setting SC_CTL [RX_ERETRY_EN] register, the RX_EPA_F flag will be ignored (hardware will not set RX_EPA_F).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[22]   </td><td class="markdownTableBodyCenter">RX_OVER_ERETRY   </td><td class="markdownTableBodyLeft">Receiver Over Retry Error (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set by hardware when RX transfer error retry over retry number limit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This bit is read only, but it can be cleared by writing "1" to it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: If CPU enables receiver retries function by setting SC_CTL [RX_ERETRY_EN] register, the RX_EPA_F flag will be ignored (hardware will not set RX_EPA_F).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23]   </td><td class="markdownTableBodyCenter">RX_ATV   </td><td class="markdownTableBodyLeft">Receiver In Active Status Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set by hardware when RX transfer is in active.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is cleared automatically when RX transfer is finished.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[26:24]   </td><td class="markdownTableBodyCenter">TX_POINT_F   </td><td class="markdownTableBodyLeft">Transmit Buffer Pointer Status Flag (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field indicates the TX buffer pointer status flag.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When CPU writes data into SC_THR, TX_POINT_F increases one.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When one byte of TX Buffer is transferred to transmitter shift register, TX_POINT_F decreases one.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[29]   </td><td class="markdownTableBodyCenter">TX_REERR   </td><td class="markdownTableBodyLeft">Transmitter Retry Error (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set by hardware when transmitter re-transmits.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This bit is read only, but it can be cleared by writing "1" to it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2 This bit is a flag and can not generate any interrupt to CPU.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[30]   </td><td class="markdownTableBodyCenter">TX_OVER_ERETRY   </td><td class="markdownTableBodyLeft">Transmitter Over Retry Error (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set by hardware when transmitter re-transmits over retry number limitation.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only, but it can be cleared by writing "1" to it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31]   </td><td class="markdownTableBodyCenter">TX_ATV   </td><td class="markdownTableBodyLeft">Transmit In Active Status Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set by hardware when TX transfer is in active or the last byte transmission has not completed.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is cleared automatically when TX transfer is finished and the STOP bit (include guard time) has been transmitted.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l07979">7979</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga4297386c5926124fc6441172a68f844d" name="ga4297386c5926124fc6441172a68f844d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4297386c5926124fc6441172a68f844d">&#9670;&nbsp;</a></span>TRSR <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t UART_T::TRSR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md416"></a>
TRSR</h1>
<h2><a class="anchor" id="autotoc_md417"></a>
Offset: 0x14  UART Transfer State Status Register.</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">RS485_ADDET_F   </td><td class="markdownTableBodyLeft">RS-485 Address Byte Detection Status Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set to logic "1" and set RS-485_ADD_EN (UART_ALT_CTL[19]) whenever in RS-485 mode the receiver detected any address byte character (bit 9 ='1') bit".    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is reset whenever the CPU writes "1" to this bit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No RS-485 address detection interrupt is generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RS-485 address detection interrupt is generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This field is used for RS-485 mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: This bit is read only, but can be cleared by writing "1" to it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">ABAUD_F   </td><td class="markdownTableBodyLeft">Auto-Baud Rate Interrupt (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set to logic "1" when auto-baud rate detect function finished.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No Auto- Baud Rate interrupt is generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1= Auto-Baud Rate interrupt is generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only, but can be cleared by writing "1" to it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">ABAUD_TOUT_F   </td><td class="markdownTableBodyLeft">Auto-Baud Rate Time-Out Interrupt (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set to logic "1" in Auto-baud Rate Detect mode and the baud rate counter is overflow.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No Auto-Baud Rate Time-Out interrupt is generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Auto-Baud Rate Time-Out interrupt is generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only, but can be cleared by writing "1" to it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">LIN_TX_F   </td><td class="markdownTableBodyLeft">LIN TX Interrupt Flag (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set to logic "1" when LIN transmitted header field.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The header may be "break field" or "break field + sync field" or "break field + sync field + PID field", it can be choose by setting LIN_HEAD_SEL (UART_ALT_CTL[5:4]) register.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No LIN Tx interrupt is generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = LIN Tx interrupt is generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only, but can be cleared by writing "1" to it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">LIN_RX_F   </td><td class="markdownTableBodyLeft">LIN RX Interrupt Flag (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set to logic "1" when received LIN header field.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The header may be "break field" or "break field + sync field" or "break field + sync field + PID field", and it can be choose by setting LIN_HEAD_SEL (UART_ALT_CTL[5:4]) register.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No LIN Rx interrupt is generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = LIN Rx interrupt is generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only, but can be cleared by writing "1" to it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">BIT_ERR_F   </td><td class="markdownTableBodyLeft">Bit Error Detect Status Flag (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">At TX transfer state, hardware will monitoring the bus state, if the input pin (SIN) state is not equal to the output pin (SOUT) state, BIT_ERR_F will be set.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When occur bit error, hardware will generate an interrupt to CPU (INT_LIN).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No Bit error interrupt is generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Bit error interrupt is generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This bit is read only, but it can be cleared by writing "1" to it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: This bit is only valid when enabling the bit error detection function (BIT_ERR_EN (UART_ALT_CTL[8]) = "1").    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">LIN_RX_SYNC_ERR_F   </td><td class="markdownTableBodyLeft">LIN RX SYNC Error Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set to logic "1" when LIN received incorrect SYNC field.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">User can choose the header by setting LIN_HEAD_SEL (UART_ALT_CTL[5:4]) register.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No LIN Rx sync error is generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = LIN Rx sync error is generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only, but can be cleared by writing "1" to LIN_RX_F.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l09784">9784</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="gaf061c521c29b57af2654b536c9ee976c" name="gaf061c521c29b57af2654b536c9ee976c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf061c521c29b57af2654b536c9ee976c">&#9670;&nbsp;</a></span>TSSR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t RTC_T::TSSR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md316"></a>
TSSR</h1>
<h2><a class="anchor" id="autotoc_md317"></a>
Offset: 0x14  Time Scale Selection Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">24hr_12hr   </td><td class="markdownTableBodyLeft">24-Hour / 12-Hour Mode Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It indicates that TLR and TAR are in 24-hour mode or 12-hour mode    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = select 12-hour time scale with AM and PM indication.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = select 24-hour time scale.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l07166">7166</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga017c4ea5adc9a4fd9e837ace5ad3544c" name="ga017c4ea5adc9a4fd9e837ace5ad3544c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga017c4ea5adc9a4fd9e837ace5ad3544c">&#9670;&nbsp;</a></span>TTR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t RTC_T::TTR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md330"></a>
TTR</h1>
<h2><a class="anchor" id="autotoc_md331"></a>
Offset: 0x30  RTC Time Tick Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2:0]   </td><td class="markdownTableBodyCenter">TTR   </td><td class="markdownTableBodyLeft">Time Tick Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The RTC time tick period for Periodic Time Tick Interrupt request.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">000 = 1 tick/second.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">001 = 1/2 tick/second.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">010 = 1/4 tick/second.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">011 = 1/8 tick/second.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">100 = 1/16 tick/second.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">101 = 1/32 tick/second.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">110 = 1/64 tick/second.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">111 = 1/128 tick/second.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This register can be read back after the RTC is active by AER.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">TWKE   </td><td class="markdownTableBodyLeft">RTC Timer Wake-Up CPU Function Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If TWKE is set before CPU enters power-down mode, when a RTC Time Tick, CPU will be wakened up by RTC unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Time Tick wake-up CPU function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Wake-up function Enabled so that CPU can be waken up from Power-down mode by Time Tick.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Tick timer setting follows the TTR ( RTC_TTR[2:0]) description.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l07302">7302</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga2e6b1c45e89186b0b38d4d5a03dfa063" name="ga2e6b1c45e89186b0b38d4d5a03dfa063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e6b1c45e89186b0b38d4d5a03dfa063">&#9670;&nbsp;</a></span>TX0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__O uint32_t SPI_T::TX0</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md382"></a>
TX0</h1>
<h2><a class="anchor" id="autotoc_md383"></a>
Offset: 0x20  SPI Transmit Data FIFO Register 0</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]   </td><td class="markdownTableBodyCenter">TDATA   </td><td class="markdownTableBodyLeft">Transmit Data FIFO Bits(Write Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The Data Transmit Registers hold the data to be transmitted in the next transfer.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The number of valid bits depends on the setting of transmit bit length field of the SPI_CTL register.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For example, if TX_BIT_LEN is set to 0x8, the bit SPI_TX[7:0] will be transmitted in next transfer.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If TX_BIT_LEN is set to 0x0, the SPI controller will perform a 32-bit transfer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: The SPI_TX1 is used only in TWOB bit (SPI_CTL[22]) is set 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The first channel's transmitted data shall be written into SPI_TX0 and the second channel's transmitted data shall be written into SPI_TX1 in two-bit mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SPI_TX0 shall be written first in TWOB mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In FIFO and two-bit mode, the first written into data in SPI_TX0 is the first channel's transmitted data and the second written data in SPI_RX0 is the second channel's transmitted data.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: When the SPI controller is configured as a slave device and the FIFO mode is disabled, if the SPI controller attempts to transmit data to a master, the software must update the transmit data register before setting the GO_BUSY bit to 1.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l08743">8743</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga390d2928ba639001d0282683b53ceaf3" name="ga390d2928ba639001d0282683b53ceaf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga390d2928ba639001d0282683b53ceaf3">&#9670;&nbsp;</a></span>TX1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__O uint32_t SPI_T::TX1</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md384"></a>
TX1</h1>
<h2><a class="anchor" id="autotoc_md385"></a>
Offset: 0x24  SPI Transmit Data FIFO Register 1</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]   </td><td class="markdownTableBodyCenter">TDATA   </td><td class="markdownTableBodyLeft">Transmit Data FIFO Bits(Write Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The Data Transmit Registers hold the data to be transmitted in the next transfer.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The number of valid bits depends on the setting of transmit bit length field of the SPI_CTL register.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For example, if TX_BIT_LEN is set to 0x8, the bit SPI_TX[7:0] will be transmitted in next transfer.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If TX_BIT_LEN is set to 0x0, the SPI controller will perform a 32-bit transfer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: The SPI_TX1 is used only in TWOB bit (SPI_CTL[22]) is set 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The first channel's transmitted data shall be written into SPI_TX0 and the second channel's transmitted data shall be written into SPI_TX1 in two-bit mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SPI_TX0 shall be written first in TWOB mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In FIFO and two-bit mode, the first written into data in SPI_TX0 is the first channel's transmitted data and the second written data in SPI_RX0 is the second channel's transmitted data.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: When the SPI controller is configured as a slave device and the FIFO mode is disabled, if the SPI controller attempts to transmit data to a master, the software must update the transmit data register before setting the GO_BUSY bit to 1.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l08763">8763</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga35c7fa9d62529991f3e3b737945db3a4" name="ga35c7fa9d62529991f3e3b737945db3a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35c7fa9d62529991f3e3b737945db3a4">&#9670;&nbsp;</a></span>UACTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SC_T::UACTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md360"></a>
UACTL</h1>
<h2><a class="anchor" id="autotoc_md361"></a>
Offset: 0x34  SC UART Mode Control Register.</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">UA_MODE_EN   </td><td class="markdownTableBodyLeft">UART Mode Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Smart Card mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = UART mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: When operating in UART mode, user must set SCx_CTL [CON_SEL] and SCx_CTL [AUTO_CON_EN] to "0".    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: When operating in smart card mode, user must set SCx_UACTL [7:0] register to "0".    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note3: When UART is enabled, hardware will generate a reset to reset internal buffer and internal state machine.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:4]   </td><td class="markdownTableBodyCenter">DATA_LEN   </td><td class="markdownTableBodyLeft">Data Length    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = 8 bits    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = 7 bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = 6 bits    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = 5 bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: In Smart Card mode, this field must be '00'    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">PBDIS   </td><td class="markdownTableBodyLeft">Parity Bit Disable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Parity bit is generated or checked between the "last data word bit" and "stop bit" of the serial data.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Parity bit is not generated (transmitting data) or checked (receiving data) during transfer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: In Smart Card mode, this field must be '0' (default setting is with parity bit)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">OPE   </td><td class="markdownTableBodyLeft">Odd Parity Enable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Even number of logic 1's are transmitted or check the data word and parity bits in receiving mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Odd number of logic 1's are transmitted or check the data word and parity bits in receiving mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit has effect only when PBDIS bit is '0'.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l08127">8127</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga6a20715644b8a1b46c9600626bffb3b9" name="ga6a20715644b8a1b46c9600626bffb3b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a20715644b8a1b46c9600626bffb3b9">&#9670;&nbsp;</a></span>VAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t WWDT_T::VAL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md452"></a>
WWDTVAL</h1>
<h2><a class="anchor" id="autotoc_md453"></a>
Offset: 0x10  Window Watchdog Timer Counter Value Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">VAL   </td><td class="markdownTableBodyLeft">WWDT Counter Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This register reflects the counter value of window watchdog. This register is read only   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l10522">10522</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga762fced4160de55295b4d0854f24f66d" name="ga762fced4160de55295b4d0854f24f66d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga762fced4160de55295b4d0854f24f66d">&#9670;&nbsp;</a></span>VARCLK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SPI_T::VARCLK</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md386"></a>
VARCLK</h1>
<h2><a class="anchor" id="autotoc_md387"></a>
Offset: 0x34  SPI Variable Clock Pattern Flag Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]   </td><td class="markdownTableBodyCenter">VARCLK   </td><td class="markdownTableBodyLeft">Variable Clock Pattern Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The value in this field is the frequency patterns of the SPICLK.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: It is used for CLKP = 0 only.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l08778">8778</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga119abaa69d99974d66efbb946518e931" name="ga119abaa69d99974d66efbb946518e931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga119abaa69d99974d66efbb946518e931">&#9670;&nbsp;</a></span>WDATA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t DMA_CRC_T::WDATA</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md78"></a>
WDATA</h1>
<h2><a class="anchor" id="autotoc_md79"></a>
Offset: 0x80  DMA CRC Write Data Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]   </td><td class="markdownTableBodyCenter">CRC_WDATA   </td><td class="markdownTableBodyLeft">CRC Write Data Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When operating in CPU PIO (CRC_CTL [CRCCEN] = 1, CRC_CTL [TRIG_EN] = 0) mode, software can write data to this field to perform CRC operation;.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When operating in CRC DMA mode (CRC_CTL [CRCCEN] = 1, CRC_CTL [TRIG_EN] = 0), this field will be used for DMA internal buffer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: When operating in CRC DMA mode, so don't filled any data in this field.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2:The CRC_CTL [WDATA_COM] and CRC_CTL [WDATA_RVS] bit setting will affected this field; For example, if WDATA_RVS = 1, if the write data in CRC_WDATA register is 0xAABBCCDD, the read data from CRC_WDATA register will be 0x55DD33BB   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l01888">1888</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
<a id="ga3aace40aeea86c8dece6918b4e1170d0" name="ga3aace40aeea86c8dece6918b4e1170d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3aace40aeea86c8dece6918b4e1170d0">&#9670;&nbsp;</a></span>WK_INTSTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t CLK_T::WK_INTSTS</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md54"></a>
WK_INTSTS</h1>
<h2><a class="anchor" id="autotoc_md55"></a>
Offset: 0x30  Wake-up Interrupt Status</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">PD_WK_IS   </td><td class="markdownTableBodyLeft">Wake-Up Interrupt Status In Chip Power-Down Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates that some event resumes chip from Power-down mode    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The status is set if external interrupts, UART, GPIO, RTC, USB, SPI, Timer, WDT, and BOD wake-up occurred.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Write 1 to clear this bit.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html#l01336">1336</a> of file <a class="el" href="../../da/d91/_nano1_x2_series_8h_source.html">Nano1X2Series.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Mar 8 2023 11:33:53 for NANO102/112 BSP by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
